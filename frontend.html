<!DOCTYPE html>
<html lang="en" class=""> <!-- Add 'dark' class here for default dark mode -->
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>FLUXNOTEBOOK AI - Modern UI</title>
 <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>">

 <!-- Google Fonts - Poppins & JetBrains Mono -->
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

 <link rel="stylesheet" href="./dist/output.css">
 <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

 <!-- PDF.js Library -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
 <script>
 // Configure PDF.js worker
 pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
 </script>

 <!-- MathJax Configuration (same as before) -->
 <script>
 window.MathJax = {
 tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']], processEscapes: true, packages: {'[+]': ['mhchem']} },
 loader: { load: ['[tex]/mhchem'] },
 svg: { fontCache: 'global' },
 startup: { ready: () => { MathJax.startup.defaultReady(); } }
 };
 </script>
 <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

 <!-- Jitsi Meet API -->
 <script src="https://meet.jit.si/external_api.js"></script>

 <style>
 /* Global font family override */
 * {
 font-family: 'Poppins', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
 }

 /* Enhanced scrollbar styling for chat containers */
 ::-webkit-scrollbar { width: 8px; height: 8px; }
 ::-webkit-scrollbar-track { background: transparent; }
 ::-webkit-scrollbar-thumb {
 background: linear-gradient(135deg, #cbd5e1, #94a3b8);
 border-radius: 6px;
 border: 1px solid rgba(255, 255, 255, 0.1);
 }
 .dark ::-webkit-scrollbar-thumb {
 background: linear-gradient(135deg, #475569, #64748b);
 border: 1px solid rgba(255, 255, 255, 0.05);
 }
 ::-webkit-scrollbar-thumb:hover {
 background: linear-gradient(135deg, #94a3b8, #64748b);
 transform: scale(1.1);
 }
 .dark ::-webkit-scrollbar-thumb:hover {
 background: linear-gradient(135deg, #64748b, #475569);
 }

 /* Specialized scrollbar for chat containers */
 .chat-scroll-container::-webkit-scrollbar {
 width: 6px;
 }
 .chat-scroll-container::-webkit-scrollbar-track {
 background: transparent;
 margin: 4px 0;
 }
 .chat-scroll-container::-webkit-scrollbar-thumb {
 background: rgba(148, 163, 184, 0.5);
 border-radius: 3px;
 transition: all 0.2s ease;

 /* Video Call Mobile Responsive Styles */
 @media (max-width: 768px) {
 #video-call-container {
 max-height: 250px !important;
 }

 #video-participants-container {
 max-height: 190px !important;
 }

 #video-call-header {
 padding: 8px 12px;
 }

 #video-call-header button {
 padding: 6px;
 }

 #video-call-header svg {
 width: 16px;
 height: 16px;
 }

 #jitsi-meet-container {
 height: 190px !important;
 min-height: 190px !important;
 }

 /* Adjust toolbar buttons for mobile */
 .toolbar-button {
 padding: 8px 12px !important;
 font-size: 14px;
 }

 .toolbar-button svg {
 width: 18px !important;
 height: 18px !important;
 margin-right: 6px !important;
 }
 }

 @media (max-width: 480px) {
 #video-call-container {
 max-height: 200px !important;
 }

 #video-participants-container {
 max-height: 140px !important;
 }

 #jitsi-meet-container {
 height: 140px !important;
 min-height: 140px !important;
 }

 #video-call-header {
 flex-wrap: wrap;
 gap: 8px;
 }

 #video-call-header .flex:first-child {
 flex: 1;
 min-width: 0;
 }

 #video-call-text {
 font-size: 12px;
 }

 #video-participants-count {
 font-size: 10px;
 }

 /* Stack toolbar buttons vertically on very small screens */
 .tool-group-wrapper .flex {
 flex-direction: column !important;
 gap: 8px !important;
 }

 .toolbar-button {
 width: 100% !important;
 justify-content: center !important;
 padding: 10px !important;
 }
 }

 /* Touch-friendly resize handle */
 @media (pointer: coarse) {
 #video-resize-handle {
 height: 12px;
 opacity: 0.7;
 }

 #video-resize-handle:hover {
 opacity: 1;
 }
 }

 /* Landscape orientation adjustments */
 @media (orientation: landscape) and (max-height: 500px) {
 #video-call-container {
 max-height: 150px !important;
 }

 #video-participants-container {
 max-height: 90px !important;
 }

 #jitsi-meet-container {
 height: 90px !important;
 min-height: 90px !important;
 }
 }
 }
 .dark .chat-scroll-container::-webkit-scrollbar-thumb {
 background: rgba(71, 85, 105, 0.5);
 }
 .chat-scroll-container::-webkit-scrollbar-thumb:hover {
 background: rgba(148, 163, 184, 0.8);
 }
 .dark .chat-scroll-container::-webkit-scrollbar-thumb:hover {
 background: rgba(71, 85, 105, 0.8);
 }
 .chat-scroll-container::-webkit-scrollbar-thumb:active {
 background: rgba(100, 116, 139, 0.9);
 }
 .dark .chat-scroll-container::-webkit-scrollbar-thumb:active {
 background: rgba(51, 65, 85, 0.9);
 }

 /* Enhanced smooth scrolling behavior */
 .chat-scroll-container {
 scroll-behavior: smooth;
 scrollbar-width: thin;
 scrollbar-color: rgba(148, 163, 184, 0.5) transparent;
 /* Enhanced scroll performance */
 will-change: scroll-position;
 transform: translateZ(0);
 }
 .dark .chat-scroll-container {
 scrollbar-color: rgba(71, 85, 105, 0.5) transparent;
 }

 /* PDF Viewer Styling */
 #pdf-viewer-area {
 scroll-behavior: smooth;
 cursor: grab;
 overflow: auto;
 height: 100%;
 }

 #pdf-viewer-area.panning {
 cursor: grabbing;
 user-select: none;
 }

 .pdf-container {
 padding: 20px;
 display: flex;
 flex-direction: column;
 align-items: center;
 gap: 20px;
 min-height: 100%;
 width: max-content;
 min-width: 100%;
 }

 .pdf-page {
 box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
 border-radius: 8px;
 background: white;
 position: relative;
 flex-shrink: 0;
 }

 .dark .pdf-page {
 box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
 }

 .pdf-page canvas {
 display: block;
 border-radius: 8px;
 width: 100%;
 height: auto;
 }



 /* PDF Upload drag and drop styling */
 #pdf-upload-section.drag-over {
 background-color: rgba(99, 102, 241, 0.05);
 border-color: rgba(99, 102, 241, 0.3);
 }

 .dark #pdf-upload-section.drag-over {
 background-color: rgba(99, 102, 241, 0.1);
 }

 /* Scroll indicator for better UX */
 .chat-scroll-container::after {
 content: '';
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 background: linear-gradient(transparent, rgba(255, 255, 255, 0.8));
 pointer-events: none;
 opacity: 0;
 transition: opacity 0.3s ease;
 }
 .dark .chat-scroll-container::after {
 background: linear-gradient(transparent, rgba(30, 41, 59, 0.8));
 }
 .chat-scroll-container.has-more-content::after {
 opacity: 1;
 }

 /* Responsive scrolling adjustments */
 @media (max-width: 768px) {
 .chat-scroll-container::-webkit-scrollbar {
 width: 4px;
 }
 .chat-scroll-container {
 /* Reduce scroll threshold on mobile */
 scroll-padding-bottom: 20px;
 }
 }

 @media (max-height: 600px) {
 .chat-scroll-container {
 /* Adjust for smaller screens */
 scroll-padding-bottom: 10px;
 }
 }

 /* Handle sidebar resize scenarios */
 .chat-scroll-container {
 /* Ensure proper reflow during resize */
 resize: none;
 overflow-anchor: auto;
 }

 /* Improve touch scrolling on mobile */
 @media (pointer: coarse) {
 .chat-scroll-container {
 -webkit-overflow-scrolling: touch;
 overscroll-behavior: contain;
 }
 }

 /* Compact toolbar button styles */
 .toolbar-button {
 position: relative;
 overflow: hidden;
 transition: all 0.2s ease-in-out;
 background: rgba(255, 255, 255, 0.8);
 border: 1px solid rgb(226, 232, 240);
 color: rgb(51, 65, 85);
 box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 backdrop-filter: blur(4px);
 border-radius: 0.375rem;
 padding: 0.375rem;
 font-weight: 500;
 }

 .toolbar-button:hover {
 background: rgb(255, 255, 255);
 color: rgb(15, 23, 42);
 box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
 transform: translateY(-1px) scale(1.02);
 }

 .dark .toolbar-button {
 background: rgba(30, 41, 59, 0.8);
 border-color: rgb(71, 85, 105);
 color: rgb(203, 213, 225);
 }

 .dark .toolbar-button:hover {
 background: rgb(51, 65, 85);
 color: rgb(248, 250, 252);
 }

 /* Style for active tool button */
 .active-tool {
 background: linear-gradient(135deg, rgb(99, 102, 241), rgb(37, 99, 235), rgb(147, 51, 234));
 color: white;
 border-color: rgb(129, 140, 248);
 box-shadow:
 0 10px 25px -5px rgba(99, 102, 241, 0.4),
 0 8px 10px -6px rgba(99, 102, 241, 0.3),
 inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
 transform: translateY(-1px) scale(1.02);
 animation: glow 2s ease-in-out infinite alternate;
 }

 .active-tool::before {
 content: '';
 position: absolute;
 inset: 0;
 background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1), transparent);
 border-radius: inherit;
 }

 .dark .active-tool {
 background: linear-gradient(135deg, rgb(79, 70, 229), rgb(29, 78, 216), rgb(126, 34, 206));
 border-color: rgb(99, 102, 241);
 box-shadow:
 0 10px 25px -5px rgba(79, 70, 229, 0.5),
 0 8px 10px -6px rgba(79, 70, 229, 0.4),
 inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
 }

 /* Modern color picker styling */
 .toolbar-color-picker {
 border-radius: 0.5rem;
 transition: all 0.2s ease-in-out;
 box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 }

 .toolbar-color-picker:hover {
 box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
 transform: scale(1.05);
 }

 /* Modern slider styling */
 .toolbar-slider {
 transition: all 0.2s ease-in-out;
 }

 .toolbar-slider:hover {
 transform: scale(1.02);
 }

 /* Horizontal inline tool group styling */
 .tool-group-wrapper {
 background: rgba(255, 255, 255, 0.6);
 border: 1px solid rgba(226, 232, 240, 0.5);
 border-radius: 0.5rem;
 padding: 0.5rem 0.75rem;
 backdrop-filter: blur(8px);
 transition: all 0.2s ease-in-out;
 box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 flex-shrink: 0;
 white-space: nowrap;
 display: flex;
 flex-direction: column;
 align-items: center;
 min-width: auto;
 }

 .tool-group-wrapper:hover {
 background: rgba(255, 255, 255, 0.8);
 box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.1);
 }

 .dark .tool-group-wrapper {
 background: rgba(30, 41, 59, 0.6);
 border-color: rgba(71, 85, 105, 0.5);
 }

 .dark .tool-group-wrapper:hover {
 background: rgba(30, 41, 59, 0.8);
 }
 /* Ensure canvas selection box is visible in dark mode */
 .dark .canvas-container .upper-canvas .selection {
 border-color: rgba(165, 180, 252, 0.7) !important; /* Tailwind indigo-300 with alpha */
 background-color: rgba(129, 140, 248, 0.2) !important; /* Tailwind indigo-400 with alpha */
 }
 #magnifier-preview {
 backdrop-filter: blur(4px);
 -webkit-backdrop-filter: blur(4px);
 }

 /* Tab styles - optimized transitions */
 .tab-button {
 transition: color 0.2s ease-in-out,
             background-color 0.2s ease-in-out,
             border-color 0.2s ease-in-out;
 }
 .tab-button.active {
 color: theme('colors.indigo.600');
 border-bottom-color: theme('colors.indigo.600');
 }
 .dark .tab-button.active {
 color: theme('colors.indigo.400');
 border-bottom-color: theme('colors.indigo.400');
 }
 .tab-content {
 transition: opacity 0.2s ease-in-out;
 }

 /* Enhanced message styles */
 .message-item {
 padding: 12px 16px;
 border-radius: 12px;
 margin-bottom: 12px;
 background-color: theme('colors.slate.50');
 border-left: 4px solid theme('colors.indigo.500');
 box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
 transition: all 0.2s ease-in-out;
 animation: messageSlideIn 0.3s ease-out;
 }
 .dark .message-item {
 background-color: theme('colors.slate.700');
 box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
 }
 .message-item:hover {
 transform: translateY(-1px);
 box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
 }
 .dark .message-item:hover {
 box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
 }
 .message-header {
 font-weight: 600;
 font-size: 0.8rem;
 color: theme('colors.indigo.600');
 margin-bottom: 4px;
 display: flex;
 align-items: center;
 justify-content: space-between;
 }
 .dark .message-header {
 color: theme('colors.indigo.400');
 }
 .message-timestamp {
 font-size: 0.7rem;
 color: theme('colors.slate.500');
 font-weight: 400;
 }
 .dark .message-timestamp {
 color: theme('colors.slate.400');
 }
 .message-content {
 line-height: 1.5;
 word-wrap: break-word;
 }
 .file-message {
 border-left-color: theme('colors.green.500');
 background-color: theme('colors.green.50');
 }
 .dark .file-message {
 background-color: theme('colors.green.900/20');
 }
 .system-message {
 border-left-color: theme('colors.amber.500');
 background-color: theme('colors.amber.50');
 font-style: italic;
 }
 .dark .system-message {
 background-color: theme('colors.amber.900/20');
 }
 .file-download-link {
 color: theme('colors.blue.600');
 text-decoration: underline;
 cursor: pointer;
 font-weight: 500;
 display: inline-flex;
 align-items: center;
 gap: 4px;
 }
 .dark .file-download-link {
 color: theme('colors.blue.400');
 }
 .file-download-link:hover {
 color: theme('colors.blue.700');
 }
 .dark .file-download-link:hover {
 color: theme('colors.blue.300');
 }

 /* AI Chat message styles */
 .ai-message, .user-message, .system-message-ai {
 padding: 10px 14px;
 border-radius: 12px;
 margin-bottom: 8px;
 animation: messageSlideIn 0.3s ease-out;
 line-height: 1.6;
 word-wrap: break-word;
 word-break: break-word;
 overflow-wrap: break-word;
 hyphens: auto;
 max-width: 100%;
 box-sizing: border-box;
 overflow: hidden;
 }
 .ai-message {
 background-color: theme('colors.indigo.50');
 border-left: 4px solid theme('colors.indigo.500');
 }
 .dark .ai-message {
 background-color: theme('colors.indigo.900/20');
 }
 .user-message {
 background-color: theme('colors.slate.50');
 border-left: 4px solid theme('colors.slate.500');
 }
 .dark .user-message {
 background-color: theme('colors.slate.700');
 }
 .system-message-ai {
 background-color: theme('colors.amber.50');
 border-left: 4px solid theme('colors.amber.500');
 font-style: italic;
 }
 .dark .system-message-ai {
 background-color: theme('colors.amber.900/20');
 }

 /* Message animations */
 @keyframes messageSlideIn {
 from {
 opacity: 0;
 transform: translateY(15px) scale(0.95);
 }
 to {
 opacity: 1;
 transform: translateY(0) scale(1);
 }
 }

 @keyframes messageFadeIn {
 from {
 opacity: 0;
 }
 to {
 opacity: 1;
 }
 }

 /* Smooth transitions for interactive elements - optimized for performance */
 .message-item, .ai-message, .user-message, .system-message-ai {
 transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),
             box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
 }

 /* Disable transitions during theme switching to prevent lag */
 .theme-switching * {
 transition: none !important;
 animation: none !important;
 }

 /* Hover effects for better interactivity */
 .message-item:hover, .ai-message:hover, .user-message:hover {
 transform: translateY(-1px);
 }

 /* Focus states for accessibility */
 .file-download-link:focus {
 outline: 2px solid theme('colors.indigo.500');
 outline-offset: 2px;
 border-radius: 4px;
 }

 /* MathJax overflow prevention */
 .ai-message .MathJax, .user-message .MathJax,
 .ai-message .MathJax_Display, .user-message .MathJax_Display {
 max-width: 100% !important;
 overflow-x: auto !important;
 overflow-y: hidden !important;
 }

 /* Ensure message content containers don't overflow */
 .message-content {
 max-width: 100%;
 overflow-wrap: break-word;
 word-break: break-word;
 }

 /* Additional overflow protection for chat messages */
 .ai-message, .user-message {
 min-width: 0; /* Allow flex items to shrink below content size */
 }

 /* Handle long mathematical expressions */
 .ai-message mjx-container, .user-message mjx-container {
 max-width: 100% !important;
 overflow-x: auto !important;
 display: block !important;
 }

 /* Additional MathJax container handling */
 .ai-message mjx-math, .user-message mjx-math {
 max-width: 100% !important;
 }

 /* Handle display math (block equations) */
 .ai-message mjx-container[display="true"], .user-message mjx-container[display="true"] {
 overflow-x: auto !important;
 overflow-y: hidden !important;
 max-width: 100% !important;
 margin: 0.5em 0 !important;
 }

 /* Ensure chat history container doesn't overflow */
 #chat-history {
 overflow-x: hidden;
 overflow-y: auto;
 width: 100%;
 max-width: 100%;
 }

 /* Ensure AI chat content container handles overflow */
 #ai-chat-content {
 overflow: hidden;
 width: 100%;
 max-width: 100%;
 }

 /* Force proper width constraints on message containers */
 .ai-message.max-w-\[95\%\], .user-message.max-w-\[95\%\] {
 max-width: 95% !important;
 width: auto !important;
 }

 /* Handle very long words, URLs, or code snippets */
 .ai-message *, .user-message * {
 max-width: 100%;
 overflow-wrap: break-word;
 word-break: break-word;
 }

 /* Specific handling for code blocks and preformatted text */
 .ai-message pre, .user-message pre,
 .ai-message code, .user-message code {
 white-space: pre-wrap !important;
 overflow-wrap: break-word !important;
 word-break: break-all !important;
 max-width: 100% !important;
 overflow-x: auto !important;
 }

 /* Typing indicator animation */
 .typing-indicator {
 display: inline-flex;
 align-items: center;
 gap: 4px;
 }

 .typing-dot {
 width: 6px;
 height: 6px;
 border-radius: 50%;
 background-color: theme('colors.slate.400');
 animation: typingDot 1.4s infinite ease-in-out;
 }

 .typing-dot:nth-child(1) { animation-delay: -0.32s; }
 .typing-dot:nth-child(2) { animation-delay: -0.16s; }
 .typing-dot:nth-child(3) { animation-delay: 0s; }

 @keyframes typingDot {
 0%, 80%, 100% {
 transform: scale(0.8);
 opacity: 0.5;
 }
 40% {
 transform: scale(1);
 opacity: 1;
 }
 }

 /* Jupyter Notebook Styling */
 .cell {
     transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
     background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.8));
     border: 1px solid rgba(226, 232, 240, 0.6);
     border-radius: 12px;
     backdrop-filter: blur(8px);
     box-shadow:
         0 1px 3px 0 rgba(0, 0, 0, 0.1),
         0 1px 2px 0 rgba(0, 0, 0, 0.06);
     margin-bottom: 16px;
     overflow: hidden;
 }

 .cell:hover {
     box-shadow:
         0 8px 25px -8px rgba(0, 0, 0, 0.15),
         0 4px 6px -1px rgba(0, 0, 0, 0.1);
     transform: translateY(-2px);
     border-color: rgba(99, 102, 241, 0.3);
 }

 .dark .cell {
     background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.8));
     border-color: rgba(71, 85, 105, 0.6);
     box-shadow:
         0 1px 3px 0 rgba(0, 0, 0, 0.3),
         0 1px 2px 0 rgba(0, 0, 0, 0.2);
 }

 .dark .cell:hover {
     box-shadow:
         0 8px 25px -8px rgba(0, 0, 0, 0.4),
         0 4px 6px -1px rgba(0, 0, 0, 0.3);
     border-color: rgba(99, 102, 241, 0.5);
 }

 .code-input {
     font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
     line-height: 1.6;
     tab-size: 4;
     white-space: pre;
     overflow-x: auto;
     word-wrap: normal;
     background: rgba(248, 250, 252, 0.5);
     border-radius: 8px;
     padding: 12px;
     border: 1px solid rgba(226, 232, 240, 0.5);
     transition: all 0.2s ease;
 }

 .dark .code-input {
     background: rgba(15, 23, 42, 0.7);
     border-color: rgba(71, 85, 105, 0.5);
     color: #e2e8f0;
 }

 .code-input:focus {
     outline: none;
     border-color: #6366f1;
     box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
     background: rgba(255, 255, 255, 0.8);
 }

 .dark .code-input:focus {
     border-color: #818cf8;
     box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.2);
     background: rgba(15, 23, 42, 0.9);
 }

 .output-content {
     font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
     line-height: 1.6;
     overflow-x: auto;
     white-space: pre;
     word-wrap: normal;
     background: rgba(241, 245, 249, 0.5);
     border-radius: 8px;
     padding: 12px;
     border: 1px solid rgba(226, 232, 240, 0.3);
 }

 .dark .output-content {
     background: rgba(15, 23, 42, 0.5);
     border-color: rgba(71, 85, 105, 0.3);
     color: #cbd5e1;
 }

 .cell-header {
     user-select: none;
     background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(147, 51, 234, 0.05));
     padding: 12px 16px;
     border-bottom: 1px solid rgba(226, 232, 240, 0.3);
     font-weight: 600;
     font-size: 0.875rem;
     color: #4f46e5;
     display: flex;
     align-items: center;
     justify-content: space-between;
     min-height: 48px;
 }

 .dark .cell-header {
     background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(147, 51, 234, 0.1));
     border-bottom-color: rgba(71, 85, 105, 0.3);
     color: #a5b4fc;
 }

 /* Cell action buttons */
 .cell-action-buttons {
     display: flex;
     gap: 8px;
     align-items: center;
 }

 .run-cell-btn, .delete-cell-btn {
     padding: 8px 12px;
     font-size: 0.875rem;
     font-weight: 500;
     border-radius: 6px;
     transition: all 0.2s ease;
     border: none;
     cursor: pointer;
     display: flex;
     align-items: center;
     gap: 4px;
     min-width: 70px;
     justify-content: center;
 }

 .run-cell-btn {
     background: linear-gradient(135deg, #10b981, #059669);
     color: white;
 }

 .run-cell-btn:hover {
     background: linear-gradient(135deg, #059669, #047857);
     transform: translateY(-1px);
     box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
 }

 .delete-cell-btn {
     background: linear-gradient(135deg, #ef4444, #dc2626);
     color: white;
 }

 .delete-cell-btn:hover {
     background: linear-gradient(135deg, #dc2626, #b91c1c);
     transform: translateY(-1px);
     box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
 }

 .cell:focus-within {
     border-color: #6366f1;
     box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
 }

 .dark .cell:focus-within {
     border-color: #818cf8;
     box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.2);
 }

 .plot-container {
     text-align: center;
     margin: 1.5rem 0;
     padding: 16px;
     background: rgba(255, 255, 255, 0.5);
     border-radius: 12px;
     border: 1px solid rgba(226, 232, 240, 0.3);
 }

 .dark .plot-container {
     background: rgba(15, 23, 42, 0.5);
     border-color: rgba(71, 85, 105, 0.3);
 }

 .plot-container img {
     max-width: 100%;
     height: auto;
     border: 1px solid rgba(226, 232, 240, 0.5);
     border-radius: 12px;
     box-shadow:
         0 4px 6px -1px rgba(0, 0, 0, 0.1),
         0 2px 4px -1px rgba(0, 0, 0, 0.06);
     transition: all 0.2s ease;
 }

 .dark .plot-container img {
     border-color: rgba(71, 85, 105, 0.5);
     box-shadow:
         0 4px 6px -1px rgba(0, 0, 0, 0.3),
         0 2px 4px -1px rgba(0, 0, 0, 0.2);
 }

 .plot-container img:hover {
     transform: scale(1.02);
     box-shadow:
         0 8px 25px -8px rgba(0, 0, 0, 0.15),
         0 4px 6px -1px rgba(0, 0, 0, 0.1);
 }

 .dark .plot-container img:hover {
     box-shadow:
         0 8px 25px -8px rgba(0, 0, 0, 0.4),
         0 4px 6px -1px rgba(0, 0, 0, 0.3);
 }

 .dark .plot-container img {
     border-color: #4a5568;
 }

 /* Horizontal scrolling for code containers */
 .code-input-container {
     overflow-x: auto;
 }

 .cell-output .output-content {
     overflow-x: auto;
     max-width: 100%;
 }

 .cell-output .output-content pre {
     white-space: pre;
     word-wrap: normal;
     overflow-x: auto;
 }

 /* Image Preview Styles */
 .image-preview-container {
     position: relative;
     display: inline-block;
 }

 .image-preview-container img {
     transition: all 0.2s ease-in-out;
     box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
 }

 .dark .image-preview-container img {
     box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
 }

 .image-preview-container img:hover {
     transform: scale(1.02);
     box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 }

 .dark .image-preview-container img:hover {
     box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
 }

 /* Image Modal Styles */
 #image-modal {
     backdrop-filter: blur(4px);
     -webkit-backdrop-filter: blur(4px);
 }

 #image-modal-img {
     transition: all 0.3s ease-in-out;
 }

 /* Loading state for images */
 .image-preview-container img[src=""] {
     background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
     background-size: 200% 100%;
     animation: loading 1.5s infinite;
 }

 .dark .image-preview-container img[src=""] {
     background: linear-gradient(90deg, #374151 25%, #4b5563 50%, #374151 75%);
     background-size: 200% 100%;
 }

 @keyframes loading {
     0% { background-position: 200% 0; }
     100% { background-position: -200% 0; }
 }

 /* Responsive image modal */
 @media (max-width: 768px) {
     #image-modal .relative {
         max-width: 95vw;
         max-height: 95vh;
     }

     #image-modal-img {
         max-height: 60vh;
     }
 }

 /* AI Chat Image Preview Styles */
 #ai-chat-image-preview {
     animation: slideDown 0.3s ease-out;
 }

 #ai-chat-preview-img {
     transition: all 0.2s ease-in-out;
 }

 #ai-chat-preview-img:hover {
     transform: scale(1.05);
 }

 #ai-chat-remove-image {
     transition: all 0.2s ease-in-out;
 }

 #ai-chat-remove-image:hover {
     background-color: rgba(239, 68, 68, 0.1);
     color: #ef4444;
 }

 @keyframes slideDown {
     from {
         opacity: 0;
         transform: translateY(-10px);
     }
     to {
         opacity: 1;
         transform: translateY(0);
     }
 }

 /* Enhanced chat input placeholder */
 #chat-input:focus::placeholder {
     opacity: 0.5;
 }

 /* Message text content styling */
 .message-text-content {
     display: block;
     width: 100%;
     clear: both;
 }

 /* Modern Button Styles */
 button:not(.toolbar-button):not(.tab-button) {
     font-family: 'Poppins', sans-serif;
     font-weight: 500;
     transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
     border-radius: 8px;
 }

 /* Modern Input Styles */
 input[type="text"], input[type="number"], textarea {
     font-family: 'Poppins', sans-serif;
     transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
     border-radius: 8px;
 }

 input[type="text"]:focus, input[type="number"]:focus, textarea:focus {
     transform: translateY(-1px);
     box-shadow:
         0 4px 6px -1px rgba(0, 0, 0, 0.1),
         0 2px 4px -1px rgba(0, 0, 0, 0.06),
         0 0 0 3px rgba(99, 102, 241, 0.1);
 }

 /* Enhanced Canvas Area */
 #canvas-parent {
     background: linear-gradient(135deg,
         rgba(248, 250, 252, 0.8) 0%,
         rgba(241, 245, 249, 0.6) 50%,
         rgba(226, 232, 240, 0.4) 100%);
 }

 /* üöÄ MOBILE OPTIMIZATION: Prevent Safari pan/zoom during drawing */
#main-canvas {
    touch-action: none;
}

/* Prevent browser touch scrolling on the canvas container for robust gestures */
#canvas-parent {
    touch-action: none;
    overscroll-behavior: contain;
}

 .dark #canvas-parent {
     background: linear-gradient(135deg,
         rgba(15, 23, 42, 0.8) 0%,
         rgba(30, 41, 59, 0.6) 50%,
         rgba(51, 65, 85, 0.4) 100%);
 }

 /* Floating Action Button Style */
 .floating-btn {
     position: relative;
     overflow: hidden;
     background: linear-gradient(135deg, #6366f1, #8b5cf6, #a855f7);
     border: none;
     border-radius: 12px;
     color: white;
     font-weight: 600;
     padding: 12px 24px;
     box-shadow:
         0 4px 6px -1px rgba(0, 0, 0, 0.1),
         0 2px 4px -1px rgba(0, 0, 0, 0.06);
     transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
 }

 .floating-btn:hover {
     transform: translateY(-2px) scale(1.02);
     box-shadow:
         0 10px 25px -5px rgba(99, 102, 241, 0.4),
         0 8px 10px -6px rgba(99, 102, 241, 0.3);
 }

 .floating-btn::before {
     content: '';
     position: absolute;
     inset: 0;
     background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
     border-radius: inherit;
     opacity: 0;
     transition: opacity 0.3s ease;
 }

 .floating-btn:hover::before {
     opacity: 1;
 }

 /* Glassmorphism effect for panels */
 .glass-panel {
     background: rgba(255, 255, 255, 0.1);
     backdrop-filter: blur(10px);
     border: 1px solid rgba(255, 255, 255, 0.2);
     border-radius: 16px;
     box-shadow:
         0 8px 32px 0 rgba(31, 38, 135, 0.37),
         inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
 }

 .dark .glass-panel {
     background: rgba(15, 23, 42, 0.2);
     border-color: rgba(255, 255, 255, 0.1);
 }

 /* Enhanced Scrollbar Styles */
 .scrollbar-thin {
     scrollbar-width: thin;
 }

 .scrollbar-thumb-slate-300::-webkit-scrollbar-thumb {
     background-color: #cbd5e1;
     border-radius: 6px;
     border: 2px solid transparent;
     background-clip: content-box;
 }

 .dark .scrollbar-thumb-slate-600::-webkit-scrollbar-thumb {
     background-color: #475569;
 }

 .scrollbar-track-transparent::-webkit-scrollbar-track {
     background: transparent;
 }

 .scrollbar-thin::-webkit-scrollbar {
     width: 8px;
     height: 8px;
 }

 /* Tab scrolling improvements */
 .tab-container {
     scrollbar-width: none;
     -ms-overflow-style: none;
 }

 .tab-container::-webkit-scrollbar {
     display: none;
 }

 /* Enhanced scrollbar styling for toolbar */
 #toolbar-content {
     scroll-behavior: smooth;
     scrollbar-width: thin;
     scrollbar-color: #94a3b8 #f1f5f9;
 }

 #toolbar-content::-webkit-scrollbar {
     height: 8px;
     width: 8px;
 }

 #toolbar-content::-webkit-scrollbar-track {
     background: #f1f5f9;
     border-radius: 4px;
     margin: 2px;
 }

 #toolbar-content::-webkit-scrollbar-thumb {
     background: linear-gradient(135deg, #94a3b8, #64748b);
     border-radius: 4px;
     border: 1px solid rgba(255, 255, 255, 0.2);
 }

 #toolbar-content::-webkit-scrollbar-thumb:hover {
     background: linear-gradient(135deg, #64748b, #475569);
 }

 .dark #toolbar-content::-webkit-scrollbar-track {
     background: #334155;
 }

 .dark #toolbar-content::-webkit-scrollbar-thumb {
     background: linear-gradient(135deg, #475569, #334155);
     border: 1px solid rgba(255, 255, 255, 0.1);
 }

 .dark #toolbar-content::-webkit-scrollbar-thumb:hover {
     background: linear-gradient(135deg, #64748b, #475569);
 }

 /* Ensure flex container creates horizontal scroll */
 #toolbar-content .flex {
     width: max-content;
     min-width: 100%;
 }

 /* Hidden scrollbar for toolbar */
 #toolbar-content {
     scrollbar-width: none; /* Firefox */
     -ms-overflow-style: none; /* Internet Explorer 10+ */
 }

 #toolbar-content::-webkit-scrollbar {
     display: none; /* WebKit */
 }

 /* Hidden scrollbars for tab headers and notebook container */
 .flex[style*="scrollbar-width: none"]::-webkit-scrollbar,
 #notebook-container::-webkit-scrollbar {
     display: none; /* WebKit */
 }

 /* Force horizontal scrolling */
 #toolbar-content .flex {
     min-width: max-content;
     width: max-content;
 }

 /* Ensure scrollbar appears when needed */
 #toolbar-content {
     overflow-x: scroll !important;
 }

 /* Ensure buttons don't shrink */
 .whitespace-nowrap {
     white-space: nowrap;
     flex-shrink: 0;
 }

 /* Group Chat Notification System */
 .notification-popup {
     position: fixed;
     bottom: 20px;
     right: 20px;
     max-width: 350px;
     background: white;
     border: 1px solid #e2e8f0;
     border-radius: 12px;
     box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
     padding: 16px;
     z-index: 99999;
     cursor: pointer;
     transform: translateX(400px);
     opacity: 0;
     transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
     pointer-events: auto;
 }

 .notification-popup.show {
     transform: translateX(0);
     opacity: 1;
 }

 .dark .notification-popup {
     background: #1e293b;
     border-color: #475569;
     color: #f1f5f9;
 }

 .notification-popup:hover {
     transform: translateX(0) translateY(-2px);
     box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
 }

/* Video Popup Modal */
.video-popup-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
    z-index: 100000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.video-popup-modal.show {
    opacity: 1;
    visibility: visible;
}

.video-popup-container {
    position: relative;
    width: 90%;
    height: 90%;
    max-width: 1344px;
    max-height: 896px;
    background: #1e293b;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    transform: scale(0.9) translateY(20px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.video-popup-modal.show .video-popup-container {
    transform: scale(1) translateY(0);
}

.video-popup-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background: #000;
}

.video-popup-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 10;
}

.video-popup-title {
    color: white;
    font-size: 18px;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

.video-popup-close {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    backdrop-filter: blur(8px);
}

.video-popup-close:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
}

.video-popup-close:active {
    transform: scale(0.95);
}

/* Video element hover effect for double-click hint */
.video-container-clickable {
    cursor: pointer;
    transition: all 0.2s ease;
}

.video-container-clickable:hover {
    transform: scale(1.02);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.video-container-clickable::after {
    content: "Double-click to expand";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
    white-space: nowrap;
}

.video-container-clickable:hover::after {
    opacity: 1;
}

/* Reply Feature Styles */
.message-item {
    position: relative;
    transition: all 0.2s ease;
}

.message-item:hover {
    background-color: rgba(0, 0, 0, 0.02);
}

.dark .message-item:hover {
    background-color: rgba(255, 255, 255, 0.02);
}

.message-action-buttons {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: all 0.2s ease;
}

.message-item:hover .message-action-buttons {
    opacity: 1;
}

.message-reply-button,
.message-read-aloud-button {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    backdrop-filter: blur(4px);
}

.dark .message-reply-button,
.dark .message-read-aloud-button {
    background: rgba(0, 0, 0, 0.7);
    border-color: rgba(255, 255, 255, 0.2);
    color: white;
}

.message-reply-button:hover {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.3);
    transform: scale(1.1);
}

.message-read-aloud-button:hover {
    background: rgba(34, 197, 94, 0.1);
    border-color: rgba(34, 197, 94, 0.3);
    transform: scale(1.1);
}

.message-read-aloud-button.reading {
    background: rgba(34, 197, 94, 0.2);
    border-color: rgba(34, 197, 94, 0.5);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.reply-context {
    background: rgba(34, 197, 94, 0.1);
    border-left: 4px solid #22c55e;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 8px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.reply-context:hover {
    background: rgba(34, 197, 94, 0.15);
    transform: translateX(2px);
}

.dark .reply-context {
    background: rgba(34, 197, 94, 0.15);
    border-left-color: #16a34a;
}

.dark .reply-context:hover {
    background: rgba(34, 197, 94, 0.2);
}

.reply-context-header {
    font-weight: 600;
    color: #22c55e;
    margin-bottom: 3px;
    font-size: 11px;
    letter-spacing: 0.5px;
}

.dark .reply-context-header {
    color: #4ade80;
}

.reply-context-content {
    color: #64748b;
    font-size: 12px;
    line-height: 1.4;
    max-height: 36px;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
    word-break: break-word;
}

.dark .reply-context-content {
    color: #94a3b8;
}

.reply-input-container {
    background: rgba(59, 130, 246, 0.05);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 8px;
    padding: 8px 12px;
    margin-bottom: 8px;
}

.dark .reply-input-container {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.3);
}

.reply-input-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
}

.reply-input-title {
    font-size: 12px;
    font-weight: 600;
    color: #3b82f6;
}

.reply-input-close {
    background: none;
    border: none;
    color: #64748b;
    cursor: pointer;
    padding: 2px;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.reply-input-close:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
}

.reply-input-preview {
    font-size: 11px;
    color: #64748b;
    line-height: 1.3;
    max-height: 32px;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    line-clamp: 2;
    -webkit-box-orient: vertical;
}

.dark .reply-input-preview {
    color: #94a3b8;
}

/* AI Chat message reply styles */
.ai-message, .user-message {
    position: relative;
}

.ai-message:hover .message-reply-button,
.message-item:hover .message-actions {
    opacity: 1;
}

/* Message highlighting for navigation */
.message-highlighted {
    background-color: rgba(59, 130, 246, 0.3) !important;
    border-radius: 8px;
    transition: background-color 2s ease-out;
}

.dark .message-highlighted {
    background-color: rgba(59, 130, 246, 0.4) !important;
}

/* Edited message indicator */
.edited-indicator {
    font-style: italic;
    opacity: 0.7;
    position: absolute;
    bottom: 4px;
    right: 8px;
    font-size: 11px;
    color: #94a3b8;
    pointer-events: none;
}

.dark .edited-indicator {
    color: #64748b;
}

/* Deleted message styling */
.message-item.deleted {
    opacity: 0.6;
}

.message-item.deleted .message-content {
    font-style: italic;
}



/* Reply context hover effect */
.reply-context:hover {
    background: rgba(59, 130, 246, 0.15);
    transform: translateX(2px);
}

 .notification-header {
     display: flex;
     align-items: center;
     margin-bottom: 8px;
 }

 .notification-avatar {
     width: 32px;
     height: 32px;
     border-radius: 50%;
     background: linear-gradient(135deg, #6366f1, #8b5cf6);
     display: flex;
     align-items: center;
     justify-content: center;
     color: white;
     font-weight: 600;
     font-size: 14px;
     margin-right: 12px;
 }

 .notification-content {
     flex: 1;
 }

 .notification-sender {
     font-weight: 600;
     font-size: 14px;
     color: #374151;
     margin-bottom: 4px;
 }

 .dark .notification-sender {
     color: #f9fafb;
 }

 .notification-message {
     font-size: 13px;
     color: #6b7280;
     line-height: 1.4;
     max-height: 40px;
     overflow: hidden;
     display: -webkit-box;
     -webkit-line-clamp: 2;
     -webkit-box-orient: vertical;
 }

 .dark .notification-message {
     color: #d1d5db;
 }

 .notification-time {
     font-size: 11px;
     color: #9ca3af;
     margin-top: 4px;
 }

 .dark .notification-time {
     color: #6b7280;
 }

 /* Message counter badge */
 .message-counter {
     position: absolute;
     top: 4px;
     right: -8px;
     background: white;
     color: #1f2937;
     border-radius: 50%;
     min-width: 20px;
     height: 20px;
     display: flex;
     align-items: center;
     justify-content: center;
     font-size: 11px;
     font-weight: 700;
     border: 2px solid #e5e7eb;
     box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
     z-index: 10;
 }

 .dark .message-counter {
     background: white;
     color: #1f2937;
     border-color: #d1d5db;
     box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
 }



 /* Mute button styling */
 .mute-button {
     padding: 6px 12px;
     border-radius: 6px;
     font-size: 12px;
     font-weight: 500;
     transition: all 0.2s ease;
     border: 1px solid #e2e8f0;
     background: white;
     color: #6b7280;
 }

 .mute-button:hover {
     background: #f8fafc;
     border-color: #cbd5e1;
 }

 .mute-button.muted {
     background: #fef2f2;
     border-color: #fecaca;
     color: #dc2626;
 }

 .dark .mute-button {
     background: #374151;
     border-color: #4b5563;
     color: #d1d5db;
 }

 .dark .mute-button:hover {
     background: #4b5563;
     border-color: #6b7280;
 }

 .dark .mute-button.muted {
     background: #450a0a;
     border-color: #7f1d1d;
     color: #fca5a5;
 }

 /* Removed interface zoom styling for natural browser-like behavior */

 /* Fix chat interface positioning */
 #app-container {
     height: 100vh;
     position: relative;
 }

 #ai-chat-sidebar {
     height: 100vh;
     position: relative;
 }

 /* Ensure input areas stay accessible during zoom */
 #chat-input-area,
 #group-message-input-area {
     position: sticky;
     bottom: 0;
     background: inherit;
     z-index: 20;
 }

 /* Improved resize handle visibility */
 #resize-handle {
     opacity: 0.3;
     transition: all 0.2s ease;
 }

 #resize-handle:hover {
     opacity: 1;
     width: 4px;
     background: linear-gradient(to bottom, #6366f1, #8b5cf6);
 }

 /* Touch-friendly resize handle */
 @media (pointer: coarse) {
     #resize-handle {
         width: 6px;
         opacity: 0.6;
     }

     #resize-handle:hover {
         width: 8px;
         opacity: 1;
     }
 }

 /* Voice Assistant Styles */
 #voice-assistant-btn {
     position: relative;
     overflow: hidden;
 }

 #voice-recording-indicator {
     background: linear-gradient(135deg, #ef4444, #dc2626);
 }

 #voice-recording-indicator .animate-pulse {
     animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
 }

 @keyframes voicePulse {
     0%, 100% {
         transform: scale(1);
         opacity: 1;
     }
     50% {
         transform: scale(1.1);
         opacity: 0.8;
     }
 }

 .voice-listening {
     animation: voicePulse 1.5s ease-in-out infinite;
 }

 /* Voice status indicator animations */
 #voice-assistant-status {
     transition: all 0.3s ease;
 }

 #voice-status-indicator.animate-pulse {
     animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
 }

 /* Enhanced voice button hover effects */
 #voice-assistant-btn:hover {
     box-shadow: 0 8px 25px -8px rgba(34, 197, 94, 0.4);
 }

 #voice-assistant-btn:active {
     transform: scale(0.95);
 }

 /* Host broadcast toggle styles */
 #host-broadcast-toggle {
     position: relative;
     overflow: hidden;
 }

 #host-broadcast-toggle .host-broadcast-glow {
     position: absolute;
     inset: 0;
     background: linear-gradient(to right, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0));
     opacity: 0;
     transition: opacity 0.3s ease;
 }

 #host-broadcast-toggle:hover .host-broadcast-glow {
     opacity: 1;
 }

 #host-broadcast-toggle.broadcast-on {
     background: linear-gradient(135deg, #22c55e, #16a34a);
     color: #ffffff;
     box-shadow: 0 12px 35px -10px rgba(34, 197, 94, 0.65);
 }

 #host-broadcast-toggle.broadcast-off {
     background: linear-gradient(135deg, #e2e8f0, #cbd5f5);
     color: #475569;
     box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.4);
 }

 #host-broadcast-toggle:disabled {
     opacity: 0.6;
     cursor: not-allowed;
 }

 #host-broadcast-toggle .broadcast-state-indicator {
     width: 0.65rem;
     height: 0.65rem;
     border-radius: 9999px;
     box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
     transition: all 0.2s ease;
 }
 

 /* Kick Notification Modal Styles */
 #kick-notification-modal {
     backdrop-filter: blur(4px);
     -webkit-backdrop-filter: blur(4px);
 }

 #kick-notification-modal .bg-white {
     animation: kickModalSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
 }

 @keyframes kickModalSlideIn {
     0% {
         transform: translateY(-50px) scale(0.9);
         opacity: 0;
     }
     100% {
         transform: translateY(0) scale(1);
         opacity: 1;
     }
 }

 /* Shake animation for emphasis */
 .kick-notification-shake {
     animation: kickShake 0.6s ease-in-out;
 }

 @keyframes kickShake {
     0%, 100% { transform: translateX(0); }
     10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
     20%, 40%, 60%, 80% { transform: translateX(5px); }
 }

 /* Enhanced warning icon animation */
 .kick-warning-icon {
     animation: kickPulse 2s infinite;
 }

 @keyframes kickPulse {
     0%, 100% { transform: scale(1); }
     50% { transform: scale(1.1); }
 }

 /* Ensure users tooltip has highest z-index */
 #users-tooltip {
     z-index: 999999 !important;
 }

 #users-tooltip::before,
 #users-tooltip::after {
     z-index: 999999 !important;
 }

 /* Ensure background menu has highest z-index */
 #background-menu {
 z-index: 999999 !important;
 }
 </style>
</head>
<body class="bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50 dark:from-slate-900 dark:via-slate-800 dark:to-indigo-900 text-slate-800 dark:text-slate-200 font-sans antialiased overflow-hidden">
<script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
 <div id="app-container" class="flex h-screen">

 <!-- Main Content Area (Toolbar + Canvas) -->
 <div id="main-content" class="flex-1 flex flex-col overflow-hidden">
 <header id="toolbar-wrapper" class="bg-white/80 dark:bg-slate-800/80 backdrop-blur-xl shadow-lg border-b border-white/20 dark:border-slate-700/50 print:hidden relative z-20">
 <div class="px-4 py-2 flex items-center justify-between h-14">
 <div class="flex items-center space-x-3">
 <span class="text-xl font-semibold text-slate-700 dark:text-slate-200">FLUXNOTEBOOK AI</span>

 <!-- Selected Tool Indicator -->
 <div id="selected-tool-indicator" class="flex items-center space-x-2 px-3 py-1.5 rounded-lg bg-gradient-to-r from-indigo-50 to-blue-50 dark:from-indigo-900/30 dark:to-blue-900/30 border border-indigo-200 dark:border-indigo-700">
 <div id="tool-icon" class="w-4 h-4 text-indigo-600 dark:text-indigo-400">
 <!-- Icon will be updated by JavaScript -->
 <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
 </svg>
 </div>
 <span id="tool-name" class="text-sm font-medium text-indigo-700 dark:text-indigo-300">Pen</span>
 </div>

 <!-- Collaboration Status -->
 <div id="collaboration-status" class="flex items-center space-x-2 px-2.5 py-1 rounded-full bg-slate-100 dark:bg-slate-700">
 <div id="connection-indicator" class="w-2 h-2 rounded-full bg-red-500"></div>
 <span id="connection-text" class="text-xs text-slate-600 dark:text-slate-400">Offline</span>
 <span id="room-info" class="text-xs text-slate-500 dark:text-slate-500 hidden"></span>
 </div>

 <!-- Video Call Status -->
 <div id="video-call-status-indicator" class="flex items-center space-x-2 px-2.5 py-1 rounded-full bg-slate-100 dark:bg-slate-700 hidden">
 <div id="video-status-dot" class="w-2 h-2 rounded-full bg-gray-400"></div>
 <span id="video-status-text" class="text-xs text-slate-600 dark:text-slate-400">No Video</span>
 <span id="video-participant-count" class="text-xs text-slate-500 dark:text-slate-500">0</span>
 </div>

 <!-- Active Users -->
 <div id="active-users" class="flex items-center space-x-1 hidden relative">
 <svg class="w-4 h-4 text-slate-500 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"></path>
 </svg>
 <span id="user-count" class="text-xs text-slate-600 dark:text-slate-400">0</span>


 </div>

 <!-- Voice Assistant Status -->
 <div id="voice-assistant-status" class="flex items-center space-x-2 px-2.5 py-1 rounded-full bg-green-100 dark:bg-green-900/30 hidden">
 <div id="voice-status-indicator" class="w-2 h-2 rounded-full bg-green-500"></div>
 <span id="voice-status-text" class="text-xs text-green-600 dark:text-green-400">Ready</span>
 </div>
 </div>
 <button id="toggle-toolbar-content-btn" title="Toggle Toolbar" class="p-2 rounded-md text-slate-500 hover:text-slate-700 hover:bg-slate-100 dark:text-slate-400 dark:hover:text-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500">
 <!-- Chevron Up/Down Icon will be inserted by JS -->
 <svg id="toolbar-chevron-icon" class="w-5 h-5 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
 </button>
 </div>
 <div id="toolbar-content" class="px-4 py-3 border-t border-slate-200/50 dark:border-slate-700/50 transition-all duration-300 ease-in-out bg-gradient-to-b from-transparent to-slate-50/30 dark:to-slate-800/30 overflow-x-auto overflow-y-hidden" style="max-height: 110px;"> <!-- max-h for animation -->
 <div class="flex flex-nowrap gap-4 min-w-max items-center h-full">

 <!-- Drawing Tools Group -->
 <div class="tool-group-wrapper">
 <p class="text-xs font-medium text-slate-500 dark:text-slate-400 mb-1 uppercase tracking-wide text-center">Drawing</p>
 <div class="flex flex-wrap gap-1 items-center justify-center">
 <button id="pen-tool" title="Pen (Press 1)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
 </svg>
 </button>
 <button id="line-tool" title="Line (Press 2)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"/>
 </svg>
 </button>
 <button id="arrow-tool" title="Arrow (Press 3) - Double-click to edit control points, hold Shift for straight lines" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"/>
 </svg>
 </button>
 <button id="circle-tool" title="Circle (Press 4)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
 </svg>
 </button>
 <button id="rectangle-tool" title="Rectangle (Press 5)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="2" fill="none"/>
 </svg>
 </button>
 <button id="highlighter-rect-tool" title="Highlight Rectangle (Press 6)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z"/>
 </svg>
 </button>
 <button id="highlighter-circle-tool" title="Highlight Circle (Press 7)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
 </svg>
 </button>
 <button id="text-tool" title="Text (Press 8) - Click to add text" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/>
 </svg>
 </button>
 <button id="image-upload-tool" title="Upload Image - Click to add images to canvas" class="toolbar-button text-purple-600 hover:bg-purple-100 dark:hover:bg-purple-800/50 dark:text-purple-400">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
 </svg>
 </button>
 <input type="file" id="image-upload-input" accept="image/*" multiple style="display: none;">
 <button id="select-tool" title="Select Objects (Press 9)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"/>
 </svg>
 </button>
 <button id="pan-mode-tool" title="Pan Mode - Navigation Only (Press P)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l-4-4m0 0l4-4m-4 4h18M17 8l4 4m0 0l-4 4"/>
 </svg>
 </button>
 <button id="erase-selected" title="Erase Selected Objects" class="toolbar-button text-orange-500 hover:bg-orange-100 dark:hover:bg-orange-800/50 dark:text-orange-400">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
 </svg>
 </button>
 <button id="erase-canvas" title="Erase Whole Canvas" class="toolbar-button text-red-500 hover:bg-red-100 dark:hover:bg-red-800/50 dark:text-red-400">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M3 12l6.414 6.414a2 2 0 001.414.586H19a2 2 0 002-2V7a2 2 0 00-2-2h-8.172a2 2 0 00-1.414.586L3 12z"/>
 </svg>
 </button>

 <input type="color" id="color-picker" title="Color" class="toolbar-color-picker w-8 h-8 p-1 border border-slate-300 dark:border-slate-600 rounded-md cursor-pointer appearance-none bg-transparent">
 <div class="flex items-center space-x-1 px-1 py-0.5 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700">
 <svg class="w-4 h-4 text-slate-500 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
 <input type="range" id="brush-size" title="Brush Size" min="1" max="50" value="5" class="toolbar-slider w-20 h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
 </div>



 </div>
 </div>

 <!-- AI Tools Group -->
 <div class="tool-group-wrapper">
 <p class="text-xs font-medium text-slate-500 dark:text-slate-400 mb-1 uppercase tracking-wide text-center">AI</p>
 <div class="flex flex-wrap gap-1 justify-center">
 <button id="ask-ai-canvas" title="Ask AI (Screenshot Canvas)" class="group relative overflow-hidden px-3 py-2 rounded-lg bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 dark:from-indigo-600 dark:to-purple-700 dark:hover:from-indigo-700 dark:hover:to-purple-800 text-white font-medium shadow-md hover:shadow-lg transition-all duration-200 transform hover:scale-105">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
 </svg>
 <span>Ask AI</span>
 </div>
 </button>
 <button id="ai-settings-btn" title="AI Settings - API Key, Model & Limits" class="toolbar-button text-slate-600 hover:text-slate-800 dark:text-slate-400 dark:hover:text-slate-200">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 100 4m0-4v2m0-6V4"/>
 </svg>
 </button>
 <button id="voice-assistant-btn" title="Voice Assistant - Click to start voice interaction" class="group relative overflow-hidden px-3 py-2 rounded-lg bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 dark:from-green-600 dark:to-emerald-700 dark:hover:from-green-700 dark:hover:to-emerald-800 text-white font-medium shadow-md hover:shadow-lg transition-all duration-200 transform hover:scale-105">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg id="voice-icon" class="w-5 h-5 transition-transform duration-300 group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
 </svg>
 <span id="voice-btn-text">Voice</span>
 </div>
 <!-- Recording indicator -->
 <div id="voice-recording-indicator" class="absolute inset-0 bg-red-500 rounded-lg opacity-0 transition-opacity duration-300 flex items-center justify-center z-10">
 <div class="flex items-center space-x-1">
 <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
 <span class="text-white text-xs font-medium">REC</span>
 </div>
 </div>
 </button>
 <button id="voice-settings-btn" title="Voice Assistant Settings" class="toolbar-button text-slate-600 hover:text-slate-800 dark:text-slate-400 dark:hover:text-slate-200">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
 </svg>
 </button>
 </div>
 </div>

 <!-- Accessibility Group -->
 <div class="tool-group-wrapper">
 <p class="text-xs font-medium text-slate-500 dark:text-slate-400 mb-1 uppercase tracking-wide text-center">View</p>
 <div class="flex flex-wrap gap-1 items-center justify-center">
 <button id="toggle-high-contrast" title="Toggle Dark Mode" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>
 </svg>
 </button>
 <button id="zoom-in" title="Zoom In Canvas (Ctrl/Cmd + Plus)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"/>
 </svg>
 </button>
 <button id="zoom-out" title="Zoom Out Canvas (Ctrl/Cmd + Minus)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"/>
 </svg>
 </button>
 <button id="zoom-reset" title="Reset Canvas Zoom (Ctrl/Cmd + 0)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
 </svg>
 </button>
 <div class="flex items-center space-x-1 px-2 py-1 rounded-md bg-slate-100 dark:bg-slate-700">
 <svg class="w-4 h-4 text-slate-500 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
 </svg>
 <span id="zoom-level" class="text-xs font-medium text-slate-600 dark:text-slate-300 min-w-[3rem] text-center">100%</span>
 </div>
 <button id="toggle-magnifier" title="Toggle Magnifier" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
 </svg>
 </button>

 <div class="flex items-center space-x-1 px-1 py-0.5 rounded-md hover:bg-slate-200 dark:hover:bg-slate-700">
 <svg class="w-4 h-4 text-slate-500 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/></svg>
 <input type="range" id="font-sizer" title="Chat Font Size" min="10" max="24" value="14" step="1" class="toolbar-slider w-20 h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
 </div>
 </div>
 </div>

 <!-- Collaboration Group -->
 <div class="tool-group-wrapper">
 <p class="text-xs font-medium text-slate-500 dark:text-slate-400 mb-1 uppercase tracking-wide text-center">Collaborate</p>
 <div class="flex flex-wrap gap-1 justify-center">
 <button id="create-room-btn" title="Create New Room" class="group relative overflow-hidden px-3 py-2 rounded-lg bg-gradient-to-r from-emerald-500 to-teal-600 hover:from-emerald-600 hover:to-teal-700 dark:from-emerald-600 dark:to-teal-700 dark:hover:from-emerald-700 dark:hover:to-teal-800 text-white font-medium shadow-md hover:shadow-lg transition-all duration-200 transform hover:scale-105">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
 </svg>
 <span>Create Room</span>
 </div>
 </button>
 <button id="join-room-btn" title="Join Existing Room" class="group relative overflow-hidden px-3 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 dark:from-blue-600 dark:to-indigo-700 dark:hover:from-blue-700 dark:hover:to-indigo-800 text-white font-medium shadow-md hover:shadow-lg transition-all duration-200 transform hover:scale-105">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"/>
 </svg>
 <span>Join Room</span>
 </div>
 </button>
 <button id="leave-room-btn" title="Leave Current Room" class="group relative overflow-hidden px-4 py-2.5 rounded-xl bg-gradient-to-r from-red-500 to-rose-600 hover:from-red-600 hover:to-rose-700 dark:from-red-600 dark:to-rose-700 dark:hover:from-red-700 dark:hover:to-rose-800 text-white font-medium shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105 hidden">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"/>
 </svg>
 <span>Leave Room</span>
 </div>
 </button>
 <button id="start-video-call-btn" title="Start Video Call" class="group relative overflow-hidden px-4 py-2.5 rounded-xl bg-gradient-to-r from-purple-500 to-violet-600 hover:from-purple-600 hover:to-violet-700 dark:from-purple-600 dark:to-violet-700 dark:hover:from-purple-700 dark:hover:to-violet-800 text-white font-medium shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105 hidden">
 <div class="absolute inset-0 bg-gradient-to-r from-white/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
 <div class="relative flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
 </svg>
 <span>Video Call</span>
 </div>
 </button>
 <button id="host-broadcast-toggle" title="Broadcast host AI + PDF" aria-pressed="false" class="group relative overflow-hidden px-4 py-2.5 rounded-xl text-sm font-semibold shadow-lg dark:shadow-slate-900/40 transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-emerald-400 hidden broadcast-off">
 <div class="host-broadcast-glow"></div>
 <div class="relative flex items-center space-x-2">
 <span id="host-broadcast-indicator" class="broadcast-state-indicator inline-flex items-center justify-center bg-slate-400"></span>
 <svg id="host-broadcast-icon" class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.5 6a7.5 7.5 0 010 12m7-12a7.5 7.5 0 010 12M5 9.5a4.5 4.5 0 010 7M19 9.5a4.5 4.5 0 010 7M12 14v4" />
 <circle cx="12" cy="10" r="2" stroke-width="2" fill="none" stroke="currentColor"></circle>
 </svg>
 <span id="host-broadcast-label">Broadcast OFF</span>
 </div>
 </button>
</div>
</div>



 <!-- File/Session Group -->
 <div class="tool-group-wrapper">
 <p class="text-xs font-medium text-slate-500 dark:text-slate-400 mb-1 uppercase tracking-wide text-center">Session</p>
 <div class="flex flex-wrap gap-1 justify-center">
 <button id="save-session" title="Save Session (.fluxnb)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3-3m0 0l-3 3m3-3v12"/>
 </svg>
 </button>
 <button id="open-session" title="Open Session (.fluxnb)" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
 </svg>
 </button>
 <button id="export-pdf" title="Export as PDF" class="toolbar-button">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 </button>
 </div>
 </div>

 <!-- Hidden file input for session import -->
 <input type="file" id="session-file-input" accept=".fluxnb" style="display: none;">
 </div>
 </div>
 </header>



 <!-- Video Call Container -->
 <div id="video-call-container" class="bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700 hidden transition-all duration-300 ease-in-out relative z-30" style="min-height: 0px; max-height: 300px;">
 <!-- Video Call Header -->
 <div id="video-call-header" class="flex items-center justify-between px-4 py-2 border-b border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-900/50">
 <div class="flex items-center space-x-3">
 <div class="flex items-center space-x-2">
 <div id="video-call-status" class="w-2 h-2 rounded-full bg-red-500"></div>
 <span id="video-call-text" class="text-sm font-medium text-slate-700 dark:text-slate-300">Video Call</span>
 <span id="video-participants-count" class="text-xs text-slate-500 dark:text-slate-400">(0 participants)</span>
 </div>
 </div>
 <div class="flex items-center space-x-2">
 <!-- Minimize/Maximize Button -->
 <button id="video-minimize-btn" title="Minimize Video" class="p-2 rounded-lg bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-600 dark:text-slate-400 transition-colors">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
 </svg>
 </button>
 <!-- Leave Call Button -->
 <button id="leave-call-btn"
         title="Leave Call"
         class="p-2 rounded-lg bg-yellow-500 hover:bg-yellow-600 text-white transition-colors hidden">
   <!-- phone-handset-off icon -->
   <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
           d="M6 18L18 6M6 6l12 12"/>
   </svg>
 </button>
 </div>
 </div>

 <!-- Video Participants Container -->
 <div id="video-participants-container" class="flex-1 overflow-y-auto overflow-x-hidden p-3" style="max-height: 240px;">
 <div id="video-participants-grid" class="grid grid-cols-5 gap-2" style="grid-template-rows: repeat(auto-fit, 88px);">
 <!-- Video participants will be dynamically added here -->
 <div id="video-placeholder" class="col-span-5 text-center py-8 text-slate-500 dark:text-slate-400 text-sm">
 <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
 </svg>
 <p>No video call active</p>
 <p class="text-xs mt-1">Start a video call to see participants here</p>
 </div>
 </div>
 </div>

 <!-- Resize Handle for Video Container -->
 <div id="video-resize-handle" class="absolute bottom-0 left-0 right-0 h-1 bg-slate-300 dark:bg-slate-600 hover:bg-indigo-500 dark:hover:bg-indigo-400 cursor-row-resize transition-colors opacity-0 hover:opacity-100"></div>
 </div>

 <main id="canvas-section" class="flex-1 relative">
 <div id="canvas-parent" class="absolute inset-0 overflow-auto bg-slate-50 dark:bg-slate-900/70">
 <canvas id="main-canvas"></canvas>
 </div>
 <div id="magnifier-preview" class="w-36 h-36 border-2 border-slate-400 dark:border-slate-500 rounded-full pointer-events-none hidden absolute bg-no-repeat z-50 shadow-xl bg-white/50 dark:bg-slate-800/50"></div>
 </main>
 </div>

 <!-- Right Sidebar for AI Chat and Group Messaging -->
 <aside id="ai-chat-sidebar" class="bg-white/90 dark:bg-slate-800/90 backdrop-blur-xl border-l border-slate-200/50 dark:border-slate-700/50 flex flex-col p-0 print:hidden transition-transform duration-300 ease-in-out relative h-screen overflow-hidden shadow-xl" style="width: 384px; min-width: 200px; max-width: 50vw;">
 <!-- Resize Handle -->
 <div id="resize-handle" class="absolute left-0 top-0 w-1 h-full bg-slate-300 dark:bg-slate-600 hover:bg-indigo-500 dark:hover:bg-indigo-400 cursor-col-resize transition-colors opacity-0 hover:opacity-100 z-10"></div>

 <!-- Tab Header -->
 <div class="border-b border-slate-200/50 dark:border-slate-700/50 flex justify-between items-center h-16 flex-shrink-0 bg-gradient-to-r from-slate-50/50 to-indigo-50/30 dark:from-slate-800/50 dark:to-indigo-900/30">
 <div class="flex overflow-x-auto overflow-y-hidden" style="scrollbar-width: none; -ms-overflow-style: none;">
 <button id="ai-chat-tab" class="tab-button active px-4 py-3 text-sm font-semibold text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600 dark:border-indigo-400 bg-white/60 dark:bg-slate-700/60 rounded-t-lg mx-1 whitespace-nowrap">
 <span class="flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
 </svg>
 <span>AI Chat</span>
 </span>
 </button>
 <button id="group-message-tab" class="tab-button relative px-4 py-3 text-sm font-semibold text-slate-500 dark:text-slate-400 border-b-2 border-transparent hover:text-slate-700 dark:hover:text-slate-300 hover:bg-white/40 dark:hover:bg-slate-700/40 rounded-t-lg mx-1 transition-all duration-200 whitespace-nowrap">
 <span class="flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
 </svg>
 <span>Group Message</span>
 </span>
 <div id="message-counter-badge" class="message-counter hidden">0</div>
 </button>
 <button id="pdf-viewer-tab" class="tab-button px-4 py-3 text-sm font-semibold text-slate-500 dark:text-slate-400 border-b-2 border-transparent hover:text-slate-700 dark:hover:text-slate-300 hover:bg-white/40 dark:hover:bg-slate-700/40 rounded-t-lg mx-1 transition-all duration-200 whitespace-nowrap">
 <span class="flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 <span>PDF Viewer</span>
 </span>
 </button>

 <button id="jupyter-tab" class="tab-button px-4 py-3 text-sm font-semibold text-slate-500 dark:text-slate-400 border-b-2 border-transparent hover:text-slate-700 dark:hover:text-slate-300 hover:bg-white/40 dark:hover:bg-slate-700/40 rounded-t-lg mx-1 transition-all duration-200 whitespace-nowrap">
 <span class="flex items-center space-x-2">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z"/>
 </svg>
 <span>Jupyter</span>
 </span>
 </button>
 </div>
 <button id="toggle-chat-sidebar-btn" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors" title="Toggle Panel">
 <svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>

 <!-- AI Chat Tab Content -->
 <div id="ai-chat-content" class="tab-content flex flex-col flex-1 min-h-0">
 <div id="chat-history" class="flex-1 min-h-0 p-2 space-y-3 overflow-y-auto text-sm chat-scroll-container">
 <!-- Chat messages will be appended here by JS -->
 <div class="ai-message animate-fade-in"><strong>AI: </strong></div>
 </div>
 <div id="chat-input-area" class="flex-shrink-0 p-4 border-t border-slate-200 dark:border-slate-700">
 <!-- Reply Input Container -->
 <div id="ai-chat-reply-container" class="reply-input-container hidden">
 <div class="reply-input-header">
 <span class="reply-input-title">Replying to message</span>
 <button id="ai-chat-reply-close" class="reply-input-close">
 <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 <div id="ai-chat-reply-preview" class="reply-input-preview"></div>
 </div>

 <!-- Image Preview Area -->
 <div id="ai-chat-image-preview" class="hidden mb-3 p-3 bg-slate-50 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-600">
 <div class="flex items-start space-x-3">
 <div class="flex-shrink-0">
 <img id="ai-chat-preview-img" src="" alt="Pasted image" class="w-16 h-16 object-cover rounded-lg border border-slate-300 dark:border-slate-500">
 </div>
 <div class="flex-1 min-w-0">
 <p class="text-sm font-medium text-slate-700 dark:text-slate-300">Image attached</p>
 <p class="text-xs text-slate-500 dark:text-slate-400">This image will be sent with your message</p>
 </div>
 <button id="ai-chat-remove-image" class="flex-shrink-0 p-1 text-slate-400 hover:text-slate-600 dark:hover:text-slate-300 transition-colors">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 </div>



 <div class="flex items-center space-x-2">
 <input type="text" id="chat-input" placeholder="Ask AI... (Ctrl+V to paste images)" class="flex-grow p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 placeholder-slate-400 dark:placeholder-slate-500 text-sm transition-colors">
<button id="send-to-ai-chat-button" title="Send Canvas Screenshot to AI" class="bg-indigo-500 hover:bg-indigo-600 text-white p-2.5 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-slate-800">
<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
</svg>
</button>
 <button id="send-button" class="bg-indigo-500 hover:bg-indigo-600 text-white p-2.5 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-slate-800">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
 </button>
 </div>
 </div>
 </div>

 <!-- Group Message Tab Content -->
 <div id="group-message-content" class="tab-content flex flex-col flex-1 min-h-0 hidden">
 <!-- Room Connection Section -->
 <div id="room-connection-section" class="flex-shrink-0 p-4 border-b border-slate-200 dark:border-slate-700">
 <!-- Not Connected State -->
 <div id="group-not-connected" class="text-center py-6">
 <div class="text-slate-500 dark:text-slate-400 text-sm mb-2">
 <svg class="w-8 h-8 mx-auto mb-2 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
 </svg>
 Join a collaboration room to start group messaging
 </div>
 <p class="text-xs text-slate-400 dark:text-slate-500">
 Use the "Create" or "Join" buttons in the toolbar to connect to a collaboration room
 </p>
 </div>

 <!-- Connected State -->
 <div id="group-connected" class="hidden">
 <div class="flex items-center justify-between">
 <div>
 <p class="text-sm font-medium text-slate-700 dark:text-slate-300">Group Messaging Active</p>
 <p id="group-current-room-id" class="text-xs text-slate-500 dark:text-slate-400"></p>
 <p id="group-current-user-name" class="text-xs text-slate-500 dark:text-slate-400"></p>
 </div>
 <div class="flex items-center space-x-2">
 <div id="group-connection-indicator" class="w-2 h-2 rounded-full bg-green-500"></div>
 <span class="text-xs text-slate-600 dark:text-slate-400">Connected</span>
 </div>
 </div>
 </div>
 </div>

 <!-- Messages Header -->
 <div id="group-messages-header" class="flex-shrink-0 px-4 py-2 border-b border-slate-200 dark:border-slate-700 bg-slate-50/50 dark:bg-slate-800/50 hidden">
 <div class="flex items-center justify-between">
 <span class="text-sm font-medium text-slate-700 dark:text-slate-300">Group Messages</span>
 <button id="mute-notifications-btn" class="mute-button">
 <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
 </svg>
 <span id="mute-btn-text">Mute</span>
 </button>
 </div>
 </div>

 <!-- Messages Area -->
 <div id="group-messages" class="flex-1 min-h-0 p-4 space-y-3 overflow-y-auto text-sm chat-scroll-container">
 <div id="group-messages-placeholder" class="text-center text-slate-500 dark:text-slate-400 text-xs">
 Join a collaboration room to start messaging
 </div>
 </div>

 <!-- Message Input Area -->
 <div id="group-message-input-area" class="flex-shrink-0 p-4 border-t border-slate-200 dark:border-slate-700">
 <!-- Reply Input Container -->
 <div id="group-reply-container" class="reply-input-container hidden">
 <div class="reply-input-header">
 <span class="reply-input-title">Replying to message</span>
 <button id="group-reply-close" class="reply-input-close">
 <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 <div id="group-reply-preview" class="reply-input-preview"></div>
 </div>

 <div class="flex items-center space-x-2">
 <input type="text" id="group-message-input" placeholder="Type a message..." class="flex-grow p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 placeholder-slate-400 dark:placeholder-slate-500 text-sm transition-colors" disabled>
 <input type="file" id="file-upload-input" class="hidden" multiple accept="*/*">
 <button id="file-upload-button" class="p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50" disabled title="Upload File">
 <svg class="w-5 h-5 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
 </svg>
 </button>
 <button id="group-send-button" class="bg-indigo-500 hover:bg-indigo-600 text-white p-2.5 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-slate-800 disabled:opacity-50" disabled>
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
 </button>
 </div>
 </div>
 </div>

 <!-- PDF Viewer Tab Content -->
 <div id="pdf-viewer-content" class="tab-content flex flex-col flex-1 min-h-0 hidden">
 <!-- PDF Upload Section -->
 <div id="pdf-upload-section" class="flex-shrink-0 p-4 border-b border-slate-200 dark:border-slate-700">
 <div id="pdf-not-loaded" class="text-center py-6">
 <div class="text-slate-500 dark:text-slate-400 text-sm mb-4">
 <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 <p class="font-medium mb-2">Upload a PDF to view</p>
 <p class="text-xs text-slate-400 dark:text-slate-500 mb-4">
 Drag and drop a PDF file here or click to browse
 </p>
 </div>
 <div class="flex justify-center">
 <input type="file" id="pdf-file-input" class="hidden" accept=".pdf,application/pdf">
 <button id="pdf-upload-button" class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:focus:ring-offset-slate-800 text-sm">
 Choose PDF File
 </button>
 </div>
 </div>

 <!-- PDF Loaded State -->
 <div id="pdf-loaded" class="hidden">
 <div class="flex items-center justify-between">
 <div class="flex-1 min-w-0">
 <p id="pdf-filename" class="text-sm font-medium text-slate-700 dark:text-slate-300 truncate"></p>
 <p id="pdf-info" class="text-xs text-slate-500 dark:text-slate-400"></p>
 </div>
 <button id="pdf-close-button" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors" title="Close PDF">
 <svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 </div>
 </div>

 <!-- PDF Controls -->
 <div id="pdf-controls" class="flex-shrink-0 p-3 border-b border-slate-200 dark:border-slate-700 hidden">
 <div class="flex items-center justify-between space-x-2">
 <!-- Navigation Controls -->
 <div class="flex items-center space-x-1">
 <button id="pdf-prev-page" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors disabled:opacity-50" disabled title="Previous Page">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
 </svg>
 </button>
 <div class="flex items-center space-x-1 text-xs">
 <input type="number" id="pdf-page-input" class="w-12 px-1 py-0.5 text-center border border-slate-300 dark:border-slate-600 rounded bg-white dark:bg-slate-700 text-slate-700 dark:text-slate-300" min="1" value="1">
 <span class="text-slate-500 dark:text-slate-400">/</span>
 <span id="pdf-total-pages" class="text-slate-500 dark:text-slate-400">0</span>
 </div>
 <button id="pdf-next-page" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors disabled:opacity-50" disabled title="Next Page">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
 </svg>
 </button>
 </div>

 <!-- Zoom Controls -->
 <div class="flex items-center space-x-1">
 <button id="pdf-zoom-out" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors" title="Zoom Out">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"/>
 </svg>
 </button>
 <span id="pdf-zoom-level" class="text-xs text-slate-600 dark:text-slate-400 min-w-[3rem] text-center">100%</span>
 <button id="pdf-zoom-in" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors" title="Zoom In">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"/>
 </svg>
 </button>
 <button id="pdf-fit-width" class="p-1.5 rounded-md hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors text-xs" title="Fit Width">
 W
 </button>
 </div>

 <!-- AI Controls -->
 <div class="flex items-center space-x-1">
 <button id="pdf-send-to-ai" class="px-3 py-1.5 bg-indigo-500 hover:bg-indigo-600 text-white text-xs rounded-md transition-colors" title="Send current page to AI Chat">
 <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
 </svg>
 Send to AI
 </button>
 <button id="pdf-voice-ai" class="px-3 py-1.5 bg-green-500 hover:bg-green-600 text-white text-xs rounded-md transition-colors" title="Voice AI for current PDF page">
 <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
 </svg>
 Voice AI
 </button>
 </div>
 </div>
 </div>

 <!-- PDF Viewer Area -->
 <div id="pdf-viewer-area" class="flex-1 min-h-0 overflow-auto bg-slate-50 dark:bg-slate-900 hidden relative">
 <div id="pdf-loading" class="flex items-center justify-center h-full absolute inset-0 z-10 bg-slate-50 dark:bg-slate-900">
 <div class="text-center">
 <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-500 mx-auto mb-2"></div>
 <p class="text-sm text-slate-500 dark:text-slate-400">Loading PDF...</p>
 </div>
 </div>
 <div id="pdf-container" class="pdf-container">
 <!-- PDF pages will be rendered here -->
 </div>
 </div>
 </div>



 <!-- Jupyter Tab Content -->
 <div id="jupyter-content" class="tab-content flex flex-col flex-1 min-h-0 hidden">
 <!-- Jupyter Notebook Header -->
 <div class="flex-shrink-0 p-4 border-b border-slate-200/50 dark:border-slate-700/50 bg-gradient-to-r from-white/90 to-indigo-50/30 dark:from-slate-800/90 dark:to-indigo-900/30 backdrop-blur-sm">
 <div class="flex items-center justify-between">
 <div class="flex items-center space-x-3">
 <div class="flex items-center space-x-2">

 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z"/>
 </svg>
 </div>

 </div>
 <div class="flex items-center space-x-2 overflow-x-auto" style="scrollbar-width: none; -ms-overflow-style: none;">
 <button id="add-cell-btn" class="px-4 py-2 text-sm bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white rounded-lg transition-all duration-200 transform hover:scale-105 shadow-md whitespace-nowrap">
 <span class="flex items-center space-x-1">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
 </svg>
 <span>Code</span>
 </span>
 </button>
 <button id="run-all-btn" class="px-4 py-2 text-sm bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white rounded-lg transition-all duration-200 transform hover:scale-105 shadow-md whitespace-nowrap">
 <span class="flex items-center space-x-1">
 <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
 <path d="M8 5v14l11-7z"/>
 </svg>
 <span>Run All</span>
 </span>
 </button>
 <button id="clear-all-btn" class="px-4 py-2 text-sm bg-gradient-to-r from-slate-500 to-slate-600 hover:from-slate-600 hover:to-slate-700 text-white rounded-lg transition-all duration-200 transform hover:scale-105 shadow-md whitespace-nowrap">
 <span class="flex items-center space-x-1">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
 </svg>
 <span>Clear All</span>
 </span>
 </button>
 <button id="import-csv-btn" class="px-4 py-2 text-sm bg-gradient-to-r from-blue-500 to-cyan-600 hover:from-blue-600 hover:to-cyan-700 text-white rounded-lg transition-all duration-200 transform hover:scale-105 shadow-md whitespace-nowrap">
 <span class="flex items-center space-x-1">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10"/>
 </svg>
 <span>Import CSV</span>
 </span>
 </button>
 <button id="show-datasets-btn" class="px-4 py-2 text-sm bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white rounded-lg transition-all duration-200 transform hover:scale-105 shadow-md whitespace-nowrap">
 <span class="flex items-center space-x-1">
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4"/>
 </svg>
 <span>Datasets</span>
 </span>
 </button>
 <div id="jupyter-status" class="text-sm font-medium text-slate-600 dark:text-slate-400 px-3 py-1 bg-slate-100 dark:bg-slate-700 rounded-full whitespace-nowrap">
 Loading...
 </div>
 </div>
 </div>
 </div>

 <!-- Jupyter Notebook Container -->
 <div id="notebook-container" class="flex-1 overflow-y-auto overflow-x-auto p-4 bg-gradient-to-br from-slate-50/80 to-indigo-50/30 dark:from-slate-900/80 dark:to-indigo-900/30" style="scrollbar-width: none; -ms-overflow-style: none;">
 <div id="cells-container" class="max-w-4xl mx-auto space-y-6 min-w-max">
 <!-- Initial cell will be added by JavaScript -->
 </div>
 </div>
 </div>

 </aside>
 </div>

<!-- Hidden CSV file input -->
<input type="file" id="csv-file-input" class="hidden" accept=".csv" multiple>

<!-- Dataset Manager Modal -->
<div id="dataset-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
 <div class="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
 <h3 class="text-lg font-semibold text-slate-900 dark:text-slate-100">Dataset Manager</h3>
 <button id="close-dataset-modal" class="text-slate-400 hover:text-slate-600 dark:hover:text-slate-300">
 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 <div class="p-4 overflow-y-auto max-h-[60vh]">
 <div id="dataset-list" class="space-y-3">
 <div class="text-center text-slate-500 dark:text-slate-400 py-8">
 <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 <p>No datasets imported yet</p>
 <p class="text-xs mt-1">Click "Import CSV" to add datasets</p>
 </div>
 </div>
 </div>
 <div class="flex justify-end space-x-2 p-4 border-t border-slate-200 dark:border-slate-700">
 <button id="import-csv-from-modal" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors">
 Import CSV
 </button>
 <button id="close-dataset-modal-btn" class="px-4 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded transition-colors">
 Close
 </button>
 </div>
 </div>
</div>

<!-- Image Preview Modal -->
<div id="image-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
 <div class="relative max-w-[90vw] max-h-[90vh] bg-white dark:bg-slate-800 rounded-lg shadow-xl overflow-hidden">
 <div class="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
 <h3 id="image-modal-title" class="text-lg font-semibold text-slate-900 dark:text-slate-100 truncate">Image Preview</h3>
 <button id="close-image-modal" class="text-slate-400 hover:text-slate-600 dark:hover:text-slate-300 flex-shrink-0 ml-4">
 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 <div class="p-4 flex items-center justify-center bg-slate-50 dark:bg-slate-900">
 <img id="image-modal-img" src="" alt="" class="max-w-full max-h-[70vh] object-contain rounded-lg">
 </div>
 <div class="flex justify-center space-x-2 p-4 border-t border-slate-200 dark:border-slate-700">
 <a id="image-modal-download" href="" download="" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors">
 <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 Download
 </a>
 <button id="close-image-modal-btn" class="px-4 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded transition-colors">
 Close
 </button>
 </div>
 </div>
</div>

<!-- Video Popup Modal -->
<div id="video-popup-modal" class="video-popup-modal">
    <div class="video-popup-container">
        <div class="video-popup-header">
            <div class="video-popup-title" id="video-popup-title">Video Call Participant</div>
            <button id="video-popup-close" class="video-popup-close" title="Close">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        <video id="video-popup-video" class="video-popup-video" autoplay playsinline muted></video>
    </div>
</div>

<script>
console.log("üöÄ Script loading started...");

// Global error handler to catch any issues
window.addEventListener('error', (e) => {
 console.error('üö® Global error caught:', e.error);
 if (typeof undoRedoEnabled !== 'undefined') {
 undoRedoEnabled = false;
 console.log('üö´ Undo/Redo system disabled due to error');
 }
});

document.addEventListener('DOMContentLoaded', () => {
 console.log("DOM fully loaded. Initializing Modern UI script...");

 console.log("üé® Initializing Fabric.js canvas...");

 // Get canvas parent for dynamic sizing
 const canvasParent = document.getElementById('canvas-parent');

 // Calculate responsive canvas size to fill the container
 const BASE_W = canvasParent.clientWidth;
 const BASE_H = canvasParent.clientHeight;

 // Detect if device has coarse pointer (mobile/tablet)
 const isCoarse = matchMedia('(pointer:coarse)').matches;

 console.log(`üì± Device detection: ${isCoarse ? 'Mobile/Tablet' : 'Desktop'} (${BASE_W}x${BASE_H})`);

 const fabricCanvas = new fabric.Canvas('main-canvas', {
 width: BASE_W,
 height: BASE_H,
 isDrawingMode: false,
 backgroundColor: document.documentElement.classList.contains('dark') ? '#0f172a' : '#ffffff',
 selection: true,
 enableRetinaScaling: false, // üëà Critical for iPad performance
 renderOnAddRemove: false    // üëà Manual render control for better performance
 });
 console.log("‚úÖ Fabric canvas initialized successfully with performance optimizations.");

 // üöÄ INFINITE CANVAS: Setup viewport-based infinite canvas
 let viewportX = 0;
 let viewportY = 0;
 const INFINITE_CANVAS_SIZE = 50000; // Virtual canvas size

 // Enable infinite panning (we handle touch ourselves)
 fabricCanvas.allowTouchScrolling = false;

 // Setup infinite canvas panning with mouse/touch
 let isPanning = false;
 let lastPanPoint = { x: 0, y: 0 };
 let isGesturing = false; // Flag to block all Fabric.js events during gestures
 let gestureStartTime = 0; // Track when gesture started for additional safety

 // Pan Mode - dedicated navigation mode
 let isPanModeActive = false;
 let panModeButton = null;

 // Add pan functionality with space key or middle mouse
  function enableInfinitePanning() {
     // Mouse panning: Middle mouse, Shift+click, or Space+click
     canvasParent.addEventListener('mousedown', (e) => {
         if (e.button === 1 || (e.button === 0 && e.shiftKey) || (e.button === 0 && isSpacePressed)) {
             isPanning = true;
             isGesturing = true; // Block Fabric.js events during mouse panning
             isSpacePanning = (e.button === 0 && isSpacePressed); // Track if this is space panning
             lastPanPoint = { x: e.clientX, y: e.clientY };
             canvasParent.style.cursor = 'grabbing';

             // Disable ALL canvas interactions during panning
             canvasParent.dataset.wasDrawingMode = fabricCanvas.isDrawingMode ? 'true' : 'false';
             canvasParent.dataset.wasSelection = fabricCanvas.selection ? 'true' : 'false';

             fabricCanvas.isDrawingMode = false;
             fabricCanvas.selection = false;
             fabricCanvas.discardActiveObject();

             // Make all objects non-interactive during panning
             fabricCanvas.getObjects().forEach(obj => {
                 obj.selectable = false;
                 obj.evented = false;
             });

             e.preventDefault();
             e.stopPropagation();
         }
     });

     canvasParent.addEventListener('mousemove', (e) => {
         if (isPanning) {
             const deltaX = e.clientX - lastPanPoint.x;
             const deltaY = e.clientY - lastPanPoint.y;

             // Apply viewport transform directly - works at all zoom levels
             const vpt = fabricCanvas.viewportTransform;
             vpt[4] += deltaX;
             vpt[5] += deltaY;
             fabricCanvas.setViewportTransform(vpt);
             fabricCanvas.requestRenderAll();

             lastPanPoint = { x: e.clientX, y: e.clientY };
             e.preventDefault();
         }
     });

     canvasParent.addEventListener('mouseup', (e) => {
         if (isPanning) {
             isPanning = false;
             isGesturing = false; // Re-enable Fabric.js events

             // Set cursor based on whether space is still pressed
             canvasParent.style.cursor = (isSpacePressed && !isSpacePanning) ? 'grab' : '';
             isSpacePanning = false;

             // Small delay to ensure panning is completely finished
             setTimeout(() => {
                 // Restore all previous canvas states
                 if (canvasParent.dataset.wasDrawingMode === 'true') {
                     fabricCanvas.isDrawingMode = true;
                 }
                 if (canvasParent.dataset.wasSelection === 'true') {
                     fabricCanvas.selection = true;
                 }

                 // Restore object interactivity
                 fabricCanvas.getObjects().forEach(obj => {
                     obj.selectable = true;
                     obj.evented = true;
                 });

                 // Clear stored states
                 canvasParent.dataset.wasDrawingMode = '';
                 canvasParent.dataset.wasSelection = '';
             }, 50);
         }
     });

     // Global mousemove listener to handle panning outside canvas (optimized)
     document.addEventListener('mousemove', (e) => {
         if (isPanning) {
             const deltaX = e.clientX - lastPanPoint.x;
             const deltaY = e.clientY - lastPanPoint.y;

             // Only update if there's meaningful movement (reduce unnecessary renders)
             if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {
                 // Apply viewport transform directly - works at all zoom levels
                 const vpt = fabricCanvas.viewportTransform;
                 vpt[4] += deltaX;
                 vpt[5] += deltaY;
                 fabricCanvas.setViewportTransform(vpt);
                 fabricCanvas.requestRenderAll();

                 lastPanPoint = { x: e.clientX, y: e.clientY };
             }
             e.preventDefault();
         }
     });

     // Global mouseup listener to handle panning end outside canvas
     document.addEventListener('mouseup', (e) => {
         if (isPanning) {
             isPanning = false;
             isGesturing = false; // Re-enable Fabric.js events
             canvasParent.style.cursor = '';

             // Small delay to ensure panning is completely finished
             setTimeout(() => {
                 // Restore all previous canvas states
                 if (canvasParent.dataset.wasDrawingMode === 'true') {
                     fabricCanvas.isDrawingMode = true;
                 }
                 if (canvasParent.dataset.wasSelection === 'true') {
                     fabricCanvas.selection = true;
                 }

                 // Restore object interactivity
                 fabricCanvas.getObjects().forEach(obj => {
                     obj.selectable = true;
                     obj.evented = true;
                 });

                 // Clear stored states
                 canvasParent.dataset.wasDrawingMode = '';
                 canvasParent.dataset.wasSelection = '';
             }, 50);
         }
     });

     // Touch support for mobile panning and zooming
     let touchStartPoint = null;
     let touchStartDistance = null;
     let touchStartZoom = 1;

    canvasParent.addEventListener('touchstart', (e) => {
        if (e.touches.length >= 2) { // Two-finger pan/zoom
             // Gesture flag should already be set by canvas-level handler
             if (!isGesturing) {
                 isGesturing = true;
                 gestureStartTime = Date.now();
             }

             touchStartPoint = {
                 x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                 y: (e.touches[0].clientY + e.touches[1].clientY) / 2
             };

             // Calculate initial distance for zoom
             touchStartDistance = Math.sqrt(
                 Math.pow(e.touches[1].clientX - e.touches[0].clientX, 2) +
                 Math.pow(e.touches[1].clientY - e.touches[0].clientY, 2)
             );
             touchStartZoom = currentZoom;

             // Store current tool states for restoration
             canvasParent.dataset.wasDrawingMode = fabricCanvas.isDrawingMode ? 'true' : 'false';
             canvasParent.dataset.wasSelection = fabricCanvas.selection ? 'true' : 'false';

             // Aggressively disable ALL canvas interactions
             fabricCanvas.isDrawingMode = false;
             fabricCanvas.selection = false;
             fabricCanvas.discardActiveObject();

             // Make all objects non-interactive during gestures only
             fabricCanvas.getObjects().forEach(obj => {
                 obj.selectable = false;
                 obj.evented = false;
             });

             fabricCanvas.renderAll(); // Force immediate render of state change

             console.log('üéØ Two-finger gesture initialized - all tools disabled');
             e.preventDefault();
             e.stopPropagation();
         }
     }, { passive: false });

    canvasParent.addEventListener('touchmove', (e) => {
        // Two‚Äëfinger pinch/zoom + pan
        if (e.touches.length === 2 && touchStartPoint && touchStartDistance) {
            e.preventDefault(); // Prevent immediately to avoid lag

             const currentPoint = {
                 x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                 y: (e.touches[0].clientY + e.touches[1].clientY) / 2
             };

             // Calculate current distance for zoom (optimized)
             const dx = e.touches[1].clientX - e.touches[0].clientX;
             const dy = e.touches[1].clientY - e.touches[0].clientY;
             const currentDistance = Math.sqrt(dx * dx + dy * dy);

             // Handle zoom with reduced threshold for responsiveness
             const zoomFactor = currentDistance / touchStartDistance;
             const newZoom = Math.max(0.1, Math.min(5, touchStartZoom * zoomFactor));

            // Reduced threshold for more responsive zoom
            if (Math.abs(newZoom - currentZoom) > 0.003) {
                currentZoom = newZoom;
                const rect = fabricCanvas.getElement().getBoundingClientRect();
                const point = new fabric.Point(currentPoint.x - rect.left, currentPoint.y - rect.top);
                // Zoom anchored at pinch center for stability
                fabricCanvas.zoomToPoint(point, currentZoom);
            }

             // Handle pan with reduced threshold for snappier response
             const deltaX = currentPoint.x - touchStartPoint.x;
             const deltaY = currentPoint.y - touchStartPoint.y;

             // Reduced threshold from 2 to 1 for more responsive panning
             if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                 const vpt = fabricCanvas.viewportTransform;
                 vpt[4] += deltaX;
                 vpt[5] += deltaY;
                 fabricCanvas.setViewportTransform(vpt);
                 touchStartPoint = currentPoint;
             }

             // Use requestRenderAll for better performance
             fabricCanvas.requestRenderAll();
        }

        // Single‚Äëfinger pan support (especially for Pan Mode)
        else if (e.touches.length === 1 && isPanning) {
            const touch = e.touches[0];
            const deltaX = touch.clientX - lastPanPoint.x;
            const deltaY = touch.clientY - lastPanPoint.y;
            const vpt = fabricCanvas.viewportTransform;
            vpt[4] += deltaX;
            vpt[5] += deltaY;
            fabricCanvas.setViewportTransform(vpt);
            fabricCanvas.requestRenderAll();
            lastPanPoint = { x: touch.clientX, y: touch.clientY };
            e.preventDefault();
        }

        // Single‚Äëfinger pan start when in Pan Mode (or while Space is pressed)
        if (e.touches.length === 1 && (isPanModeActive || isSpacePressed)) {
            const touch = e.touches[0];
            isPanning = true;
            isGesturing = true; // unify handling to pause other events
            lastPanPoint = { x: touch.clientX, y: touch.clientY };
            canvasParent.style.cursor = 'grabbing';

            canvasParent.dataset.wasDrawingMode = fabricCanvas.isDrawingMode ? 'true' : 'false';
            canvasParent.dataset.wasSelection = fabricCanvas.selection ? 'true' : 'false';
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = false;
            fabricCanvas.discardActiveObject();
            fabricCanvas.getObjects().forEach(obj => { obj.selectable = false; obj.evented = false; });
            e.preventDefault();
            e.stopPropagation();
        }
    }, { passive: false });

    canvasParent.addEventListener('touchend', (e) => {
        // Finish single‚Äëfinger pan
        if (e.touches.length === 0 && isPanning) {
            isPanning = false;
            isGesturing = false;
            canvasParent.style.cursor = '';
            // Restore object interactivity
            fabricCanvas.getObjects().forEach(obj => { obj.selectable = true; obj.evented = true; });
        }

        if (e.touches.length < 2 && isGesturing) {
            touchStartPoint = null;
            touchStartDistance = null;

             // Shorter delay for better responsiveness, especially for select tool
             const delay = currentTool === 'select' ? 10 : 50;
             setTimeout(() => {
                 isGesturing = false; // Re-enable Fabric.js events
                 console.log('‚úÖ Gesture ended, re-enabling interactions');

                 // Restore all previous canvas states
                 if (canvasParent.dataset.wasDrawingMode === 'true') {
                     fabricCanvas.isDrawingMode = true;
                 }
                 if (canvasParent.dataset.wasSelection === 'true') {
                     fabricCanvas.selection = true;
                 }

                 // Restore object interactivity
                 fabricCanvas.getObjects().forEach(obj => {
                     obj.selectable = true;
                     obj.evented = true;
                 });

                 // Force canvas re-render to ensure clean state
                 fabricCanvas.renderAll();

                 // Clear stored states
                 canvasParent.dataset.wasDrawingMode = '';
                 canvasParent.dataset.wasSelection = '';

                 console.log('‚úÖ Gesture ended - tools restored');
             }, 150); // Increased delay for better reliability
         }
     });
 }

 // Initialize infinite panning
 enableInfinitePanning();

 // SIMPLIFIED GESTURE BLOCKING: Only block Fabric.js events, not touch events
 console.log("üö´ Gesture blocking enabled - Fabric.js events only");



 // Minimal Fabric.js blocking - only block during actual two-finger gestures
 const originalOnMouseDown = fabricCanvas._onMouseDown;

 fabricCanvas._onMouseDown = function(e) {
     // Only block during confirmed two-finger gestures
     if (isGesturing && touchStartPoint && e.touches && e.touches.length >= 2) {
         console.log('üö´ Blocked Fabric.js drawing during confirmed two-finger gesture');
         return;
     }
     return originalOnMouseDown.call(this, e);
 };

 console.log("üåå Infinite canvas support enabled");
 console.log("üö´ Gesture blocking enabled");
 console.log("üñ±Ô∏è PC scroll panning enabled");
 console.log("‚å®Ô∏è Text field keyboard support enabled");

 // Test syntax check
 console.log("‚úÖ Syntax check passed");

 // === PAN MODE FUNCTIONALITY ===

 // Function to block selection events during Pan Mode
 function blockSelectionInPanMode(e) {
     if (isPanModeActive) {
         // Only block if we're actually in Pan Mode
         if (e.e) {
             e.e.preventDefault();
             e.e.stopPropagation();
         }

         // Prevent any object selection or manipulation
         if (e.target) {
             fabricCanvas.discardActiveObject();
         }

         console.log('üö´ Blocked selection event in Pan Mode:', e.type);
         return false;
     }
     // If not in Pan Mode, allow the event to proceed normally
     return true;
 }

 function togglePanMode() {
     isPanModeActive = !isPanModeActive;

     if (isPanModeActive) {
         enablePanMode();
     } else {
         disablePanMode();
     }
 }

 function enablePanMode() {
     console.log('üéØ Pan Mode ENABLED - Navigation only');

     // FIRST: Reset all tool states to ensure clean transition
     resetAllToolStates();

     // Store current tool state (before activating pan mode) - use correct CSS class
     const currentActiveButton = document.querySelector('.toolbar-button.active-tool');
     if (currentActiveButton && currentActiveButton !== panModeToolButton) {
         panModeButton = currentActiveButton;
         console.log('üîÑ Stored previous tool:', currentActiveButton.id);
     }

     // Disable ALL drawing and selection tools
     fabricCanvas.isDrawingMode = false;
     fabricCanvas.selection = false;
     fabricCanvas.discardActiveObject();

     // Simple approach: Just disable selection and object interaction
     fabricCanvas.skipTargetFind = true;

     // Make all objects non-interactive
     fabricCanvas.getObjects().forEach(obj => {
         obj.selectable = false;
         obj.evented = false;
         obj.hoverCursor = 'grab';
         obj.moveCursor = 'grab';
     });

     // Set grab cursors
     fabricCanvas.defaultCursor = 'grab';
     fabricCanvas.hoverCursor = 'grab';
     fabricCanvas.moveCursor = 'grab';

     // Optimize canvas for better panning performance
     fabricCanvas.renderOnAddRemove = false;
     fabricCanvas.skipOffscreen = true;

     console.log('üéØ Pan Mode enabled - selection disabled, performance optimized');

     // IMPORTANT: Clear all active tool buttons BEFORE setting Pan Mode active
     document.querySelectorAll('.toolbar-button').forEach(btn => {
         btn.classList.remove('active-tool', 'active');
     });

     // Set visual feedback for Pan Mode
     if (panModeToolButton) {
         setActiveToolButton(panModeToolButton);
         console.log('üéØ Pan Mode button set as active');
     }
     canvasParent.style.cursor = 'grab';

     // Show pan mode indicator
     showSystemMessage('üéØ Pan Mode: Use fingers/mouse to navigate. Click Pan Mode again to exit.', 'info');

     fabricCanvas.renderAll();
 }

 function disablePanMode() {
     console.log('‚úÖ Pan Mode DISABLED - Tools restored');

     // FIRST: Clear Pan Mode button active state
     if (panModeToolButton) {
         panModeToolButton.classList.remove('active-tool', 'active');
         console.log('üîÑ Removed active state from Pan Mode button');
     }

     // Restore canvas functionality
     fabricCanvas.selection = true;
     fabricCanvas.skipTargetFind = false;

     // Restore object interactivity
     fabricCanvas.getObjects().forEach(obj => {
         obj.selectable = true;
         obj.evented = true;
         obj.hoverCursor = 'move';
         obj.moveCursor = 'move';
     });

     // Restore cursors
     fabricCanvas.defaultCursor = 'default';
     fabricCanvas.hoverCursor = 'move';
     fabricCanvas.moveCursor = 'move';
     canvasParent.style.cursor = '';

     // Restore full rendering quality
     fabricCanvas.renderOnAddRemove = true;
     fabricCanvas.skipOffscreen = false;

     console.log('‚úÖ Pan Mode disabled - selection functionality and render quality restored');

     // Restore previous tool or default to select - use setActiveToolButton for proper state management
     if (panModeButton && panModeButton !== panModeToolButton) {
         console.log('üîÑ Restoring previous tool:', panModeButton.id);
         setActiveToolButton(panModeButton);
         // Trigger the tool's functionality if needed
         if (panModeButton.id === 'select-tool') {
             resetAllToolStates(); // Ensure select tool state
         }
     } else {
         console.log('üîÑ Defaulting to select tool');
         setActiveToolButton(selectToolButton);
         resetAllToolStates(); // Ensure select tool state
     }

     // Clear stored previous tool
     panModeButton = null;

     showSystemMessage('‚úÖ Pan Mode disabled - Tools restored', 'success');

     fabricCanvas.renderAll();
 }

 // Add keyboard shortcuts for infinite canvas navigation
 let isSpacePressed = false;
 let isSpacePanning = false;

 document.addEventListener('keydown', (e) => {
     // Check if user is typing in a text field or text area
     const isTyping = e.target.tagName === 'INPUT' ||
                     e.target.tagName === 'TEXTAREA' ||
                     e.target.contentEditable === 'true' ||
                     e.target.isContentEditable;

     // P key for Pan Mode toggle (only when not typing)
     if ((e.key === 'p' || e.key === 'P') && !isTyping) {
         if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
             e.preventDefault();
             togglePanMode();
             return;
         }
     }

     // Space + drag for panning (only when not typing)
     if (e.code === 'Space' && !e.repeat && !isSpacePressed && !isTyping) {
         isSpacePressed = true;
         canvasParent.style.cursor = 'grab';

         // Temporarily disable drawing mode for space panning
         if (fabricCanvas.isDrawingMode) {
             canvasParent.dataset.wasDrawingModeSpace = 'true';
             fabricCanvas.isDrawingMode = false;
         }
         if (fabricCanvas.selection) {
             canvasParent.dataset.wasSelectionSpace = 'true';
             fabricCanvas.selection = false;
         }

         e.preventDefault();
     }
 });

 document.addEventListener('keyup', (e) => {
     // Check if user is typing in a text field
     const isTyping = e.target.tagName === 'INPUT' ||
                     e.target.tagName === 'TEXTAREA' ||
                     e.target.contentEditable === 'true' ||
                     e.target.isContentEditable;

     if (e.code === 'Space' && isSpacePressed && !isTyping) {
         isSpacePressed = false;
         isSpacePanning = false;
         canvasParent.style.cursor = '';

         // Restore previous tool states
         if (canvasParent.dataset.wasDrawingModeSpace === 'true') {
             fabricCanvas.isDrawingMode = true;
             canvasParent.dataset.wasDrawingModeSpace = '';
         }
         if (canvasParent.dataset.wasSelectionSpace === 'true') {
             fabricCanvas.selection = true;
             canvasParent.dataset.wasSelectionSpace = '';
         }
     }
 });



 // Global mouse events for space panning outside canvas
 document.addEventListener('mousemove', (e) => {
     if (isSpacePanning) {
         const deltaX = e.clientX - lastPanPoint.x;
         const deltaY = e.clientY - lastPanPoint.y;

         const vpt = fabricCanvas.viewportTransform;
         vpt[4] += deltaX;
         vpt[5] += deltaY;
         fabricCanvas.setViewportTransform(vpt);
         fabricCanvas.requestRenderAll();

         lastPanPoint = { x: e.clientX, y: e.clientY };
         e.preventDefault();
     }
 });

 document.addEventListener('mouseup', (e) => {
     if (isSpacePanning) {
         isSpacePanning = false;
         canvasParent.style.cursor = isSpacePressed ? 'grab' : '';
     }
 });

 // Arrow keys for precise navigation (only when not typing)
 document.addEventListener('keydown', (e) => {
     // Check if user is typing in a text field
     const isTyping = e.target.tagName === 'INPUT' ||
                     e.target.tagName === 'TEXTAREA' ||
                     e.target.contentEditable === 'true' ||
                     e.target.isContentEditable;

     if (!e.ctrlKey && !e.metaKey && !e.shiftKey && !isTyping) {
         const panSpeed = 50 / currentZoom; // Adjust speed based on zoom
         let deltaX = 0, deltaY = 0;

         switch(e.code) {
             case 'ArrowLeft':
                 deltaX = panSpeed;
                 break;
             case 'ArrowRight':
                 deltaX = -panSpeed;
                 break;
             case 'ArrowUp':
                 deltaY = panSpeed;
                 break;
             case 'ArrowDown':
                 deltaY = -panSpeed;
                 break;
         }

         if (deltaX !== 0 || deltaY !== 0) {
             const vpt = fabricCanvas.viewportTransform;
             vpt[4] += deltaX;
             vpt[5] += deltaY;
             fabricCanvas.setViewportTransform(vpt);
             fabricCanvas.requestRenderAll();
             e.preventDefault();
         }
     }
 });



 // Track last drawing center to help recentering
 let lastDrawCenter = null;

 // Unified function to detect if user is typing in any text field
 function isUserTypingInTextField() {
     const activeElement = document.activeElement;
     if (!activeElement) return false;

     // Check for standard input elements
     const tagName = activeElement.tagName.toUpperCase();
     if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') {
         return true;
     }

     // Check for contentEditable elements
     if (activeElement.contentEditable === 'true' || activeElement.isContentEditable) {
         return true;
     }

     // Check for Jupyter notebook cells
     if (activeElement.classList.contains('code-input') ||
         activeElement.closest('.cell') ||
         activeElement.closest('.jupyter-cell') ||
         activeElement.closest('#cells-container')) {
         return true;
     }

     // Check for specific input fields by ID
     const inputIds = [
         'chat-input', 'group-message-input', 'ai-chat-input',
         'room-name-input', 'max-users-input', 'room-id-input', 'display-name-input',
         'pdf-page-input', 'zoom-level-input'
     ];
     if (inputIds.includes(activeElement.id)) {
         return true;
     }

     // Check if element has input-related classes
     const inputClasses = ['input', 'textarea', 'editable', 'code-input'];
     if (inputClasses.some(cls => activeElement.classList.contains(cls))) {
         return true;
     }

     // Check for Fabric.js text editing mode
     if (typeof fabricCanvas !== 'undefined' && fabricCanvas) {
         const activeObjects = fabricCanvas.getActiveObjects();
         const textInEditingMode = activeObjects.find(obj =>
             obj.type === 'i-text' && obj.isEditing
         );
         if (textInEditingMode) {
             return true;
         }
     }

     return false;
 }

 // Function to center canvas view (fit to drawing content, ignore control helpers)
 function centerCanvasView() {
     console.log('üéØ centerCanvasView() called');

     if (!fabricCanvas) {
         console.log('‚ùå No fabricCanvas available');
         return;
     }

     const drawableTypes = new Set(['path','i-text','textbox','rect','circle','ellipse','line','arrow','image','polygon','polyline']);
     const allObjects = fabricCanvas.getObjects();
     const objects = allObjects.filter(o => o && o.visible !== false && !o.isControlPoint && drawableTypes.has(o.type));

     console.log(`üéØ Found ${allObjects.length} total objects, ${objects.length} drawable objects`);

     if (objects.length === 0) {
         console.log('üéØ No drawable objects found, centering to origin');
         // No objects, center to origin at 1x
         currentZoom = 1.0;
         fabricCanvas.setZoom(currentZoom);
         fabricCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
         fabricCanvas.requestRenderAll();
         updateZoomLevel();
         return;
     }

     // Bounding box in absolute canvas coordinates (accounts for transform)
     let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
     objects.forEach(obj => {
         const bounds = obj.getBoundingRect(true, true);
         minX = Math.min(minX, bounds.left);
         minY = Math.min(minY, bounds.top);
         maxX = Math.max(maxX, bounds.left + bounds.width);
         maxY = Math.max(maxY, bounds.top + bounds.height);
     });

     console.log(`üéØ Content bounds: (${minX.toFixed(1)}, ${minY.toFixed(1)}) to (${maxX.toFixed(1)}, ${maxY.toFixed(1)})`);

     // Center target: prefer last draw center if available, else content center
     const contentCenterX = (minX + maxX) / 2;
     const contentCenterY = (minY + maxY) / 2;
     const targetCenter = lastDrawCenter || new fabric.Point(contentCenterX, contentCenterY);

     console.log(`üéØ Target center: (${targetCenter.x.toFixed(1)}, ${targetCenter.y.toFixed(1)})`);

     // Zoom to fit content with padding
     const contentWidth = Math.max(1, maxX - minX);
     const contentHeight = Math.max(1, maxY - minY);
     const padding = 100; // Padding around content
     const zoomX = (fabricCanvas.width - padding * 2) / contentWidth;
     const zoomY = (fabricCanvas.height - padding * 2) / contentHeight;
     const optimalZoom = Math.min(zoomX, zoomY, 3); // cap
     currentZoom = Math.max(0.1, optimalZoom);

     console.log(`üéØ Canvas size: ${fabricCanvas.width}x${fabricCanvas.height}, content size: ${contentWidth.toFixed(1)}x${contentHeight.toFixed(1)}, optimal zoom: ${currentZoom.toFixed(2)}`);

     // Use zoomToPoint to keep the target at center of viewport
     const viewportCenter = new fabric.Point(fabricCanvas.width / 2, fabricCanvas.height / 2);
     const before = fabricCanvas.viewportTransform ? fabricCanvas.viewportTransform.slice() : [1,0,0,1,0,0];
     fabricCanvas.setViewportTransform([1,0,0,1,before[4],before[5]]);
     fabricCanvas.zoomToPoint(viewportCenter, currentZoom);

     // Translate so target center appears at viewport center
     const vpt = fabricCanvas.viewportTransform;
     vpt[4] = fabricCanvas.width / 2 - targetCenter.x * currentZoom;
     vpt[5] = fabricCanvas.height / 2 - targetCenter.y * currentZoom;
     fabricCanvas.setViewportTransform(vpt);
     fabricCanvas.requestRenderAll();
     updateZoomLevel();
     console.log(`üéØ Centered view: zoom=${currentZoom.toFixed(2)}, center=(${targetCenter.x.toFixed(1)}, ${targetCenter.y.toFixed(1)})`);
 }

 // Add keyboard shortcut for center view (Ctrl/Cmd + 0)
 document.addEventListener('keydown', (e) => {
     if ((e.ctrlKey || e.metaKey) && e.key === '0') {
         e.preventDefault();
         centerCanvasView();
     }
 });





 // Mini-map removed for cleaner interface

 // üöÄ PERFORMANCE SUMMARY: Log all optimizations applied
 console.log("üöÄ MOBILE PERFORMANCE OPTIMIZATIONS APPLIED:");
 console.log("‚úÖ Canvas bitmap size fixed (no resize on zoom)");
 console.log("‚úÖ Retina scaling disabled for iPad");
 console.log("‚úÖ Manual render control enabled");
 console.log("‚úÖ Brush decimation:", isCoarse ? "6 (Mobile)" : "2 (Desktop)");
 console.log("‚úÖ Cursor throttling:", isCoarse ? "120ms (Mobile)" : "50ms (Desktop)");
 console.log("‚úÖ Object movement throttling:", isCoarse ? "100ms (Mobile)" : "50ms (Desktop)");
 console.log("‚úÖ Touch-action: none applied to canvas");
 console.log("‚úÖ Infinite canvas with viewport-based rendering");
 console.log("‚úÖ Mini-map navigation enabled");
 console.log("‚úÖ Smart zoom reset (fit to content)");
 console.log("‚úÖ Keyboard navigation (arrow keys, space+drag)");
 console.log("‚úÖ Two-finger touch panning for mobile");

 // Add performance monitoring
 if (isCoarse) {
     let frameCount = 0;
     let lastTime = performance.now();

     function monitorPerformance() {
         frameCount++;
         const currentTime = performance.now();

         if (currentTime - lastTime >= 5000) { // Every 5 seconds
             const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
             console.log(`üìä Mobile Performance: ${fps} FPS average`);
             frameCount = 0;
             lastTime = currentTime;
         }

         requestAnimationFrame(monitorPerformance);
     }

     requestAnimationFrame(monitorPerformance);
     console.log("üìä Performance monitoring enabled for mobile device");
 }

 // ‚ú® CRITICAL FIX: Override fabric.Object.prototype.toObject to always include 'id'
 // This ensures that object IDs are never lost during serialization, fixing the issue
 // where third+ users can't move existing objects because IDs are dropped
 const origToObject = fabric.Object.prototype.toObject;
 fabric.Object.prototype.toObject = function (extra = []) {
 // Always include 'id' in the serialized object properties
 const propsToInclude = Array.isArray(extra) ? extra.concat(['id']) : ['id'];
 return origToObject.call(this, propsToInclude);
 };
 console.log("‚úÖ Fabric.js toObject override applied - IDs will always be preserved");

 // Enhanced WebRTC + WebSocket for real-time canvas synchronization
 let dataChannels = new Map(); // userId -> dataChannel
 let pendingOperations = new Map(); // operationId -> operation details
 let operationQueue = []; // Queue for reliable delivery
 let isProcessingRemoteOperation = false; // Flag to prevent loops
 let lastOperationTime = 0; // For throttling
 let isCreatingPath = false; // Flag to prevent duplicate path/object events
 let recentPathIds = new Set(); // Track recently created path IDs
 let currentPattern = null; // Current selected pattern type
 let currentCanvasPattern = null; // Current applied CSS pattern settings

 // --- DOM Elements ---
 const chatHistory = document.getElementById('chat-history');
 const chatInput = document.getElementById('chat-input');
 const sendButton = document.getElementById('send-button');

 // AI Chat Image Preview Elements
 const aiChatImagePreview = document.getElementById('ai-chat-image-preview');
 const aiChatPreviewImg = document.getElementById('ai-chat-preview-img');
 const aiChatRemoveImage = document.getElementById('ai-chat-remove-image');

 // PDF Viewer AI Elements
 const pdfSendToAiBtn = document.getElementById('pdf-send-to-ai');
 const pdfVoiceAiBtn = document.getElementById('pdf-voice-ai');
 let aiChatAttachedImage = null; // Store the attached image data

 // PDF Viewer AI Variables

 const colorPicker = document.getElementById('color-picker');
 const brushSizeSlider = document.getElementById('brush-size');
 const penToolButton = document.getElementById('pen-tool');
 const lineToolButton = document.getElementById('line-tool');
 const arrowToolButton = document.getElementById('arrow-tool');
 const circleToolButton = document.getElementById('circle-tool');
 const rectangleToolButton = document.getElementById('rectangle-tool');
 const highlighterRectButton = document.getElementById('highlighter-rect-tool');
 const highlighterCircleButton = document.getElementById('highlighter-circle-tool');
 const textToolButton = document.getElementById('text-tool');
 const imageUploadToolButton = document.getElementById('image-upload-tool');
 const imageUploadInput = document.getElementById('image-upload-input');
 const selectToolButton = document.getElementById('select-tool');
 const panModeToolButton = document.getElementById('pan-mode-tool');
 const eraseSelectedButton = document.getElementById('erase-selected');

 // Debug: Check if Pan Mode button was found
 if (!panModeToolButton) {
     console.error('‚ùå Pan Mode button not found!');
 } else {
     console.log('‚úÖ Pan Mode button found:', panModeToolButton);
 }
 const eraseCanvasButton = document.getElementById('erase-canvas');
 const undoButton = document.getElementById('undo-btn');
 const redoButton = document.getElementById('redo-btn');
 const askAiCanvasButton = document.getElementById('ask-ai-canvas');

 // IMMEDIATE UNDO/REDO BUTTON SETUP - RIGHT HERE WHERE BUTTONS ARE FOUND
 console.log('üîß Setting up undo/redo buttons immediately...');
 if (undoButton) {
     undoButton.addEventListener('click', function(e) {
         e.preventDefault();
         console.log('üîÑ UNDO BUTTON CLICKED - IMMEDIATE SETUP');
         if (commandHistory && commandHistory.canUndo()) {
             commandHistory.undo();
             console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
         } else {
             console.log('‚ùå Cannot undo - commandHistory:', !!commandHistory, 'canUndo:', commandHistory?.canUndo());
         }
     });
     console.log('‚úÖ Undo button listener added immediately');
 } else {
     console.log('‚ùå Undo button not found');
 }

 if (redoButton) {
     redoButton.addEventListener('click', function(e) {
         e.preventDefault();
         console.log('üîÑ REDO BUTTON CLICKED - IMMEDIATE SETUP');
         if (commandHistory && commandHistory.canRedo()) {
             commandHistory.redo();
             console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
         } else {
             console.log('‚ùå Cannot redo - commandHistory:', !!commandHistory, 'canRedo:', commandHistory?.canRedo());
         }
     });
     console.log('‚úÖ Redo button listener added immediately');
 } else {
     console.log('‚ùå Redo button not found');
 }
 const toggleHighContrastButton = document.getElementById('toggle-high-contrast');
 const zoomInButton = document.getElementById('zoom-in');
 const zoomOutButton = document.getElementById('zoom-out');
 const zoomResetButton = document.getElementById('zoom-reset');
 const zoomLevelDisplay = document.getElementById('zoom-level');
 const toggleMagnifierButton = document.getElementById('toggle-magnifier');
 const fontSizer = document.getElementById('font-sizer');
 const exportPdfButton = document.getElementById('export-pdf');
 // canvasParent already declared above - reusing existing variable
 const mainCanvasEl = document.getElementById('main-canvas');
 const magnifierPreview = document.getElementById('magnifier-preview');
 const toggleToolbarContentBtn = document.getElementById('toggle-toolbar-content-btn');
 const toolbarContent = document.getElementById('toolbar-content');
 const toolbarChevronIcon = document.getElementById('toolbar-chevron-icon');

 const allToolButtons = [penToolButton, lineToolButton, arrowToolButton, circleToolButton, rectangleToolButton, highlighterRectButton, highlighterCircleButton, textToolButton, imageUploadToolButton, selectToolButton, panModeToolButton];

 // --- Collaboration Elements ---
 const collaborationStatus = document.getElementById('collaboration-status');
 const connectionIndicator = document.getElementById('connection-indicator');
 const connectionText = document.getElementById('connection-text');
 const roomInfo = document.getElementById('room-info');
 const activeUsers = document.getElementById('active-users');
 const userCount = document.getElementById('user-count');
 const createRoomBtn = document.getElementById('create-room-btn');
 const joinRoomBtn = document.getElementById('join-room-btn');
 const leaveRoomBtn = document.getElementById('leave-room-btn');
const hostBroadcastToggleBtn = document.getElementById('host-broadcast-toggle');
const hostBroadcastIndicator = document.getElementById('host-broadcast-indicator');
const hostBroadcastLabel = document.getElementById('host-broadcast-label');
const hostBroadcastIcon = document.getElementById('host-broadcast-icon');
const createRoomModal = document.getElementById('create-room-modal');
const joinRoomModal = document.getElementById('join-room-modal');
const userCursors = document.getElementById('user-cursors');

if (hostBroadcastToggleBtn) {
    hostBroadcastToggleBtn.addEventListener('click', handleHostBroadcastToggle);
}



 // --- Resizable AI Panel Elements ---
 const aiChatSidebar = document.getElementById('ai-chat-sidebar');
 const resizeHandle = document.getElementById('resize-handle');
 const toggleChatSidebarBtn = document.getElementById('toggle-chat-sidebar-btn');
 const floatingAiBtn = document.getElementById('floating-ai-btn');

 // --- Initial State & Variables ---
    let pendingImageForChat = null;
    let pendingImageMetadata = null;
 let chatHistoryStorage = []; // Persistent chat history for context
 let lastAiRequestAt = 0; // Simple throttle for AI calls
 const receivedBroadcastAiMessageIds = new Set();
 let currentTool = 'pen';
 let isDrawingHighlight = false;
 let isAddingText = false;
 let startPoint = null;
 let currentHighlightShape = null;
 let isDrawingShape = false;
 let currentDrawingShape = null;
 let isEditingLine = false;
 let lineControlPoints = [];
 let selectedLineForEditing = null;
 let controlPointCircles = [];
 let skipNextObjectAdded = false;
 let currentZoom = 1;
 let magnifierActive = false;

 // Copy/Paste functionality
 let copiedObjects = [];
 let pasteOffset = 20; // Offset for pasted objects
 const magnifierZoomLevel = 3;

 // --- Image Support Variables ---
 let pastedImageCounter = 0;
 let lastMousePosition = { x: 0, y: 0 };

 // --- Undo/Redo System Variables ---
 let commandHistory = null; // Will be initialized after CommandHistory class definition
 let isExecutingCommand = false; // Flag to prevent recursive command execution
 let objectStatesBeforeModification = new Map(); // Store object states before modification
 let undoRedoEnabled = true; // Flag to enable/disable undo/redo system

// --- Collaboration Variables ---
let collaborationSocket = null;
let collaborationSocketCandidates = [];
let collaborationSocketCandidateIndex = 0;
let currentUserId = null;
let currentRoomId = null;
let currentRoomHostId = null; // Track the host of the current room
 let hostBroadcastState = {
     enabled: false,
     hostId: null,
     pdf: null
 };
 let isApplyingBroadcastedChat = false;
 let isApplyingBroadcastedPdf = false;
 let isConnected = false;
 let roomUsers = new Map();

 // --- CLIENT-SIDE HOST OVERRIDE SYSTEM ---
 let clientSideHostOverride = null; // If set, this user is treated as host regardless of server
 let roomCreatorId = null; // Track who created the room
 let hostOverrideActive = false; // Flag to indicate override is active

 // --- MESSAGE INTERCEPTION SYSTEM ---
 let originalOnMessage = null; // Store original onmessage handler
 let messageInterceptionActive = false; // Flag to indicate message interception is active
 let isReceivingRemoteEvent = false; // Legacy flag - kept for compatibility
let isAutoRejoining = false; // Flag to track auto-rejoin process
let wasKicked = false; // Flag to track if user was kicked (prevents auto-rejoin)
let recentlyKickedUsers = new Set(); // Track recently kicked users to prevent "left room" messages

 // --- Group Messaging Variables ---
 let groupMessageSocket = null;
 let currentGroupRoomId = null;
 let currentDisplayName = null;
 let isGroupConnected = false;
 let activeTab = 'ai-chat'; // 'ai-chat', 'group-message', 'pdf-viewer', 'jupyter'

 // --- Notification System Variables ---
 let notificationsEnabled = true;
 let unreadMessageCount = 0;
 let lastSeenMessageTime = 0; // Timestamp of when user last viewed group messages
 let notificationContainer = null;
 let messageCounterBadge = null;
 let muteNotificationsBtn = null;
 let groupMessagesHeader = null;

 // --- Video Call Variables ---
 let jitsiAPI = null;
 let isVideoCallActive = false;
 let videoCallParticipants = new Map();
 let isVideoCallMinimized = false;
 let videoCallRoomName = null;
 let isModerator = false;

 // --- WebRTC Variables ---
 let localStream = null;
 let peerConnections = new Map(); // userId -> RTCPeerConnection
 let remoteStreams = new Map(); // userId -> MediaStream
 let iceCandidatesQueue = new Map(); // userId -> [candidates]

 // --- Session Management Variables ---
 let currentPdfData = null; // Store current PDF data
 let currentPdfName = null; // Store current PDF name

 // --- Tab Elements ---
 const aiChatTab = document.getElementById('ai-chat-tab');
 const groupMessageTab = document.getElementById('group-message-tab');
 const pdfViewerTab = document.getElementById('pdf-viewer-tab');
const jupyterTab = document.getElementById('jupyter-tab');
 const aiChatContent = document.getElementById('ai-chat-content');
 const groupMessageContent = document.getElementById('group-message-content');
 const pdfViewerContent = document.getElementById('pdf-viewer-content');
const jupyterContent = document.getElementById('jupyter-content');
const jupyterStatus = document.getElementById('jupyter-status');
const addCellBtn = document.getElementById('add-cell-btn');
const runAllBtn = document.getElementById('run-all-btn');
const clearAllBtn = document.getElementById('clear-all-btn');
const cellsContainer = document.getElementById('cells-container');

 // --- Group Messaging Elements ---
 const groupNotConnected = document.getElementById('group-not-connected');
 const groupConnected = document.getElementById('group-connected');
 const groupCurrentRoomId = document.getElementById('group-current-room-id');
 const groupCurrentUserName = document.getElementById('group-current-user-name');
 const groupConnectionIndicator = document.getElementById('group-connection-indicator');
 const groupMessages = document.getElementById('group-messages');
 const groupMessagesPlaceholder = document.getElementById('group-messages-placeholder');
 const groupMessageInput = document.getElementById('group-message-input');
 const groupSendButton = document.getElementById('group-send-button');
 const fileUploadInput = document.getElementById('file-upload-input');
 const fileUploadButton = document.getElementById('file-upload-button');

 // --- Notification System Elements ---
 notificationContainer = document.getElementById('notification-container');
 messageCounterBadge = document.getElementById('message-counter-badge');
 muteNotificationsBtn = document.getElementById('mute-notifications-btn');
 groupMessagesHeader = document.getElementById('group-messages-header');

 // --- PDF Viewer Variables ---
 let currentPdfDoc = null;
 let currentPdfPage = 1;
 let totalPdfPages = 0;
 let pdfZoomLevel = 1.0;
 let pdfPages = []; // Array to store rendered pages
 let pdfContainer = null;
 let isPdfPanning = false;
 let panStart = { x: 0, y: 0 };
 let scrollStart = { x: 0, y: 0 };
 let pageElements = []; // Array to store page DOM elements
 let pageObserver = null; // Intersection observer for current page tracking
 let renderTimeout = null; // For throttling re-renders
 let isRendering = false; // Prevent concurrent renders

 // --- PDF Viewer Elements ---
 const pdfFileInput = document.getElementById('pdf-file-input');
 const pdfUploadButton = document.getElementById('pdf-upload-button');
 const pdfNotLoaded = document.getElementById('pdf-not-loaded');
 const pdfLoaded = document.getElementById('pdf-loaded');
 const pdfFilename = document.getElementById('pdf-filename');
 const pdfInfo = document.getElementById('pdf-info');
 const pdfCloseButton = document.getElementById('pdf-close-button');
 const pdfControls = document.getElementById('pdf-controls');
 const pdfPrevPage = document.getElementById('pdf-prev-page');
 const pdfNextPage = document.getElementById('pdf-next-page');
 const pdfPageInput = document.getElementById('pdf-page-input');
 const pdfTotalPages = document.getElementById('pdf-total-pages');
 const pdfZoomOut = document.getElementById('pdf-zoom-out');
 const pdfZoomIn = document.getElementById('pdf-zoom-in');
 const pdfZoomLevelDisplay = document.getElementById('pdf-zoom-level');
 const pdfFitWidth = document.getElementById('pdf-fit-width');
 const pdfViewerArea = document.getElementById('pdf-viewer-area');
 const pdfLoading = document.getElementById('pdf-loading');
const pdfContainerElement = document.getElementById('pdf-container');











 // --- Dark Mode Persistence ---
 // Default to light theme with white background on first visit
 if (localStorage.getItem('darkMode') === 'true') {
 document.documentElement.classList.add('dark');
 } else {
 document.documentElement.classList.remove('dark');
 // Set default to light theme if no preference stored
 if (!('darkMode' in localStorage)) {
 localStorage.setItem('darkMode', 'false');
 }
 }

 // Check if user has saved canvas pattern settings
 const savedPattern = localStorage.getItem('canvasPatternSettings');
 if (savedPattern) {
 // Set transparent background for patterns - will be restored later
 fabricCanvas.backgroundColor = 'transparent';
 fabricCanvas.setBackgroundColor('transparent');
 console.log('üé® Transparent background set - pattern will be restored');
 } else {
 // Set default white background for new users
 fabricCanvas.backgroundColor = '#ffffff';
 fabricCanvas.setBackgroundColor('#ffffff');
 console.log('üé® Default white background set for new user');
 }
 fabricCanvas.renderAll();


 // --- Toolbar Collapse ---
 let isToolbarContentCollapsed = localStorage.getItem('toolbarCollapsed') === 'true';
 function updateToolbarView() {
 if (isToolbarContentCollapsed) {
 toolbarContent.style.maxHeight = '0px';
 toolbarContent.style.overflow = 'hidden';
 toolbarContent.style.paddingTop = '0px';
 toolbarContent.style.paddingBottom = '0px';
 toolbarContent.style.borderTop = 'none';
 toolbarChevronIcon.style.transform = 'rotate(180deg)';
 } else {
 // Set the target height to 110px and proper overflow
 toolbarContent.style.maxHeight = '110px';
 toolbarContent.style.overflowX = 'scroll';
 toolbarContent.style.overflowY = 'hidden';
 toolbarContent.style.paddingTop = '';
 toolbarContent.style.paddingBottom = '';
 toolbarContent.style.borderTop = '';
 toolbarChevronIcon.style.transform = 'rotate(0deg)';
 }
 }
 // Initial call, after a small delay to allow scrollHeight to be calculated correctly
 setTimeout(updateToolbarView, 100);


 toggleToolbarContentBtn.addEventListener('click', () => {
 isToolbarContentCollapsed = !isToolbarContentCollapsed;
 localStorage.setItem('toolbarCollapsed', isToolbarContentCollapsed);
 updateToolbarView();
 // Recalculate canvas offset if needed, though Fabric usually handles this well with relative positioning
 setTimeout(() => fabricCanvas.calcOffset(), 350); // after animation
 });
 // Adjust max-height on resize if toolbar is open
 window.addEventListener('resize', () => {
 if (!isToolbarContentCollapsed) {
 toolbarContent.style.maxHeight = '110px';
 toolbarContent.style.overflowX = 'scroll';
 toolbarContent.style.overflowY = 'hidden';
 }
 });

 // --- Tab Functionality ---
 function switchTab(tabName) {
 // Store previous tab for counter logic
 const previousTab = activeTab;
 console.log('üîÑ Switching from', previousTab, 'to', tabName);

 // Update tab buttons
 aiChatTab.classList.remove('active');
 groupMessageTab.classList.remove('active');
 pdfViewerTab.classList.remove('active');
 jupyterTab.classList.remove('active');
 aiChatTab.classList.add('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 aiChatTab.classList.remove('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 groupMessageTab.classList.add('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 groupMessageTab.classList.remove('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 pdfViewerTab.classList.add('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 pdfViewerTab.classList.remove('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 jupyterTab.classList.add('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 jupyterTab.classList.remove('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');

 // Update content visibility
 aiChatContent.classList.add('hidden');
 groupMessageContent.classList.add('hidden');
 pdfViewerContent.classList.add('hidden');
 jupyterContent.classList.add('hidden');

 if (tabName === 'ai-chat') {
 aiChatTab.classList.add('active');
 aiChatTab.classList.remove('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 aiChatTab.classList.add('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 aiChatContent.classList.remove('hidden');
 activeTab = 'ai-chat';
 } else if (tabName === 'group-message') {
 groupMessageTab.classList.add('active');
 groupMessageTab.classList.remove('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 groupMessageTab.classList.add('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 groupMessageContent.classList.remove('hidden');
 activeTab = 'group-message';

 // Simple counter reset - set to 0 and hide immediately
 console.log('üîÑ Opening group messages - setting counter to 0');
 unreadMessageCount = 0;
 lastSeenMessageTime = Date.now();
 if (messageCounterBadge) {
 messageCounterBadge.classList.add('hidden');
 messageCounterBadge.textContent = '0';
 }
 console.log('‚úÖ Counter reset to 0 and hidden');

 // Show group messages header if connected
 if (isGroupConnected && groupMessagesHeader) {
 groupMessagesHeader.classList.remove('hidden');
 }

 // Update group messaging status when switching to the tab
 updateGroupRoomStatus();
 } else if (tabName === 'pdf-viewer') {
 pdfViewerTab.classList.add('active');
 pdfViewerTab.classList.remove('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 pdfViewerTab.classList.add('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 pdfViewerContent.classList.remove('hidden');
 activeTab = 'pdf-viewer';
 } else if (tabName === 'jupyter') {
 jupyterTab.classList.add('active');
 jupyterTab.classList.remove('text-slate-500', 'dark:text-slate-400', 'border-transparent');
 jupyterTab.classList.add('text-indigo-600', 'dark:text-indigo-400', 'border-indigo-600', 'dark:border-indigo-400');
 jupyterContent.classList.remove('hidden');
 activeTab = 'jupyter';

 // Setup CSV import functionality when Jupyter tab is first accessed
 if (typeof window.csvImportSetup === 'undefined') {
     console.log('Setting up CSV import for first time...');
     window.csvImportSetup = true;
     setTimeout(() => {
         console.log('Calling setupCSVImport...');
         setupCSVImport();
     }, 100);
 }
 }

 // Update message counter visibility after tab switch
 if (typeof updateMessageCounter === 'function') {
 updateMessageCounter();
 }
 }

 // Tab event listeners
aiChatTab.addEventListener('click', () => switchTab('ai-chat'));
groupMessageTab.addEventListener('click', () => switchTab('group-message'));
pdfViewerTab.addEventListener('click', () => switchTab('pdf-viewer'));
jupyterTab.addEventListener('click', () => switchTab('jupyter'));

// Simple approach - counter resets when switching to group message tab (handled above)

// --- Jupyter Notebook Functions ---
let pyodide = null;
let pyodideReady = false;
let cellCounter = 0;
let cells = [];

// --- CSV Import Variables ---
let importedDatasets = new Map(); // filename -> {data, info}
let datasetCounter = 0;

async function initializePyodide() {
    try {
        jupyterStatus.textContent = 'Loading Python...';
        pyodide = await loadPyodide({
            indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
        });

        // Load essential packages first
        jupyterStatus.textContent = 'Loading core libraries...';
        await pyodide.loadPackage(['numpy', 'matplotlib', 'pandas']);

        // Configure matplotlib for inline plotting
        await pyodide.runPythonAsync(`
            import matplotlib
            matplotlib.use('Agg')  # Use non-interactive backend
            import matplotlib.pyplot as plt
            import numpy as np
            import pandas as pd
            import io
            import base64

            # Configure matplotlib for better plots
            plt.rcParams['figure.figsize'] = (10, 6)
            plt.rcParams['figure.dpi'] = 100
            plt.rcParams['savefig.dpi'] = 100
            plt.rcParams['font.size'] = 12

            def capture_plot():
                """Convert current matplotlib figure to base64 image"""
                if plt.get_fignums():
                    buf = io.BytesIO()
                    plt.savefig(buf, format='png', bbox_inches='tight', dpi=100)
                    buf.seek(0)
                    img_base64 = base64.b64encode(buf.read()).decode('utf-8')
                    plt.close('all')  # Close all figures
                    return f"data:image/png;base64,{img_base64}"
                return None

            # Keep track of plots generated
            _plots = []

            # Override plt.show to capture plots
            _original_show = plt.show
            def custom_show(*args, **kwargs):
                global _plots
                plot_data = capture_plot()
                if plot_data:
                    _plots.append(plot_data)
                return plot_data
            plt.show = custom_show

            # Helper functions for working with datasets
            def list_datasets():
                """List all available datasets in the environment"""
                import pandas as pd
                datasets = []
                for name, obj in globals().items():
                    if isinstance(obj, pd.DataFrame) and not name.startswith('_'):
                        datasets.append({
                            'name': name,
                            'shape': obj.shape,
                            'columns': list(obj.columns),
                            'memory_mb': round(obj.memory_usage(deep=True).sum() / (1024*1024), 2)
                        })

                if not datasets:
                    print("No datasets found. Import CSV files using the 'Import CSV' button.")
                    return

                print("Available datasets:")
                print("-" * 50)
                for ds in datasets:
                    print(f"üìä {ds['name']}")
                    print(f"   Shape: {ds['shape'][0]} rows √ó {ds['shape'][1]} columns")
                    print(f"   Memory: {ds['memory_mb']} MB")
                    print(f"   Columns: {', '.join(ds['columns'][:5])}")
                    if len(ds['columns']) > 5:
                        print(f"            ... and {len(ds['columns']) - 5} more")
                    print()

            def quick_explore(df_name):
                """Quick exploration of a dataset"""
                if df_name not in globals():
                    print(f"Dataset '{df_name}' not found. Use list_datasets() to see available datasets.")
                    return

                df = globals()[df_name]
                print(f"=== Quick Exploration: {df_name} ===")
                print(f"Shape: {df.shape}")
                print(f"\\nColumns and types:")
                for col, dtype in df.dtypes.items():
                    print(f"  {col}: {dtype}")

                print(f"\\nFirst 3 rows:")
                print(df.head(3))

                print(f"\\nBasic statistics:")
                print(df.describe())

                missing = df.isnull().sum()
                if missing.sum() > 0:
                    print(f"\\nMissing values:")
                    print(missing[missing > 0])
                else:
                    print(f"\\nNo missing values found!")

            print("Core libraries loaded successfully!")
            print("Available: numpy, pandas, matplotlib")
            print("\\nHelper functions:")
            print("  list_datasets() - Show all imported datasets")
            print("  quick_explore('dataset_name') - Quick dataset exploration")
        `);

        // Load additional packages in background
        setTimeout(async () => {
            try {
                jupyterStatus.textContent = 'Loading additional libraries...';
                await pyodide.loadPackage(['scipy', 'scikit-learn']);
                await pyodide.runPythonAsync(`
                    import scipy
                    try:
                        import sklearn
                        print("Additional libraries loaded: scipy, scikit-learn")
                        print("Ready for machine learning workflows!")
                    except ImportError:
                        print("Additional libraries loaded: scipy")
                `);
            } catch (error) {
                console.log('Some additional libraries failed to load:', error);
            }
        }, 1000);

        pyodideReady = true;
        jupyterStatus.textContent = 'Ready';
        jupyterStatus.classList.remove('text-slate-500', 'dark:text-slate-400');
        jupyterStatus.classList.add('text-green-600', 'dark:text-green-400');

    } catch (error) {
        jupyterStatus.textContent = 'Error';
        jupyterStatus.classList.remove('text-slate-500', 'dark:text-slate-400');
        jupyterStatus.classList.add('text-red-600', 'dark:text-red-400');
        console.error('Failed to load Pyodide:', error);
    }
}

// --- CSV Import Functions ---
window.setupCSVImport = function setupCSVImport() {
    console.log('Setting up CSV import functionality...');

    const csvFileInput = document.getElementById('csv-file-input');
    const importCsvBtn = document.getElementById('import-csv-btn');
    const showDatasetsBtn = document.getElementById('show-datasets-btn');
    const datasetModal = document.getElementById('dataset-modal');
    const closeDatasetModal = document.getElementById('close-dataset-modal');
    const closeDatasetModalBtn = document.getElementById('close-dataset-modal-btn');
    const importCsvFromModal = document.getElementById('import-csv-from-modal');

    // Debug: Check if elements exist
    console.log('CSV elements found:', {
        csvFileInput: !!csvFileInput,
        importCsvBtn: !!importCsvBtn,
        showDatasetsBtn: !!showDatasetsBtn,
        datasetModal: !!datasetModal
    });

    // Import CSV button click
    if (importCsvBtn && csvFileInput) {
        importCsvBtn.addEventListener('click', () => {
            console.log('Import CSV button clicked');
            csvFileInput.click();
        });
    } else {
        console.error('Import CSV button or file input not found');
    }

    // Import from modal button click
    if (importCsvFromModal && csvFileInput) {
        importCsvFromModal.addEventListener('click', () => {
            console.log('Import CSV from modal clicked');
            csvFileInput.click();
        });
    }

    // Show datasets button click
    if (showDatasetsBtn && datasetModal) {
        showDatasetsBtn.addEventListener('click', () => {
            console.log('Show datasets button clicked');
            updateDatasetList();
            datasetModal.classList.remove('hidden');
        });
    } else {
        console.error('Show datasets button or modal not found');
    }

    // Close modal events
    if (closeDatasetModal && datasetModal) {
        closeDatasetModal.addEventListener('click', () => {
            datasetModal.classList.add('hidden');
        });
    }

    if (closeDatasetModalBtn && datasetModal) {
        closeDatasetModalBtn.addEventListener('click', () => {
            datasetModal.classList.add('hidden');
        });
    }

    // Click outside modal to close
    if (datasetModal) {
        datasetModal.addEventListener('click', (e) => {
            if (e.target === datasetModal) {
                datasetModal.classList.add('hidden');
            }
        });
    }

    // File input change event
    if (csvFileInput) {
        csvFileInput.addEventListener('change', async (e) => {
            console.log('File input changed, files selected:', e.target.files.length);
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            for (const file of files) {
                console.log('Importing file:', file.name);
                await importCSVFile(file);
            }

            // Clear the input so the same file can be selected again
            csvFileInput.value = '';

            // Update dataset list if modal is open
            if (datasetModal && !datasetModal.classList.contains('hidden')) {
                updateDatasetList();
            }

            // Update button text to show count
            updateDatasetButton();
        });
    } else {
        console.error('CSV file input not found');
    }

    console.log('CSV import setup complete');
}

window.importCSVFile = async function importCSVFile(file) {
    if (!pyodideReady) {
        alert('Python environment not ready. Please wait...');
        return;
    }

    try {
        // Read file content
        const text = await file.text();
        const filename = file.name.replace(/\.csv$/i, '');

        // Create a safe variable name
        const varName = createSafeVariableName(filename);

        // Escape filename for Python string
        const escapedFilename = filename.replace(/\\/g, '\\\\').replace(/"/g, '\\"');

        // Import the CSV data into Python - use a safer approach
        // First, store the CSV data in pyodide's file system
        pyodide.FS.writeFile('/tmp/temp.csv', new TextEncoder().encode(text));

        await pyodide.runPythonAsync(`
import pandas as pd

# Read CSV data from file system (safer than string interpolation)
${varName} = pd.read_csv('/tmp/temp.csv')

# Store dataset info
dataset_info = {
    'name': "${escapedFilename}",
    'variable': "${varName}",
    'shape': ${varName}.shape,
    'columns': list(${varName}.columns),
    'dtypes': ${varName}.dtypes.to_dict(),
    'memory_usage': ${varName}.memory_usage(deep=True).sum()
}

print(f"Successfully imported '${escapedFilename}' as variable '${varName}'")
print(f"Shape: {${varName}.shape}")
print(f"Columns: {list(${varName}.columns)}")
        `);

        // Get dataset info from Python
        const datasetInfo = await pyodide.runPythonAsync(`dataset_info`);

        // Store in our datasets map
        importedDatasets.set(varName, {
            filename: filename,
            variable: varName,
            info: datasetInfo.toJs({dict_converter: Object.fromEntries})
        });

        // Show success message with details
        const info = datasetInfo.toJs({dict_converter: Object.fromEntries});
        addSystemMessage(`‚úÖ Successfully imported "${filename}" as variable "${varName}" (${info.shape[0]} rows √ó ${info.shape[1]} columns)`);

        // Update button count
        updateDatasetButton();

        // Add a helpful cell if this is the first dataset
        if (importedDatasets.size === 1) {
            addDataExplorationCell(varName);
        }

    } catch (error) {
        console.error('Error importing CSV:', error);
        let errorMsg = error.message;

        // Provide more helpful error messages
        if (errorMsg.includes('ParserError')) {
            errorMsg = 'CSV parsing error. Please check file format and ensure proper comma separation.';
        } else if (errorMsg.includes('UnicodeDecodeError')) {
            errorMsg = 'File encoding error. Please ensure the CSV file is saved with UTF-8 encoding.';
        } else if (errorMsg.includes('EmptyDataError')) {
            errorMsg = 'The CSV file appears to be empty or has no valid data.';
        }

        addSystemMessage(`‚ùå Error importing "${file.name}": ${errorMsg}`, 'error');
    }
}

function createSafeVariableName(filename) {
    // Remove file extension and create a safe Python variable name
    let varName = filename
        .replace(/[^a-zA-Z0-9_]/g, '_')  // Replace non-alphanumeric with underscore
        .replace(/^[0-9]/, 'data_$&')    // Prefix with 'data_' if starts with number
        .replace(/_+/g, '_')             // Replace multiple underscores with single
        .replace(/^_|_$/g, '');          // Remove leading/trailing underscores

    // Ensure it's not empty
    if (!varName) {
        varName = `dataset_${datasetCounter++}`;
    }

    // Ensure uniqueness
    let originalVarName = varName;
    let counter = 1;
    while (importedDatasets.has(varName)) {
        varName = `${originalVarName}_${counter++}`;
    }

    return varName;
}

window.updateDatasetList = function updateDatasetList() {
    const datasetList = document.getElementById('dataset-list');

    if (importedDatasets.size === 0) {
        datasetList.innerHTML = `
            <div class="text-center text-slate-500 dark:text-slate-400 py-8">
                <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                </svg>
                <p>No datasets imported yet</p>
                <p class="text-xs mt-1">Click "Import CSV" to add datasets</p>
            </div>
        `;
        return;
    }

    let html = '';
    for (const [varName, dataset] of importedDatasets) {
        const info = dataset.info;
        const sizeInMB = (info.memory_usage / (1024 * 1024)).toFixed(2);

        html += `
            <div class="bg-slate-50 dark:bg-slate-700 rounded-lg p-4 border border-slate-200 dark:border-slate-600">
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <h4 class="font-medium text-slate-900 dark:text-slate-100">${dataset.filename}</h4>
                        <p class="text-sm text-slate-600 dark:text-slate-400 mt-1">Variable: <code class="bg-slate-200 dark:bg-slate-600 px-1 rounded">${varName}</code></p>
                        <div class="mt-2 text-xs text-slate-500 dark:text-slate-400">
                            <p>Shape: ${info.shape[0]} rows √ó ${info.shape[1]} columns</p>
                            <p>Memory: ${sizeInMB} MB</p>
                        </div>
                        <div class="mt-2">
                            <p class="text-xs font-medium text-slate-600 dark:text-slate-400 mb-1">Columns:</p>
                            <div class="flex flex-wrap gap-1">
                                ${info.columns.slice(0, 5).map(col =>
                                    `<span class="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded">${col}</span>`
                                ).join('')}
                                ${info.columns.length > 5 ? `<span class="text-xs text-slate-500">+${info.columns.length - 5} more</span>` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="flex flex-col space-y-1 ml-4">
                        <button onclick="insertDatasetCode('${varName}')" class="px-2 py-1 text-xs bg-green-500 hover:bg-green-600 text-white rounded transition-colors">
                            Explore
                        </button>
                        <button onclick="insertMLCode('${varName}')" class="px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded transition-colors">
                            ML Template
                        </button>
                        <button onclick="removeDataset('${varName}')" class="px-2 py-1 text-xs bg-red-500 hover:bg-red-600 text-white rounded transition-colors">
                            Remove
                        </button>
                    </div>
                </div>
            </div>
        `;
    }

    datasetList.innerHTML = html;
}

window.insertDatasetCode = function insertDatasetCode(varName) {
    const dataset = importedDatasets.get(varName);
    if (!dataset) return;

    const code = `# Explore ${dataset.filename} dataset
print(f"Dataset: ${dataset.filename}")
print(f"Shape: {${varName}.shape}")
print("\\nFirst 5 rows:")
print(${varName}.head())
print("\\nDataset info:")
print(${varName}.info())
print("\\nBasic statistics:")
print(${varName}.describe())`;

    const newCell = createCell(code);
    const cellsContainer = document.getElementById('cells-container');
    if (cellsContainer) {
        cellsContainer.appendChild(newCell);
        newCell.querySelector('.code-input').focus();
    } else {
        console.error('cells-container not found');
    }

    // Close modal
    document.getElementById('dataset-modal').classList.add('hidden');
}

window.insertMLCode = function insertMLCode(varName) {
    const dataset = importedDatasets.get(varName);
    if (!dataset) return;

    const info = dataset.info;
    const numericColumns = Object.entries(info.dtypes)
        .filter(([col, dtype]) => dtype.includes('int') || dtype.includes('float'))
        .map(([col, dtype]) => col);

    const code = `# Machine Learning Template for ${dataset.filename}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, mean_squared_error, r2_score

# Dataset: ${varName}
print(f"Working with dataset: ${dataset.filename}")
print(f"Shape: {${varName}.shape}")
print("\\nColumns:", ${varName}.columns.tolist())

# 1. Data Overview
print("\\n=== DATA OVERVIEW ===")
print(${varName}.info())
print("\\nMissing values:")
print(${varName}.isnull().sum())

# 2. Basic Statistics
print("\\n=== BASIC STATISTICS ===")
print(${varName}.describe())

# 3. Data Visualization
print("\\n=== DATA VISUALIZATION ===")
# Numeric columns: ${numericColumns.slice(0, 3).join(', ')}${numericColumns.length > 3 ? ' ...' : ''}

# Plot distributions of numeric columns
numeric_cols = ${varName}.select_dtypes(include=[np.number]).columns
if len(numeric_cols) > 0:
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    axes = axes.ravel()

    for i, col in enumerate(numeric_cols[:4]):
        ${varName}[col].hist(bins=20, ax=axes[i])
        axes[i].set_title(f'Distribution of {col}')
        axes[i].set_xlabel(col)
        axes[i].set_ylabel('Frequency')

    plt.tight_layout()
    plt.show()

# 4. Correlation Matrix (for numeric data)
if len(numeric_cols) > 1:
    correlation_matrix = ${varName}[numeric_cols].corr()
    plt.figure(figsize=(10, 8))
    plt.imshow(correlation_matrix, cmap='coolwarm', aspect='auto')
    plt.colorbar()
    plt.title('Correlation Matrix')
    plt.xticks(range(len(numeric_cols)), numeric_cols, rotation=45)
    plt.yticks(range(len(numeric_cols)), numeric_cols)
    plt.tight_layout()
    plt.show()

# 5. Machine Learning Template
print("\\n=== MACHINE LEARNING TEMPLATE ===")
print("# Uncomment and modify the following code for your specific use case:")
print()

# Example for Classification/Regression
# Choose your features and target
# X = ${varName}[['feature1', 'feature2', 'feature3']]  # Select feature columns
# y = ${varName}['target_column']  # Select target column

# Handle categorical variables if needed
# le = LabelEncoder()
# y_encoded = le.fit_transform(y)  # For classification with string labels

# Split the data
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale features if needed
# scaler = StandardScaler()
# X_train_scaled = scaler.fit_transform(X_train)
# X_test_scaled = scaler.transform(X_test)

# For Regression:
# model = RandomForestRegressor(n_estimators=100, random_state=42)
# model.fit(X_train_scaled, y_train)
# predictions = model.predict(X_test_scaled)
# print(f"R¬≤ Score: {r2_score(y_test, predictions):.4f}")
# print(f"RMSE: {np.sqrt(mean_squared_error(y_test, predictions)):.4f}")

# For Classification:
# model = RandomForestClassifier(n_estimators=100, random_state=42)
# model.fit(X_train_scaled, y_train)
# predictions = model.predict(X_test_scaled)
# print(f"Accuracy: {accuracy_score(y_test, predictions):.4f}")
# print("\\nClassification Report:")
# print(classification_report(y_test, predictions))

print("\\n‚úÖ Template ready! Uncomment and modify the code above for your specific ML task.")
`;

    const newCell = createCell(code);
    const cellsContainer = document.getElementById('cells-container');
    if (cellsContainer) {
        cellsContainer.appendChild(newCell);
        newCell.querySelector('.code-input').focus();
    } else {
        console.error('cells-container not found');
    }

    // Close modal
    document.getElementById('dataset-modal').classList.add('hidden');
}

window.removeDataset = function removeDataset(varName) {
    if (confirm(`Remove dataset "${varName}"? This will delete the variable from Python.`)) {
        // Remove from Python
        if (pyodideReady) {
            pyodide.runPythonAsync(`
try:
    del ${varName}
    print(f"Removed dataset variable '{varName}'")
except NameError:
    pass
            `);
        }

        // Remove from our map
        importedDatasets.delete(varName);

        // Update the list and button
        updateDatasetList();
        updateDatasetButton();

        addSystemMessage(`üóëÔ∏è Removed dataset "${varName}"`);
    }
}

function addDataExplorationCell(varName) {
    const dataset = importedDatasets.get(varName);
    if (!dataset) return;

    const code = `# Quick exploration of ${dataset.filename}
print("=== Dataset Overview ===")
print(f"Dataset: ${dataset.filename}")
print(f"Variable name: ${varName}")
print(f"Shape: {${varName}.shape}")
print(f"Columns: {list(${varName}.columns)}")

print("\\n=== First 5 rows ===")
print(${varName}.head())

print("\\n=== Data types ===")
print(${varName}.dtypes)

print("\\n=== Basic statistics ===")
print(${varName}.describe())

# Check for missing values
print("\\n=== Missing values ===")
missing = ${varName}.isnull().sum()
print(missing[missing > 0])`;

    const newCell = createCell(code);
    const cellsContainer = document.getElementById('cells-container');
    if (cellsContainer) {
        cellsContainer.appendChild(newCell);
    } else {
        console.error('cells-container not found');
    }
}

function updateDatasetButton() {
    const showDatasetsBtn = document.getElementById('show-datasets-btn');
    const count = importedDatasets.size;

    if (count === 0) {
        showDatasetsBtn.textContent = 'Datasets';
    } else {
        showDatasetsBtn.textContent = `Datasets (${count})`;
    }
}

function addSystemMessage(message, type = 'info') {
    // Add a message to indicate successful import
    const messageDiv = document.createElement('div');
    messageDiv.className = `text-xs p-2 rounded mb-2 ${
        type === 'error'
            ? 'bg-red-100 dark:bg-red-900/20 text-red-700 dark:text-red-300'
            : 'bg-green-100 dark:bg-green-900/20 text-green-700 dark:text-green-300'
    }`;
    messageDiv.textContent = message;

    const cellsContainer = document.getElementById('cells-container');
    cellsContainer.appendChild(messageDiv);

    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.remove();
        }
    }, 5000);
}

function createCell(code = '') {
    const cellId = `cell-${cellCounter++}`;
    const cell = document.createElement('div');
    cell.className = 'cell bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden';
    cell.id = cellId;

    cell.innerHTML = `
        <div class="cell-header">
            <div class="flex items-center space-x-2">
                <span class="text-sm font-medium text-slate-600 dark:text-slate-400">In [${cellCounter}]:</span>
            </div>
            <div class="cell-action-buttons">
                <button class="run-cell-btn">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Run
                </button>
                <button class="delete-cell-btn">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                    </svg>
                    Delete
                </button>
            </div>
        </div>
        <div class="cell-body">
            <div class="code-input-container">
                <textarea class="code-input w-full p-3 bg-slate-50 dark:bg-slate-900 border-none outline-none font-mono text-sm resize-none overflow-x-auto"
                          placeholder="Enter Python code here..."
                          rows="3"
                          style="white-space: pre; word-wrap: normal;">${code}</textarea>
            </div>
            <div class="cell-output hidden">
                <div class="output-header p-2 bg-slate-100 dark:bg-slate-800 border-t border-slate-200 dark:border-slate-600">
                    <span class="text-xs text-slate-500 dark:text-slate-400">Out [${cellCounter}]:</span>
                </div>
                <div class="output-content p-3 bg-white dark:bg-slate-900 font-mono text-sm"></div>
            </div>
        </div>
    `;

    // Add event listeners
    const runBtn = cell.querySelector('.run-cell-btn');
    const deleteBtn = cell.querySelector('.delete-cell-btn');
    const codeInput = cell.querySelector('.code-input');
    const cellOutput = cell.querySelector('.cell-output');
    const outputContent = cell.querySelector('.output-content');

    runBtn.addEventListener('click', async () => await runCell(cellId));
    deleteBtn.addEventListener('click', () => deleteCell(cellId));

    // Auto-resize textarea and auto-save
    codeInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.max(this.scrollHeight, 60) + 'px';

        // Auto-save when cell content changes (only when not in a room)
        const isInRoom = currentRoomId && isConnected;
        if (!isInRoom) {
            setTimeout(() => saveAppState(), 500); // Debounce typing
        }
    });

    // Shift+Enter to run
    codeInput.addEventListener('keydown', async function(e) {
        if (e.key === 'Enter' && e.shiftKey) {
            e.preventDefault();
            await runCell(cellId);
        }
    });

    cells.push({
        id: cellId,
        element: cell,
        codeInput: codeInput,
        output: cellOutput,
        outputContent: outputContent
    });

    return cell;
}

async function runCell(cellId) {
    if (!pyodideReady) {
        alert('Python environment not ready. Please wait...');
        return;
    }

    const cell = cells.find(c => c.id === cellId);
    if (!cell) return;

    const code = cell.codeInput.value.trim();
    if (!code) return;

    // Show output area
    cell.output.classList.remove('hidden');

    // Clear previous output
    cell.outputContent.innerHTML = '<div class="text-slate-500 dark:text-slate-400 italic">Running...</div>';

    try {
        // Clear previous plots
        await pyodide.runPythonAsync(`
            _plots = []
        `);

        // Use a safer approach - write code to file and execute
        const codeBytes = new TextEncoder().encode(code);
        pyodide.FS.writeFile('/tmp/user_code.py', codeBytes);

        // Capture stdout and execute code
        const result = await pyodide.runPythonAsync(`
import sys
import io
from contextlib import redirect_stdout

# Capture stdout
captured_output = io.StringIO()
error_msg = None

with redirect_stdout(captured_output):
    try:
        # Execute the user code from file (safer than string interpolation)
        with open('/tmp/user_code.py', 'r') as f:
            user_code = f.read()
        exec(user_code, globals())
    except Exception as e:
        error_msg = str(e)
        print(f"Error: {e}")

# Get the captured output
output_text = captured_output.getvalue()

# Return results
{
    'output': output_text,
    'plots': _plots.copy(),
    'error': error_msg
}
        `);

        // Process the result
        const output = result.get('output');
        const plots = result.get('plots');
        const error = result.get('error');

        let displayHtml = '';

        // Add text output
        if (output && output.trim()) {
            displayHtml += `<pre class="whitespace-pre-wrap mb-4">${output}</pre>`;
        }

        // Add plots if available
        if (plots && plots.length > 0) {
            plots.forEach((plotData, index) => {
                displayHtml += `<div class="plot-container mb-4">
                    <img src="${plotData}" class="max-w-full h-auto border rounded" alt="Plot ${index + 1}">
                </div>`;
            });
        }

        // Display final result
        if (displayHtml) {
            cell.outputContent.innerHTML = displayHtml;
        } else if (error) {
            cell.outputContent.innerHTML = `<pre class="text-red-500">Error: ${error}</pre>`;
        } else {
            cell.outputContent.innerHTML = '<div class="text-slate-500 dark:text-slate-400 italic">No output</div>';
        }

    } catch (error) {
        cell.outputContent.innerHTML = `<pre class="text-red-500">Error: ${error.message}</pre>`;
    }

    // Auto-save after cell execution (only when not in a room)
    const isInRoom = currentRoomId && isConnected;
    if (!isInRoom) {
        setTimeout(() => saveAppState(), 100);
    }
}

function deleteCell(cellId) {
    const cellIndex = cells.findIndex(c => c.id === cellId);
    if (cellIndex === -1) return;

    const cell = cells[cellIndex];
    cell.element.remove();
    cells.splice(cellIndex, 1);
}

function initializeJupyterEnvironment() {
    // Add initial cell with simple example
    const initialCell = createCell(`# Welcome to Jupyter Notebook!
# Wait for status to show "Ready" then run this cell
# Press Shift+Enter to run cells

print("Hello, Jupyter Notebook!")
print("Python is ready!")

# Test basic math
result = 2 + 3
print(f"2 + 3 = {result}")

# Test numpy
import numpy as np
arr = np.array([1, 2, 3, 4, 5])
print(f"NumPy array: {arr}")
print(f"Array mean: {np.mean(arr)}")
`);
    cellsContainer.appendChild(initialCell);

    // Add a second cell with plotting
    const secondCell = createCell(`# Plotting example
import matplotlib.pyplot as plt
import numpy as np

# Create sample data
x = np.linspace(0, 10, 100)
y = np.sin(x)

print(f"Created {len(x)} data points")
print("Generating plot...")

# Create plot
plt.figure(figsize=(10, 6))
plt.plot(x, y, 'b-', linewidth=2, label='sin(x)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Sine Wave Example')
plt.grid(True)
plt.legend()
plt.show()

print("Plot should appear above!")
`);
    cellsContainer.appendChild(secondCell);

    // Add a third cell showing global variables
    const thirdCell = createCell(`# Global variables persist across cells
# The 'x' and 'y' variables from the previous cell are still available

print("Testing global variables...")
print(f"x variable has {len(x)} points")
print(f"y variable has {len(y)} points")
print(f"x ranges from {x.min():.2f} to {x.max():.2f}")

# Create another plot using the same data
plt.figure(figsize=(10, 6))
plt.plot(x, y**2, 'r-', linewidth=2, label='sin¬≤(x)')
plt.xlabel('x')
plt.ylabel('y¬≤')
plt.title('Squared Sine Wave')
plt.grid(True)
plt.legend()
plt.show()

print("Second plot generated!")
`);
    cellsContainer.appendChild(thirdCell);

    // Add a fourth cell showing CSV import capabilities
    const csvCell = createCell(`# CSV Import and Data Analysis
# Click "Import CSV" button above to import your CSV files
# Once imported, you can use them in your code

# List all available datasets
list_datasets()

# Example: If you import a CSV file, you can explore it like this:
# quick_explore('your_dataset_name')

# Example ML workflow with imported data:
# 1. Import your CSV using the "Import CSV" button
# 2. Explore the data:
#    print(your_data.head())
#    print(your_data.info())
#    print(your_data.describe())
#
# 3. Basic analysis:
#    import seaborn as sns  # Will be available after import
#    your_data.hist(figsize=(12, 8))
#    plt.show()
#
# 4. Machine Learning example:
#    from sklearn.model_selection import train_test_split
#    from sklearn.linear_model import LinearRegression
#
#    # Prepare your data
#    X = your_data[['feature1', 'feature2']]  # Select features
#    y = your_data['target']  # Select target
#
#    # Split data
#    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
#
#    # Train model
#    model = LinearRegression()
#    model.fit(X_train, y_train)
#
#    # Make predictions
#    predictions = model.predict(X_test)

print("Ready for CSV import and ML analysis!")
print("Click 'Import CSV' to get started with your data!")
`);
    cellsContainer.appendChild(csvCell);

    // Button event listeners
    addCellBtn.addEventListener('click', () => {
        const newCell = createCell();
        cellsContainer.appendChild(newCell);
        newCell.querySelector('.code-input').focus();
    });

    runAllBtn.addEventListener('click', async () => {
        for (const cell of cells) {
            if (cell.codeInput.value.trim()) {
                await runCell(cell.id);
            }
        }
    });

    clearAllBtn.addEventListener('click', () => {
        // Clear all cells - both input and output
        cells.forEach(cell => {
            // Clear the input (using correct property name)
            cell.codeInput.value = '';
            // Clear and hide the output
            cell.output.classList.add('hidden');
            cell.outputContent.innerHTML = '';
        });

        console.log('All cells cleared');
    });

    // Initialize Pyodide
    initializePyodide();

    // CSV import will be setup when Jupyter tab is first accessed
}

// Initialize Jupyter environment
initializeJupyterEnvironment();

 // Initialize with AI Chat tab active
 switchTab('ai-chat');

 // Initialize group messaging UI based on current collaboration state
 function initializeGroupMessagingUI() {
 updateGroupRoomStatus();
 }

 // --- Group Messaging Functions ---
 function connectToGroupMessaging() {
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 return;
 }

 try {
 // Determine WebSocket URL based on environment
 let wsUrl;
 const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
 wsUrl = `${protocol}//${window.location.host}/group-ws`;

 console.log('Connecting to Group Messaging WebSocket at:', wsUrl);
 groupMessageSocket = new WebSocket(wsUrl);

 groupMessageSocket.onopen = () => {
 console.log('Connected to group messaging server');
 isGroupConnected = true;

 // If we're already in a collaboration room, automatically join group messaging
 if (currentRoomId && currentUserId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 currentDisplayName = userName;

 // Register with group messaging server
 groupMessageSocket.send(JSON.stringify({
 type: 'register',
 display_name: userName
 }));

 // Join the same room as collaboration
 setTimeout(() => {
 groupMessageSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: currentRoomId
 }));
 }, 100);
 }

 updateGroupRoomStatus();
 };

 groupMessageSocket.onmessage = (event) => {
 try {
 const data = JSON.parse(event.data);

 handleGroupMessage(data);
 } catch (error) {
 console.error('Error parsing group message:', error);
 }
 };

 groupMessageSocket.onclose = () => {
 console.log('Disconnected from group messaging server');
 isGroupConnected = false;
 currentGroupRoomId = null;

 // Reset message counter when disconnected
 resetUnreadCount();

 updateGroupRoomStatus();
 // Attempt to reconnect after 3 seconds if we're still in a collaboration room
 if (currentRoomId) {
 setTimeout(connectToGroupMessaging, 3000);
 }
 };

 groupMessageSocket.onerror = (error) => {
 console.error('Group messaging WebSocket error:', error);
 };

 } catch (error) {
 console.error('Failed to connect to group messaging server:', error);
 }
 }

 // Function to automatically join group messaging when joining collaboration room
 function joinGroupMessagingRoom(roomId, userName) {
 if (!groupMessageSocket || groupMessageSocket.readyState !== WebSocket.OPEN) {
 // Connect first, then join
 connectToGroupMessaging();
 return;
 }

 currentDisplayName = userName;

 // Register with group messaging server
 groupMessageSocket.send(JSON.stringify({
 type: 'register',
 display_name: userName
 }));

 // Join the room
 setTimeout(() => {
 groupMessageSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: roomId
 }));
 }, 100);
 }

 // Function to leave group messaging when leaving collaboration room
 function leaveGroupMessagingRoom() {
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN && currentGroupRoomId) {
 groupMessageSocket.send(JSON.stringify({
 type: 'leave_room'
 }));
 }
 currentGroupRoomId = null;
 currentDisplayName = null;

 // Reset message counter when leaving room
 resetUnreadCount();

 updateGroupRoomStatus();
 }

 function handleGroupMessage(data) {
 switch (data.type) {
 case 'registered':
 console.log('Registered for group messaging:', data.user_id);
 break;

 case 'room_joined':
 if (data.success) {
 currentGroupRoomId = data.room_id;
 updateGroupRoomStatus();
 addGroupMessage({
 type: 'system',
 content: `Connected to room ${data.room_id}`,
 timestamp: new Date().toISOString()
 });
 }
 break;

 case 'room_left':
 if (data.success) {
 currentGroupRoomId = null;
 updateGroupRoomStatus();
 clearGroupMessages();
 addGroupMessage({
 type: 'system',
 content: 'Left the room',
 timestamp: new Date().toISOString()
 });
 }
 break;

 case 'message':
 addGroupMessage(data.data);
 break;

 case 'message_edited':
 handleMessageEdited(data);
 break;

 case 'message_deleted':
 handleMessageDeleted(data);
 break;

 case 'error':
 addGroupMessage({
 type: 'system',
 content: `Error: ${data.message}`,
 timestamp: new Date().toISOString()
 });
 break;
 }
 }

 function handleMessageEdited(data) {
 const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
 if (!messageElement) return;

 const messageContent = messageElement.querySelector('.message-content');
 if (!messageContent) return;

 // Update the message content
 messageContent.innerHTML = data.new_content;

 // Add edited indicator to the message container
 // Remove existing edited indicator if any
 const existingEdited = messageElement.querySelector('.edited-indicator');
 if (existingEdited) {
 existingEdited.remove();
 }

 // Add new edited indicator positioned in bottom right corner
 const editedIndicator = document.createElement('span');
 editedIndicator.className = 'edited-indicator';
 editedIndicator.textContent = 'edited';
 messageElement.appendChild(editedIndicator);


 }

 function handleMessageDeleted(data) {
 const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
 if (!messageElement) return;

 // Replace entire message content with deleted message indicator
 const messageHeader = messageElement.querySelector('.message-header');
 const messageContent = messageElement.querySelector('.message-content');

 if (messageHeader && messageContent) {
 // Update header to show deletion
 messageHeader.innerHTML = `
 <span class="message-sender text-slate-400 dark:text-slate-500">${data.sender_name} deleted this message</span>
 <span class="message-timestamp">${messageHeader.querySelector('.message-timestamp').textContent}</span>
 `;

 // Update content to show deletion message
 messageContent.innerHTML = '<em class="text-slate-400 dark:text-slate-500">This message was deleted</em>';
 }

 // Remove action buttons
 const actionsContainer = messageElement.querySelector('.message-actions');
 if (actionsContainer) {
 actionsContainer.remove();
 }

 // Add deleted class for styling
 messageElement.classList.add('deleted');


 }

 function updateGroupRoomStatus() {
 if (currentGroupRoomId && isGroupConnected) {
 groupNotConnected.classList.add('hidden');
 groupConnected.classList.remove('hidden');
 groupCurrentRoomId.textContent = `Room: ${currentGroupRoomId}`;
 groupCurrentUserName.textContent = `User: ${currentDisplayName}`;
 groupConnectionIndicator.className = 'w-2 h-2 rounded-full bg-green-500';
 groupMessageInput.disabled = false;
 groupSendButton.disabled = false;
 fileUploadButton.disabled = false;
 groupMessagesPlaceholder.classList.add('hidden');

 // Show group messages header when connected
 if (groupMessagesHeader) {
 groupMessagesHeader.classList.remove('hidden');
 }
 } else {
 groupNotConnected.classList.remove('hidden');
 groupConnected.classList.add('hidden');
 groupConnectionIndicator.className = 'w-2 h-2 rounded-full bg-red-500';
 groupMessageInput.disabled = true;
 groupSendButton.disabled = true;
 fileUploadButton.disabled = true;
 groupMessagesPlaceholder.classList.remove('hidden');

 // Hide group messages header when disconnected
 if (groupMessagesHeader) {
 groupMessagesHeader.classList.add('hidden');
 }
 }
 }

 function addGroupMessage(messageData) {
 const messageDiv = document.createElement('div');
 messageDiv.className = 'message-item';

 // Add unique message ID for navigation
 const messageId = messageData.id || messageData.message_id || Date.now();
 messageDiv.setAttribute('data-message-id', messageId);


 if (messageData.type === 'file') {
 messageDiv.classList.add('file-message');
 } else if (messageData.type === 'system') {
 messageDiv.classList.add('system-message');
 }

 const timestamp = new Date(messageData.timestamp || new Date()).toLocaleTimeString();

 let content = '';
 if (messageData.type === 'system') {
 content = `<div class="message-content">${messageData.content}</div>`;
 } else if (messageData.type === 'file') {
 // Check if the file message is deleted
 if (messageData.deleted) {
 content = `
 <div class="message-header">
 <span class="text-slate-400 dark:text-slate-500">${messageData.sender_name} deleted this message</span>
 <span class="message-timestamp">${timestamp}</span>
 </div>
 <div class="message-content">
 <em class="text-slate-400 dark:text-slate-500">This message was deleted</em>
 </div>
 `;
 messageDiv.classList.add('deleted');
 } else {
 const downloadUrl = `/download/${messageData.file_id}`;

 // Check if the file is an image
 const isImage = messageData.file_type && messageData.file_type.startsWith('image/');

 if (isImage) {
 // Display image preview for image files
 content = `
 <div class="message-header">
 <span>${messageData.sender_name}</span>
 <span class="message-timestamp">${timestamp}</span>
 </div>
 <div class="message-content">
 <div class="image-preview-container mb-2">
 <img src="${downloadUrl}" alt="${messageData.content}"
      class="max-w-full max-h-64 rounded-lg border border-slate-200 dark:border-slate-600 cursor-pointer hover:opacity-90 transition-opacity"
      data-image-url="${downloadUrl}" data-image-name="${messageData.content}"
      loading="lazy">
 </div>
 <a href="${downloadUrl}" class="file-download-link text-xs" target="_blank" download="${messageData.content}">
 <svg class="w-3 h-3 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 Download ${messageData.content}
 </a>
 </div>
 `;
 } else {
 // Display regular file download link for non-image files
 // Remove üìé emoji from filename if present
 const cleanFileName = messageData.content.replace(/üìé\s*/, '');

 // Check if the file is a PDF
 const isPdf = messageData.file_type === 'application/pdf' || cleanFileName.toLowerCase().endsWith('.pdf');

 if (isPdf) {
 // Display PDF preview interface
 content = `
 <div class="message-header">
 <span>${messageData.sender_name}</span>
 <span class="message-timestamp">${timestamp}</span>
 </div>
 <div class="message-content">
 <div class="pdf-preview-container bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-600 rounded-lg p-4 max-w-md">
 <div class="flex items-center space-x-3 mb-3">
 <svg class="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 <div class="flex-1">
 <div class="font-medium text-slate-800 dark:text-slate-200">${cleanFileName}</div>
 <div class="text-sm text-slate-500 dark:text-slate-400">PDF Document</div>
 </div>
 </div>
 <div class="flex space-x-2">
 <button onclick="previewPdfFromMessage('${downloadUrl}', '${cleanFileName}')"
 class="flex-1 bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
 <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
 </svg>
 Preview
 </button>
 <a href="${downloadUrl}" target="_blank" download="${cleanFileName}"
 class="flex-1 bg-slate-500 hover:bg-slate-600 text-white px-3 py-2 rounded-md text-sm font-medium transition-colors text-center">
 <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 Download
 </a>
 </div>
 </div>
 </div>
 `;
 } else {
 // Display regular file download link for non-PDF files
 content = `
 <div class="message-header">
 <span>${messageData.sender_name}</span>
 <span class="message-timestamp">${timestamp}</span>
 </div>
 <div class="message-content">
 <a href="${downloadUrl}" class="file-download-link" target="_blank">
 <svg class="w-4 h-4 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
 </svg>
 ${cleanFileName}
 </a>
 </div>
 `;
 }
 }
 }
 } else {
 // Add reply context if this message is a reply
 let replyContextHtml = '';
 if (messageData.replyTo) {


 const replyToSender = messageData.replyTo.sender_name || messageData.replyTo.sender;
 const replyToContent = messageData.replyTo.content || messageData.replyTo.message;
 const cleanReplyContent = replyToContent.replace(/<[^>]*>/g, '').substring(0, 100);
 const displayReplyContent = cleanReplyContent + (replyToContent.length > 100 ? '...' : '');
 const replyToId = messageData.replyTo.id;


 replyContextHtml = `
 <div class="reply-context" data-reply-to-id="${replyToId}" style="cursor: pointer; background: #22c55e !important; color: white !important; padding: 10px !important; margin: 5px 0 !important; border-radius: 5px !important;" title="Click to go to original message">
 <div class="reply-context-header" style="color: white !important; font-weight: bold !important;">~ ${replyToSender}</div>
 <div class="reply-context-content" style="color: #f0f0f0 !important;">${displayReplyContent}</div>
 </div>
 `;
 }

 // Handle deleted and edited messages
 let messageContent = messageData.content;
 let senderDisplay = messageData.sender_name;
 let timeDisplay = timestamp;

 if (messageData.deleted) {
 messageContent = '<em class="text-slate-400 dark:text-slate-500">This message was deleted</em>';
 senderDisplay = `<span class="text-slate-400 dark:text-slate-500">${messageData.sender_name} deleted this message</span>`;
 messageDiv.classList.add('deleted');
 }

 content = `
 ${replyContextHtml}
 <div class="message-header">
 <span class="message-sender">${senderDisplay}</span>
 <span class="message-timestamp">${timeDisplay}</span>
 </div>
 <div class="message-content">${messageContent}</div>
 `;
 }

 messageDiv.innerHTML = content;

 // Add edited indicator if message was edited
 if (messageData.edited) {
 const editedIndicator = document.createElement('span');
 editedIndicator.className = 'edited-indicator';
 editedIndicator.textContent = 'edited';
 messageDiv.appendChild(editedIndicator);
 }

 // Add click handler for reply context
 const replyContext = messageDiv.querySelector('.reply-context');
 if (replyContext) {
 replyContext.addEventListener('click', () => {
 const replyToId = replyContext.getAttribute('data-reply-to-id');
 if (replyToId) {
 scrollToMessage(replyToId);
 }
 });
 }

 // Add click handler for image preview
 const imagePreview = messageDiv.querySelector('img[data-image-url]');
 if (imagePreview) {
 imagePreview.addEventListener('click', () => {
 const imageUrl = imagePreview.getAttribute('data-image-url');
 const imageName = imagePreview.getAttribute('data-image-name');
 openImageModal(imageUrl, imageName);
 });
 }

 // Add action buttons for user messages (not system messages and not deleted)
 if (messageData.type !== 'system' && !messageData.deleted) {
 const actionsContainer = document.createElement('div');
 actionsContainer.className = 'message-actions absolute top-1 right-1 opacity-0 transition-all duration-200 flex space-x-1 bg-white dark:bg-slate-800 rounded-lg shadow-lg border border-slate-200 dark:border-slate-600 p-1';

 // Reply button (always show)
 const replyButton = document.createElement('button');
 replyButton.className = 'hover:bg-slate-100 dark:hover:bg-slate-700 rounded p-1.5 transition-colors';
 replyButton.innerHTML = '<svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>';
 replyButton.title = 'Reply to this message';
 replyButton.addEventListener('click', () => {
 const replyData = {
 id: messageId,
 sender_name: messageData.sender_name,
 content: messageData.content,
 type: messageData.type,
 replyTo: messageData.replyTo || null
 };
 setGroupReply(replyData);
 });

 actionsContainer.appendChild(replyButton);

 // Only show edit/delete for own messages
 if (messageData.sender_name === currentDisplayName) {
 // Edit button
 const editButton = document.createElement('button');
 editButton.className = 'hover:bg-slate-100 dark:hover:bg-slate-700 rounded p-1.5 transition-colors';
 editButton.innerHTML = '<svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>';
 editButton.title = 'Edit message';
 editButton.addEventListener('click', () => {
 editGroupMessage(messageId, messageData);
 });

 // Delete button
 const deleteButton = document.createElement('button');
 deleteButton.className = 'hover:bg-red-50 dark:hover:bg-red-900 rounded p-1.5 transition-colors';
 deleteButton.innerHTML = '<svg class="w-4 h-4 text-slate-600 dark:text-slate-400 hover:text-red-600 dark:hover:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>';
 deleteButton.title = 'Delete message';
 deleteButton.addEventListener('click', () => {
 deleteGroupMessage(messageId, messageData);
 });

 actionsContainer.appendChild(editButton);
 actionsContainer.appendChild(deleteButton);
 }

 messageDiv.appendChild(actionsContainer);
 }

 // Hide placeholder when adding real messages
 if (groupMessagesPlaceholder) {
 groupMessagesPlaceholder.classList.add('hidden');
 }

 groupMessages.appendChild(messageDiv);

 // Trigger notification for non-system messages
 if (messageData.type !== 'system') {
 const messageTime = new Date(messageData.timestamp || new Date()).getTime();
 console.log('üì® New group message received:', {
 sender: messageData.sender_name,
 content: messageData.content?.substring(0, 50) + '...',
 messageTime: new Date(messageTime).toLocaleTimeString(),
 lastSeenTime: new Date(lastSeenMessageTime).toLocaleTimeString(),
 isNewMessage: messageTime > lastSeenMessageTime,
 activeTab,
 currentUnreadCount: unreadMessageCount
 });

 // Only count messages that arrived after the last time user viewed group messages
 if (messageTime > lastSeenMessageTime) {
 showGroupMessageNotification({
 id: messageId,
 sender: messageData.sender_name,
 content: messageData.content,
 message: messageData.content
 });
 incrementUnreadCount();
 } else {
 console.log('üì≠ Message ignored: older than last seen time');
 }
 }

 // Intelligent auto-scroll
 setTimeout(() => {
 smoothScrollToBottom(groupMessages);
 }, 50);
 }

 function clearGroupMessages() {
 groupMessages.innerHTML = '<div id="group-messages-placeholder" class="text-center text-slate-500 dark:text-slate-400 text-xs">Join a collaboration room to start messaging</div>';
 }

 // --- Notification System Functions ---
 function showGroupMessageNotification(messageData) {
 // Only skip notifications if muted OR if actively viewing group messages
 if (!notificationsEnabled) {
 console.log('üì≠ Notification skipped: notifications disabled');
 return;
 }

 if (activeTab === 'group-message') {
 console.log('üì≠ Notification skipped: currently viewing group messages');
 return;
 }

 console.log('üì¢ Showing group message notification - activeTab:', activeTab);

 const notification = document.createElement('div');
 notification.className = 'notification-popup';
 notification.setAttribute('data-message-id', messageData.id || Date.now());

 const senderInitial = messageData.sender ? messageData.sender.charAt(0).toUpperCase() : 'U';
 const senderName = messageData.sender || 'Unknown User';
 const messageText = messageData.content || messageData.message || '';
 const timeStr = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

 notification.innerHTML = `
 <div class="notification-header">
 <div class="notification-avatar">${senderInitial}</div>
 <div class="notification-content">
 <div class="notification-sender">${senderName}</div>
 <div class="notification-time">${timeStr}</div>
 </div>
 </div>
 <div class="notification-message">${messageText}</div>
 `;

 // Click handler to navigate to message
 notification.addEventListener('click', () => {
 navigateToGroupMessage(messageData.id || Date.now());
 hideNotification(notification);
 });

 notificationContainer.appendChild(notification);

 // Show with animation
 setTimeout(() => {
 notification.classList.add('show');
 }, 100);

 // Auto-hide after 3 seconds
 setTimeout(() => {
 hideNotification(notification);
 }, 3000);
 }

 function hideNotification(notification) {
 notification.classList.remove('show');
 setTimeout(() => {
 if (notification.parentNode) {
 notification.parentNode.removeChild(notification);
 }
 }, 300);
 }

 function navigateToGroupMessage(messageId) {
 console.log('üîÑ Navigating to group message:', messageId);

 // First, ensure the AI chat sidebar is visible
 const aiChatSidebar = document.getElementById('ai-chat-sidebar');
 const aiChatContainer = document.getElementById('ai-chat-container');
 const aiChatToggle = document.getElementById('ai-chat-toggle');

 console.log('Current sidebar state:', {
 sidebarVisible: aiChatSidebar && !aiChatSidebar.classList.contains('hidden'),
 containerVisible: aiChatContainer && !aiChatContainer.classList.contains('hidden'),
 isChatSidebarVisible
 });

 // Show the sidebar if it's hidden
 if (!isChatSidebarVisible) {
 console.log('üîÑ Opening AI chat sidebar');
 toggleAISidebar();
 }

 // Also ensure container is visible (legacy support)
 if (aiChatContainer && aiChatContainer.classList.contains('hidden')) {
 console.log('üîÑ Opening AI chat container');
 aiChatContainer.classList.remove('hidden');
 if (aiChatToggle) {
 aiChatToggle.classList.add('active');
 }
 }

 // Switch to group message tab
 console.log('üîÑ Switching to group-message tab');
 switchTab('group-message');

 // Find and highlight the message using the same smooth highlighting as scrollToMessage
 setTimeout(() => {
 const messageElements = groupMessages.querySelectorAll('.message-item');
 for (let msgEl of messageElements) {
 if (msgEl.getAttribute('data-message-id') === messageId.toString()) {
 // Scroll to message
 msgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

 // Use the same smooth highlighting as scrollToMessage
 highlightMessage(msgEl);
 break;
 }
 }
 }, 100);
 }

 function updateMessageCounter() {
 console.log('üîÑ Updating message counter:', {
 isGroupConnected,
 currentGroupRoomId,
 unreadMessageCount,
 activeTab
 });

 // Only show counter if connected to a group room AND have unread messages AND not currently viewing group messages
 if (isGroupConnected && currentGroupRoomId && unreadMessageCount > 0 && activeTab !== 'group-message') {
 messageCounterBadge.textContent = unreadMessageCount > 99 ? '99+' : unreadMessageCount.toString();
 messageCounterBadge.classList.remove('hidden');
 console.log('üì¢ Showing message counter:', unreadMessageCount);
 } else {
 messageCounterBadge.classList.add('hidden');
 if (unreadMessageCount === 0) {
 console.log('üì≠ Hiding counter: no unread messages');
 } else if (activeTab === 'group-message') {
 console.log('üì≠ Hiding counter: viewing group messages');
 } else if (!isGroupConnected || !currentGroupRoomId) {
 console.log('üì≠ Hiding counter: not connected to group room');
 }
 }
 }

 function incrementUnreadCount() {
 console.log('üìà Incrementing unread count. Current:', unreadMessageCount, 'Active tab:', activeTab);
 if (activeTab !== 'group-message') {
 unreadMessageCount++;
 console.log('üìà New unread count:', unreadMessageCount);
 updateMessageCounter();
 } else {
 console.log('üì≠ Not incrementing: viewing group messages');
 }
 }

 function resetUnreadCount() {
 console.log('üîÑ Resetting unread count from:', unreadMessageCount);
 unreadMessageCount = 0;
 lastSeenMessageTime = Date.now(); // Mark when user last saw messages
 console.log('üìÖ Set last seen time to:', new Date(lastSeenMessageTime).toLocaleTimeString());
 updateMessageCounter();
 }

 function toggleNotifications() {
 notificationsEnabled = !notificationsEnabled;
 const muteBtn = document.getElementById('mute-btn-text');
 const muteIcon = muteNotificationsBtn.querySelector('svg path');

 if (notificationsEnabled) {
 muteBtn.textContent = 'Mute';
 muteNotificationsBtn.classList.remove('muted');
 muteIcon.setAttribute('d', 'M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z');
 } else {
 muteBtn.textContent = 'Unmute';
 muteNotificationsBtn.classList.add('muted');
 muteIcon.setAttribute('d', 'M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2');
 }

 // Save preference to localStorage
 localStorage.setItem('groupNotificationsEnabled', notificationsEnabled.toString());
 }

 // --- Video Call Manager ---
 class VideoCallManager {
 constructor() {
 this.api = null;
 this.isActive = false;
 this.participants = new Map(); // Video call participants only
 this.activeConnections = new Map(); // Track actual WebRTC connections
 this.videoCallRoomId = null; // Separate video call room ID
 this.roomName = null;
 this.isModerator = false;
 this.domain = 'meet.jit.si';
 this.webrtcSignalHandler = null;
 this.reconnectAttempts = new Map(); // Track reconnection attempts per user
 this.options = {
 roomName: '',
 width: '100%',
 height: '100%',
 parentNode: null,
 configOverwrite: {
 startWithAudioMuted: true,
 startWithVideoMuted: true,
 enableWelcomePage: false,
 prejoinPageEnabled: false,
 disableModeratorIndicator: true,
 startScreenSharing: false,
 enableEmailInStats: false,
 requireDisplayName: false,
 enableUserRolesBasedOnToken: false,
 enableInsecureRoomNameWarning: false,
 doNotStoreRoom: true,
 disableDeepLinking: true,
 enableLobby: false,
 enableLobbyChat: false,
 enableClosePage: false,
 enableNoisyMicDetection: false,
 },
 interfaceConfigOverwrite: {
 TOOLBAR_BUTTONS: [
 'microphone', 'camera', 'desktop', 'fullscreen',
 'fodeviceselection', 'hangup', 'settings', 'videoquality', 'filmstrip'
 ],
 SETTINGS_SECTIONS: ['devices', 'language'],
 SHOW_JITSI_WATERMARK: false,
 SHOW_WATERMARK_FOR_GUESTS: false,
 SHOW_BRAND_WATERMARK: false,
 BRAND_WATERMARK_LINK: '',
 SHOW_POWERED_BY: false,
 SHOW_PROMOTIONAL_CLOSE_PAGE: false,
 SHOW_CHROME_EXTENSION_BANNER: false,
 DISABLE_JOIN_LEAVE_NOTIFICATIONS: true,
 DISABLE_PRESENCE_STATUS: true,
 HIDE_INVITE_MORE_HEADER: true,
 MOBILE_APP_PROMO: false,
 },
 userInfo: {
 displayName: localStorage.getItem('userName') || 'Anonymous'
 }
 };
 }

 async startCall(roomId) {
 if (this.isActive) {
 console.log('Video call already active');
 return false;
 }

 // Check if we're actually in a collaboration room
 if (!currentRoomId || currentRoomId !== roomId) {
 console.error('Cannot start video call: not in collaboration room');
 this.handleVideoCallError('Room error', new Error('You must be in a collaboration room to start a video call'));
 return false;
 }

 // Check browser compatibility
 if (!this.checkBrowserCompatibility()) {
 this.handleVideoCallError('Browser not supported', new Error('Browser compatibility check failed'));
 return false;
 }

 // Check device availability
 const deviceCheck = await this.checkDeviceAvailability();
 if (!deviceCheck.success) {
 this.handleVideoCallError('Device not available', new Error(deviceCheck.error));
 return false;
 }

 // Check network connectivity
 if (!navigator.onLine) {
 this.handleVideoCallError('Network error', new Error('No internet connection'));
 return false;
 }

 try {
 // Use simple WebRTC-based video call instead of Jitsi
 await this.startSimpleVideoCall(roomId);
 return true;

 } catch (error) {
 console.error('Failed to start video call:', error);
 this.handleVideoCallError('Failed to start video call', error);
 return false;
 }
 }

 async startSimpleVideoCall(roomId) {
 // Ensure video call container exists and is visible
 const videoCallContainer = document.getElementById('video-call-container');
 if (!videoCallContainer) {
 throw new Error('Video call container not found');
 }

 // Show video container first
 videoCallContainer.classList.remove('hidden');
 videoCallContainer.style.minHeight = '280px';

 // Ensure video participants container exists
 const videoContainer = document.getElementById('video-participants-container');
 if (!videoContainer) {
 throw new Error('Video participants container not found');
 }

 // Get user media first
 try {
 localStream = await navigator.mediaDevices.getUserMedia({
 video: true,
 audio: true
 });

 // Disable video and audio tracks by default
 localStream.getVideoTracks().forEach(track => {
 track.enabled = window.videoEnabled || false;
 });
 localStream.getAudioTracks().forEach(track => {
 track.enabled = window.audioEnabled || false;
 });

 console.log(`Local stream created with ${localStream.getTracks().length} tracks:`,
 localStream.getTracks().map(t => `${t.kind} (enabled: ${t.enabled})`));

 // Create local video element
 this.createLocalVideoElement();

 // Add local participant to participants map
 this.participants.set('local', { id: currentUserId });
 this.updateParticipantCount();

 // Set up WebRTC signaling
 this.setupWebRTCSignaling();

 // Set up controls
 this.setupSimpleVideoControls();

 // Set video call room ID (independent of collaboration room)
 this.videoCallRoomId = `video-${roomId}-${Date.now()}`;

 // Update UI
 this.isActive = true;
 this.updateVideoCallUI();

 // Notify other users about video call start
 this.notifyVideoCallEvent('call_started', {
 roomName: `FluxNotebook-${roomId}`,
 videoCallRoomId: this.videoCallRoomId,
 initiator: currentUserId
 });

 // Also notify that we joined as a participant
 setTimeout(() => {
 this.notifyVideoCallEvent('participant_joined', {
 userId: currentUserId
 });

 // Send a WebRTC signal to request existing participants to initiate connections
 this.sendWebRTCSignal('*', 'user-joined', { userId: currentUserId });
 }, 500);

 console.log('WebRTC video call started successfully - waiting for other participants');

 } catch (error) {
 throw new Error(`Failed to access camera/microphone: ${error.message}`);
 }
 }

 createLocalVideoElement() {
 let videoGrid = document.getElementById('video-participants-grid');

 // If video grid doesn't exist, create it
 if (!videoGrid) {
 console.log('Video grid not found, creating it...');
 const videoContainer = document.getElementById('video-participants-container');
 if (!videoContainer) {
 throw new Error('Video participants container not found');
 }

 videoContainer.innerHTML = `
 <div id="video-participants-grid" class="grid grid-cols-5 gap-2" style="grid-template-rows: repeat(auto-fit, 88px);">
 <div id="video-placeholder" class="col-span-5 text-center py-8 text-slate-500 dark:text-slate-400 text-sm">
 <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
 </svg>
 <p>No video call active</p>
 <p class="text-xs mt-1">Start a video call to see participants here</p>
 </div>
 </div>
 `;

 videoGrid = document.getElementById('video-participants-grid');
 }

 // Hide placeholder
 const placeholder = document.getElementById('video-placeholder');
 if (placeholder) {
 placeholder.style.display = 'none';
 }

 const localVideoContainer = document.createElement('div');
 localVideoContainer.id = 'local-video-container';
 localVideoContainer.className = 'relative bg-slate-900 rounded-lg overflow-hidden border-2 border-blue-500 flex-shrink-0';
 localVideoContainer.style.cssText = 'width: 140px; height: 88px; min-width: 140px; min-height: 88px; max-width: 140px; max-height: 88px;';
 localVideoContainer.innerHTML = `
 <video id="local-video" autoplay muted playsinline class="w-full h-full object-cover"></video>
 <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-1">
 <div class="flex items-center justify-between">
 <span class="text-xs font-medium text-white truncate">You (${localStorage.getItem('userName') || 'Anonymous'})</span>
 <div class="flex space-x-1">
 <button id="toggle-video-btn" class="p-0.5 rounded bg-red-500 text-white hover:bg-red-600" title="Turn On Video">
 <svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
 </svg>
 </button>
 <button id="toggle-audio-btn" class="p-0.5 rounded bg-red-500 text-white hover:bg-red-600" title="Unmute Audio">
 <svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
 </svg>
 </button>
 <button id="toggle-screen-btn" class="p-0.5 rounded bg-purple-500 text-white hover:bg-purple-600" title="Share Screen">
 <svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
 </svg>
 </button>
 </div>
 </div>
 </div>
 `;

 videoGrid.appendChild(localVideoContainer);

 const localVideo = document.getElementById('local-video');
 localVideo.srcObject = localStream;

 // Add double-click functionality for popup
 const userName = localStorage.getItem('userName') || 'Anonymous';
 addVideoDoubleClickHandler(localVideoContainer, localVideo, userName, true);
 }

 setupWebRTCSignaling() {
 // Remove any existing WebRTC signal handler to avoid duplicates
 if (this.webrtcSignalHandler) {
 collaborationSocket.removeEventListener('message', this.webrtcSignalHandler);
 }

 // Create new handler and store reference for cleanup
 this.webrtcSignalHandler = (event) => {
 const data = JSON.parse(event.data);
 if (data.type === 'webrtc_signal') {
 this.handleWebRTCSignal(data);
 }
 };

 // Listen for WebRTC signaling messages
 if (collaborationSocket) {
 collaborationSocket.addEventListener('message', this.webrtcSignalHandler);
 }
 }

 async handleWebRTCSignal(data) {
 const { fromUserId, signalType, signalData } = data;

 switch (signalType) {
 case 'offer':
 await this.handleOffer(fromUserId, signalData);
 break;
 case 'answer':
 await this.handleAnswer(fromUserId, signalData);
 break;
 case 'ice-candidate':
 await this.handleIceCandidate(fromUserId, signalData);
 break;
 case 'user-joined':
 // Only respond if we're currently in an active call
 if (this.isActive) {
 console.log(`Received user-joined signal from ${fromUserId}, initiating connection`);
 await this.handleUserJoined(fromUserId);
 } else {
 console.log(`Ignoring user-joined signal from ${fromUserId} - not in active call`);
 }
 break;
 case 'user-left':
 this.handleUserLeft(fromUserId);
 break;
 }
 }

 setupEventListeners() {
 if (!this.api) return;

 // Participant events
 this.api.addEventListener('participantJoined', (participant) => {
 console.log('Participant joined:', participant);
 this.participants.set(participant.id, participant);
 this.optimizeDOMUpdates(); // Use optimized DOM updates
 this.notifyVideoCallEvent('participant_joined', participant);
 });

 this.api.addEventListener('participantLeft', (participant) => {
 console.log('Participant left:', participant);
 this.participants.delete(participant.id);
 this.optimizeDOMUpdates(); // Use optimized DOM updates
 this.notifyVideoCallEvent('participant_left', participant);
 });

 // Video/Audio events
 this.api.addEventListener('videoConferenceJoined', (participant) => {
 console.log('Local participant joined:', participant);
 this.participants.set('local', participant);
 this.isModerator = true; // First to join is moderator
 this.updateParticipantCount();
 this.updateVideoCallUI();
 this.optimizeBandwidth();
 });

 // Handle authentication/lobby events
 this.api.addEventListener('readyToClose', () => {
 console.log('Jitsi Meet ready to close');
 this.endCall();
 });

 // Auto-join if waiting for moderator
 this.api.addEventListener('participantRoleChanged', (event) => {
 console.log('Participant role changed:', event);
 if (event.role === 'moderator') {
 this.isModerator = true;
 this.updateVideoCallUI();
 }
 });

 this.api.addEventListener('videoConferenceLeft', () => {
 console.log('Local participant left');
 this.endCall();
 });



 // Connection quality events
 this.api.addEventListener('connectionQualityChanged', (quality) => {
 console.log('Connection quality changed:', quality);
 this.handleConnectionQuality(quality);
 });

 // Audio/Video mute events
 this.api.addEventListener('audioMuteStatusChanged', (status) => {
 console.log('Audio mute status:', status);
 });

 this.api.addEventListener('videoMuteStatusChanged', (status) => {
 console.log('Video mute status:', status);
 });

 // Error handling
 this.api.addEventListener('readyToClose', () => {
 console.log('Jitsi Meet ready to close');
 this.endCall();
 });

 // Handle API errors
 this.api.addEventListener('errorOccurred', (error) => {
 console.error('Jitsi Meet error:', error);
 this.handleVideoCallError('Video call error', error);
 });

 // Handle device changes
 this.api.addEventListener('deviceListChanged', (devices) => {
 console.log('Device list changed:', devices);
 this.handleDeviceChange(devices);
 });

 // Set up network monitoring
 this.handleNetworkReconnection();
 }

 handleConnectionQuality(quality) {
 // Handle poor connection quality
 if (quality && quality.connectionQuality < 50) {
 console.warn('Poor connection quality detected:', quality.connectionQuality);
 // Could show a warning to the user or automatically reduce quality
 this.api.executeCommand('setVideoQuality', 'low');
 }
 }

 handleDeviceChange(devices) {
 // Handle device changes (e.g., camera/microphone plugged/unplugged)
 const hasCamera = devices.some(device => device.kind === 'videoinput');
 const hasMicrophone = devices.some(device => device.kind === 'audioinput');

 if (!hasCamera && !hasMicrophone) {
 this.handleVideoCallError('Device error', new Error('All devices disconnected'));
 }
 }

 async createPeerConnection(userId) {
 const configuration = {
 iceServers: [
 { urls: 'stun:stun.l.google.com:19302' },
 { urls: 'stun:stun1.l.google.com:19302' },
 { urls: 'stun:stun2.l.google.com:19302' },
 { urls: 'stun:stun3.l.google.com:19302' }
 ],
 iceCandidatePoolSize: 10
 };

 const peerConnection = new RTCPeerConnection(configuration);
 peerConnections.set(userId, peerConnection);

 console.log(`Creating peer connection for user ${userId}`);

 // Add local stream to peer connection
 if (localStream) {
 console.log(`Local stream available with ${localStream.getTracks().length} tracks for user ${userId}`);
 localStream.getTracks().forEach(track => {
 console.log(`Adding ${track.kind} track (enabled: ${track.enabled}, readyState: ${track.readyState}) to peer connection for ${userId}`);
 peerConnection.addTrack(track, localStream);
 });
 } else {
 console.error(`No local stream available when creating peer connection for ${userId}`);
 }

 // Handle remote stream
 peerConnection.ontrack = (event) => {
 console.log('Received remote stream from user:', userId, event.streams);
 const remoteStream = event.streams[0];
 if (remoteStream) {
 remoteStreams.set(userId, remoteStream);
 this.createRemoteVideoElement(userId, remoteStream);
 console.log(`Remote stream added for user ${userId}, tracks:`, remoteStream.getTracks().length);
 }
 };

 // Handle ICE candidates
 peerConnection.onicecandidate = (event) => {
 if (event.candidate) {
 console.log(`Sending ICE candidate to ${userId}:`, event.candidate);
 this.sendWebRTCSignal(userId, 'ice-candidate', event.candidate);
 } else {
 console.log(`ICE gathering complete for ${userId}`);
 }
 };

 // Handle connection state changes
 peerConnection.onconnectionstatechange = () => {
 console.log(`Connection state with ${userId}:`, peerConnection.connectionState);
 if (peerConnection.connectionState === 'connected') {
 console.log(`Successfully connected to ${userId}`);
 this.reconnectAttempts.delete(userId); // Reset reconnect attempts on success
 this.updateParticipantCount(); // Update count when connection established
 } else if (peerConnection.connectionState === 'disconnected') {
 console.log(`Connection disconnected with ${userId}, attempting reconnection...`);
 this.attemptReconnection(userId);
 } else if (peerConnection.connectionState === 'failed') {
 console.log(`Connection failed with ${userId}`);
 this.attemptReconnection(userId);
 } else if (peerConnection.connectionState === 'connecting') {
 console.log(`Connecting to ${userId}...`);
 this.updateParticipantCount(); // Update count to show connecting state
 }
 };

 // Handle ICE connection state changes
 peerConnection.oniceconnectionstatechange = () => {
 console.log(`ICE connection state with ${userId}:`, peerConnection.iceConnectionState);
 };

 return peerConnection;
 }

 async attemptReconnection(userId) {
 if (!this.isActive) {
 console.log(`Not attempting reconnection with ${userId} - call not active`);
 return;
 }

 const attempts = this.reconnectAttempts.get(userId) || 0;
 const maxAttempts = 3;
 const delay = Math.min(1000 * Math.pow(2, attempts), 10000); // Exponential backoff, max 10s

 if (attempts >= maxAttempts) {
 console.log(`Max reconnection attempts reached for ${userId}, removing from call`);
 this.handleUserLeft(userId);
 return;
 }

 this.reconnectAttempts.set(userId, attempts + 1);
 console.log(`Attempting reconnection ${attempts + 1}/${maxAttempts} with ${userId} in ${delay}ms`);

 setTimeout(async () => {
 if (!this.isActive || !peerConnections.has(userId)) {
 return; // Call ended or user already reconnected
 }

 try {
 // Close old connection
 const oldConnection = peerConnections.get(userId);
 if (oldConnection) {
 oldConnection.close();
 peerConnections.delete(userId);
 }

 // Create new connection and send offer
 console.log(`Reconnecting to ${userId}...`);
 await this.handleUserJoined(userId);
 } catch (error) {
 console.error(`Reconnection attempt failed for ${userId}:`, error);
 this.attemptReconnection(userId); // Try again
 }
 }, delay);
 }

 async handleOffer(fromUserId, offer) {
 try {
 console.log('Received offer from:', fromUserId, offer);

 // Check if we already have a peer connection with this user
 if (peerConnections.has(fromUserId)) {
 console.log(`Already have peer connection with ${fromUserId}, closing old one first`);
 const oldConnection = peerConnections.get(fromUserId);
 oldConnection.close();
 peerConnections.delete(fromUserId);
 }

 const peerConnection = await this.createPeerConnection(fromUserId);

 console.log(`Setting remote description for ${fromUserId}`);
 await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

 // Process queued ICE candidates
 if (iceCandidatesQueue.has(fromUserId)) {
 const candidates = iceCandidatesQueue.get(fromUserId);
 console.log(`Processing ${candidates.length} queued ICE candidates for ${fromUserId}`);
 for (const candidate of candidates) {
 try {
 await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
 } catch (e) {
 console.warn(`Failed to add ICE candidate for ${fromUserId}:`, e);
 }
 }
 iceCandidatesQueue.delete(fromUserId);
 }

 console.log(`Creating answer for ${fromUserId}`);
 const answer = await peerConnection.createAnswer();
 await peerConnection.setLocalDescription(answer);

 console.log(`Sending answer to ${fromUserId}:`, answer);
 this.sendWebRTCSignal(fromUserId, 'answer', answer);
 } catch (error) {
 console.error(`Error handling offer from ${fromUserId}:`, error);
 }
 }

 async handleAnswer(fromUserId, answer) {
 try {
 console.log('Received answer from:', fromUserId, answer);

 const peerConnection = peerConnections.get(fromUserId);
 if (peerConnection) {
 console.log(`Setting remote description (answer) for ${fromUserId}`);
 await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));

 // Process queued ICE candidates
 if (iceCandidatesQueue.has(fromUserId)) {
 const candidates = iceCandidatesQueue.get(fromUserId);
 console.log(`Processing ${candidates.length} queued ICE candidates for ${fromUserId}`);
 for (const candidate of candidates) {
 try {
 await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
 } catch (e) {
 console.warn(`Failed to add ICE candidate for ${fromUserId}:`, e);
 }
 }
 iceCandidatesQueue.delete(fromUserId);
 }
 } else {
 console.error(`No peer connection found for user ${fromUserId}`);
 }
 } catch (error) {
 console.error(`Error handling answer from ${fromUserId}:`, error);
 }
 }

 async handleIceCandidate(fromUserId, candidate) {
 try {
 console.log('Received ICE candidate from:', fromUserId, candidate);

 const peerConnection = peerConnections.get(fromUserId);
 if (peerConnection && peerConnection.remoteDescription) {
 console.log(`Adding ICE candidate for ${fromUserId}`);
 await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
 } else {
 // Queue the candidate if remote description is not set yet
 console.log(`Queueing ICE candidate for ${fromUserId} (no remote description yet)`);
 if (!iceCandidatesQueue.has(fromUserId)) {
 iceCandidatesQueue.set(fromUserId, []);
 }
 iceCandidatesQueue.get(fromUserId).push(candidate);
 }
 } catch (error) {
 console.error(`Error handling ICE candidate from ${fromUserId}:`, error);
 }
 }

 async handleUserJoined(userId) {
 try {
 console.log('User joined video call, creating offer for:', userId);

 // Don't create connection to ourselves
 if (userId === currentUserId) {
 console.log('Ignoring self-join event');
 return;
 }

 // Check if we already have a peer connection with this user
 if (peerConnections.has(userId)) {
 console.log(`Already have peer connection with ${userId}, closing old one first`);
 const oldConnection = peerConnections.get(userId);
 oldConnection.close();
 peerConnections.delete(userId);
 }

 // Add participant to participants map and update count
 if (!this.participants.has(userId)) {
 this.participants.set(userId, { id: userId });
 this.updateParticipantCount();
 }

 // Create offer for the new user
 const peerConnection = await this.createPeerConnection(userId);

 console.log(`Creating offer for ${userId}`);
 const offer = await peerConnection.createOffer({
 offerToReceiveAudio: true,
 offerToReceiveVideo: true
 });
 await peerConnection.setLocalDescription(offer);

 console.log(`Sending offer to ${userId}:`, offer);
 this.sendWebRTCSignal(userId, 'offer', offer);
 } catch (error) {
 console.error(`Error handling user joined ${userId}:`, error);
 }
 }

 handleUserLeft(userId) {
 console.log('User left video call:', userId);

 // Clean up peer connection
 if (peerConnections.has(userId)) {
 peerConnections.get(userId).close();
 peerConnections.delete(userId);
 }

 // Remove remote stream
 if (remoteStreams.has(userId)) {
 remoteStreams.delete(userId);
 }

 // Remove video element
 const videoElement = document.getElementById(`remote-video-container-${userId}`);
 if (videoElement) {
 videoElement.remove();
 }

 // Clean up ICE candidates queue
 if (iceCandidatesQueue.has(userId)) {
 iceCandidatesQueue.delete(userId);
 }

 // Remove participant from participants map and update count
 this.participants.delete(userId);
 this.updateParticipantCount();

 // Show placeholder if no participants left
 const videoGrid = document.getElementById('video-participants-grid');
 const localContainer = document.getElementById('local-video-container');
 if (videoGrid.children.length === 1 && localContainer) {
 // Only local video left, but keep it since we're still in the call
 }
 }

 createRemoteVideoElement(userId, stream) {
 let videoGrid = document.getElementById('video-participants-grid');

 // If video grid doesn't exist, create it
 if (!videoGrid) {
 console.log('Video grid not found for remote video, creating it...');
 const videoContainer = document.getElementById('video-participants-container');
 if (!videoContainer) {
 console.error('Video participants container not found');
 return;
 }

 videoContainer.innerHTML = `
 <div id="video-participants-grid" class="grid grid-cols-5 gap-2" style="grid-template-rows: repeat(auto-fit, 88px);">
 </div>
 `;

 videoGrid = document.getElementById('video-participants-grid');
 }

 // Remove existing video element if any
 const existingElement = document.getElementById(`remote-video-container-${userId}`);
 if (existingElement) {
 existingElement.remove();
 }

 const userName = this.getUserName(userId);
 const remoteVideoContainer = document.createElement('div');
 remoteVideoContainer.id = `remote-video-container-${userId}`;
 remoteVideoContainer.className = 'relative bg-slate-900 rounded-lg overflow-hidden border-2 border-green-500 flex-shrink-0';
 remoteVideoContainer.style.cssText = 'width: 140px; height: 88px; min-width: 140px; min-height: 88px; max-width: 140px; max-height: 88px;';
 remoteVideoContainer.innerHTML = `
 <video id="remote-video-${userId}" autoplay playsinline class="w-full h-full object-cover"></video>
 <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-1">
 <div class="flex items-center justify-between">
 <span class="text-xs font-medium text-white truncate">${userName}</span>
 <div class="w-2 h-2 rounded-full bg-green-500" title="Connected"></div>
 </div>
 </div>
 `;

 videoGrid.appendChild(remoteVideoContainer);

 const remoteVideo = document.getElementById(`remote-video-${userId}`);
 remoteVideo.srcObject = stream;

 // Add double-click functionality for popup
 addVideoDoubleClickHandler(remoteVideoContainer, remoteVideo, userName, false);
 }

 sendWebRTCSignal(toUserId, signalType, signalData) {
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'webrtc_signal',
 toUserId: toUserId,
 fromUserId: currentUserId,
 signalType: signalType,
 signalData: signalData,
 room_id: currentRoomId
 }));
 }
 }

 getUserName(userId) {
 const user = roomUsers.get(userId);
 return user ? user.name : `User ${userId.slice(0, 8)}`;
 }

 setupSimpleVideoControls() {
 const toggleVideoBtn = document.getElementById('toggle-video-btn');
 const toggleAudioBtn = document.getElementById('toggle-audio-btn');
 const toggleScreenBtn = document.getElementById('toggle-screen-btn');

 // Use global variables for video/audio/screen state
 if (typeof window.videoEnabled === 'undefined') window.videoEnabled = false;
 if (typeof window.audioEnabled === 'undefined') window.audioEnabled = false;
 if (typeof window.screenSharing === 'undefined') window.screenSharing = false;

 // Toggle video
 toggleVideoBtn.addEventListener('click', () => {
 if (localStream) {
 const videoTrack = localStream.getVideoTracks()[0];
 if (videoTrack) {
 window.videoEnabled = !window.videoEnabled;
 videoTrack.enabled = window.videoEnabled;

 toggleVideoBtn.className = window.videoEnabled
 ? 'p-1 rounded bg-blue-500 text-white hover:bg-blue-600'
 : 'p-1 rounded bg-red-500 text-white hover:bg-red-600';

 toggleVideoBtn.title = window.videoEnabled ? 'Turn Off Video' : 'Turn On Video';
 }
 }
 });

 // Toggle audio
 toggleAudioBtn.addEventListener('click', () => {
 if (localStream) {
 const audioTrack = localStream.getAudioTracks()[0];
 if (audioTrack) {
 window.audioEnabled = !window.audioEnabled;
 audioTrack.enabled = window.audioEnabled;

 toggleAudioBtn.className = window.audioEnabled
 ? 'p-1 rounded bg-green-500 text-white hover:bg-green-600'
 : 'p-1 rounded bg-red-500 text-white hover:bg-red-600';

 toggleAudioBtn.title = window.audioEnabled ? 'Mute Audio' : 'Unmute Audio';
 }
 }
 });

 // Toggle screen sharing
 toggleScreenBtn.addEventListener('click', async () => {
 try {
 if (!window.screenSharing) {
 // Start screen sharing
 const screenStream = await navigator.mediaDevices.getDisplayMedia({
 video: true,
 audio: true
 });

 // Replace video track in local stream
 if (localStream) {
 const videoTrack = localStream.getVideoTracks()[0];
 if (videoTrack) {
 localStream.removeTrack(videoTrack);
 videoTrack.stop();
 }

 const screenVideoTrack = screenStream.getVideoTracks()[0];
 localStream.addTrack(screenVideoTrack);

 // Update local video element
 const localVideo = document.getElementById('local-video');
 if (localVideo) {
 localVideo.srcObject = localStream;
 }

 // Update peer connections with new video track
 for (const [userId, peerConnection] of peerConnections) {
 const sender = peerConnection.getSenders().find(s =>
 s.track && s.track.kind === 'video'
 );
 if (sender) {
 await sender.replaceTrack(screenVideoTrack);
 }
 }

 // Handle screen share end
 screenVideoTrack.onended = async () => {
 await this.stopScreenSharing();
 };

 window.screenSharing = true;
 toggleScreenBtn.className = 'p-0.5 rounded bg-red-500 text-white hover:bg-red-600';
 toggleScreenBtn.title = 'Stop Screen Share';

 console.log('Screen sharing started');
 }
 } else {
 // Stop screen sharing
 await this.stopScreenSharing();
 }
 } catch (error) {
 console.error('Error toggling screen share:', error);
 alert('Screen sharing failed. Please try again.');
 }
 });

 }

 async stopScreenSharing() {
 try {
 // Check if video was enabled before stopping screen share
 const wasVideoEnabled = window.videoEnabled;

 if (wasVideoEnabled) {
 // Get camera stream again only if video was enabled
 const cameraStream = await navigator.mediaDevices.getUserMedia({
 video: true,
 audio: true
 });

 // Replace screen track with camera track
 if (localStream) {
 const screenTrack = localStream.getVideoTracks()[0];
 if (screenTrack) {
 localStream.removeTrack(screenTrack);
 screenTrack.stop();
 }

 const cameraVideoTrack = cameraStream.getVideoTracks()[0];
 localStream.addTrack(cameraVideoTrack);

 // Update local video element
 const localVideo = document.getElementById('local-video');
 if (localVideo) {
 localVideo.srcObject = localStream;
 }

 // Update peer connections with camera track
 for (const [userId, peerConnection] of peerConnections) {
 const sender = peerConnection.getSenders().find(s =>
 s.track && s.track.kind === 'video'
 );
 if (sender) {
 await sender.replaceTrack(cameraVideoTrack);
 }
 }

 // Stop any remaining camera tracks we don't need
 cameraStream.getTracks().forEach(track => {
 if (!localStream.getTracks().includes(track)) {
 track.stop();
 }
 });
 }
 } else {
 // If video was disabled, just remove the screen track without replacing
 if (localStream) {
 const screenTrack = localStream.getVideoTracks()[0];
 if (screenTrack) {
 localStream.removeTrack(screenTrack);
 screenTrack.stop();
 }

 // Update peer connections to remove video track
 for (const [userId, peerConnection] of peerConnections) {
 const sender = peerConnection.getSenders().find(s =>
 s.track && s.track.kind === 'video'
 );
 if (sender) {
 await sender.replaceTrack(null);
 }
 }

 // Update local video element
 const localVideo = document.getElementById('local-video');
 if (localVideo) {
 localVideo.srcObject = localStream;
 }
 }
 }

 window.screenSharing = false;
 const toggleScreenBtn = document.getElementById('toggle-screen-btn');
 if (toggleScreenBtn) {
 toggleScreenBtn.className = 'p-0.5 rounded bg-purple-500 text-white hover:bg-purple-600';
 toggleScreenBtn.title = 'Share Screen';
 }

 console.log(`Screen sharing stopped. Video was ${wasVideoEnabled ? 'enabled' : 'disabled'} before sharing.`);
 } catch (error) {
 console.error('Error stopping screen share:', error);
 }
 }

 async endCall() {
 if (!this.isActive) return;

 try {
 // Stop local stream
 if (localStream) {
 localStream.getTracks().forEach(track => track.stop());
 localStream = null;
 }

 // Close all peer connections
 for (const [userId, peerConnection] of peerConnections) {
 peerConnection.close();
 }
 peerConnections.clear();
 remoteStreams.clear();
 iceCandidatesQueue.clear();

 // Dispose of Jitsi API if it exists
 if (this.api) {
 this.api.dispose();
 this.api = null;
 }

 // Reset state
 this.isActive = false;
 this.participants.clear();
 this.roomName = null;
 this.isModerator = false;

 // Stop performance monitoring
 this.stopPerformanceMonitoring();

 // Update UI
 this.updateVideoCallUI();
 this.resetVideoContainer();

 // Hide video container
 const videoCallContainer = document.getElementById('video-call-container');
 videoCallContainer.classList.add('hidden');
 videoCallContainer.style.minHeight = '0px';

 // Notify other users
 this.notifyVideoCallEvent('call_ended', {
 endedBy: currentUserId
 });

 // Signal that we left
 this.notifyVideoCallEvent('participant_left', {
 userId: currentUserId
 });

 console.log('Video call ended successfully');

 } catch (error) {
 console.error('Error ending video call:', error);
 }
 }

 async leaveCall() {
 if (!this.isActive) return;

 try {
 // 1. Stop local tracks
 if (localStream) {
 localStream.getTracks().forEach(t => t.stop());
 localStream = null;
 }

 // 2. Close peer connections (but DON'T send call_ended)
 peerConnections.forEach(pc => pc.close());
 peerConnections.clear();
 remoteStreams.clear();
 iceCandidatesQueue.clear();

 // 3. Hang up Jitsi if that's the current backend
 if (this.api) {
 this.api.executeCommand('hangup');
 this.api.dispose();
 this.api = null;
 }

 // 4. Clean up WebRTC signal handler
 if (this.webrtcSignalHandler && collaborationSocket) {
 collaborationSocket.removeEventListener('message', this.webrtcSignalHandler);
 this.webrtcSignalHandler = null;
 }

 // 5. Update state/UI
 this.participants.delete('local');
 this.activeConnections.clear();
 this.reconnectAttempts.clear();
 this.isActive = false;
 this.videoCallRoomId = null;
 this.updateVideoCallUI(); // shows grey status, hides buttons
 this.resetVideoContainer();
 document.getElementById('video-call-container')
 .classList.add('hidden');

 // 6. Tell the room we left
 this.notifyVideoCallEvent('participant_left', { userId: currentUserId });
 } catch (err) {
 console.error('Error leaving call:', err);
 }
 }

 // Debug method to get current video call state
 getCallState() {
 return {
 isActive: this.isActive,
 videoCallRoomId: this.videoCallRoomId,
 participantCount: this.participants.size,
 activeConnectionCount: this.activeConnections.size,
 peerConnectionCount: peerConnections.size,
 localStreamActive: !!localStream,
 participants: Array.from(this.participants.keys()),
 activeConnections: Array.from(this.activeConnections.keys()),
 peerConnections: Array.from(peerConnections.keys()),
 reconnectAttempts: Object.fromEntries(this.reconnectAttempts)
 };
 }



 async muteParticipant(participantId) {
 if (!this.api || !this.isActive || !this.isModerator) return;

 try {
 await this.api.executeCommand('muteEveryone');
 console.log('Muted all participants');
 } catch (error) {
 console.error('Error muting participants:', error);
 }
 }

 updateVideoCallUI() {
 const statusIndicator = document.getElementById('video-call-status');
 const statusText = document.getElementById('video-call-text');
 const leaveCallBtn = document.getElementById('leave-call-btn');
 const startVideoBtn = document.getElementById('start-video-call-btn');

 // Safety check: if video call is active but we're not in a room, stop the call
 if (this.isActive && !currentRoomId) {
 console.warn('Video call active but not in room - stopping call');
 this.leaveCall();
 return;
 }

 if (this.isActive) {
 statusIndicator.className = 'w-2 h-2 rounded-full bg-green-500';
 statusText.textContent = 'Video Call Active';
 leaveCallBtn.classList.remove('hidden');
 startVideoBtn.classList.add('hidden');
 } else {
 statusIndicator.className = 'w-2 h-2 rounded-full bg-red-500';
 statusText.textContent = 'Video Call';
 leaveCallBtn.classList.add('hidden');
 startVideoBtn.classList.remove('hidden');
 }

 this.updateParticipantCount();

 // Update status indicator
 if (typeof videoCallStatusIndicator !== 'undefined') {
 videoCallStatusIndicator.updateStatus(this.isActive, videoCallStatusIndicator.remoteCallActive, this.participants.size);
 }
 }

 updateParticipantCount() {
 const countElement = document.getElementById('video-participants-count');

 // Count actual active participants: local + connected peers
 let count = 0;

 // Count local participant if call is active
 if (this.isActive && localStream) {
 count = 1;
 }

 // Count remote participants with active connections
 for (const [userId, connection] of peerConnections) {
 if (connection.connectionState === 'connected' ||
 connection.connectionState === 'connecting') {
 count++;
 }
 }

 console.log(`Participant count update: ${count} (local: ${this.isActive ? 1 : 0}, peers: ${peerConnections.size})`);
 countElement.textContent = `(${count} participant${count !== 1 ? 's' : ''})`;

 // Update internal tracking
 this.activeConnections.clear();
 if (this.isActive) {
 this.activeConnections.set('local', { id: currentUserId, status: 'connected' });
 }
 for (const [userId, connection] of peerConnections) {
 if (connection.connectionState === 'connected' ||
 connection.connectionState === 'connecting') {
 this.activeConnections.set(userId, { id: userId, status: connection.connectionState });
 }
 }
 }



 resetVideoContainer() {
 const videoContainer = document.getElementById('video-participants-container');
 videoContainer.innerHTML = `
 <div id="video-participants-grid" class="grid grid-cols-5 gap-2" style="grid-template-rows: repeat(auto-fit, 88px);">
 <div id="video-placeholder" class="col-span-5 text-center py-8 text-slate-500 dark:text-slate-400 text-sm">
 <svg class="w-12 h-12 mx-auto mb-3 text-slate-400 dark:text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
 </svg>
 <p>No video call active</p>
 <p class="text-xs mt-1">Start a video call to see participants here</p>
 </div>
 </div>
 `;
 }

 notifyVideoCallEvent(eventType, data) {
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'video_call_event',
 event_type: eventType,
 data: data,
 room_id: currentRoomId,
 user_id: currentUserId
 }));
 }
 }

 handleVideoCallError(message, error) {
 console.error('Video call error:', message, error);

 // Show user-friendly error message
 const errorMessages = {
 'Permission denied': 'Camera/microphone access denied. Please allow permissions and try again.',
 'Network error': 'Network connection failed. Please check your internet connection.',
 'Device not found': 'Camera or microphone not found. Please check your devices.',
 'Browser not supported': 'Your browser doesn\'t support video calling. Please use Chrome, Firefox, or Safari.'
 };

 let userMessage = message;
 for (const [key, value] of Object.entries(errorMessages)) {
 if (error && error.toString().toLowerCase().includes(key.toLowerCase())) {
 userMessage = value;
 break;
 }
 }

 // You could show this in a toast notification or modal
 alert(userMessage);

 // Reset state on error
 this.endCall();
 }

 toggleMinimize() {
 const videoContainer = document.getElementById('video-call-container');
 const minimizeBtn = document.getElementById('video-minimize-btn');
 const participantsContainer = document.getElementById('video-participants-container');

 isVideoCallMinimized = !isVideoCallMinimized;

 if (isVideoCallMinimized) {
 videoContainer.style.minHeight = '50px';
 participantsContainer.style.display = 'none';
 minimizeBtn.innerHTML = `
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
 </svg>
 `;
 minimizeBtn.title = 'Maximize Video';
 } else {
 videoContainer.style.minHeight = '280px';
 participantsContainer.style.display = 'block';
 minimizeBtn.innerHTML = `
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
 </svg>
 `;
 minimizeBtn.title = 'Minimize Video';
 }
 }

 checkBrowserCompatibility() {
 // Check for required APIs
 if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
 console.error('getUserMedia not supported');
 return false;
 }

 if (!window.RTCPeerConnection) {
 console.error('WebRTC not supported');
 return false;
 }

 if (!window.WebSocket) {
 console.error('WebSocket not supported');
 return false;
 }

 // Check browser version
 const userAgent = navigator.userAgent;
 const isChrome = /Chrome/.test(userAgent) && /Google Inc/.test(navigator.vendor);
 const isFirefox = /Firefox/.test(userAgent);
 const isSafari = /Safari/.test(userAgent) && /Apple Computer/.test(navigator.vendor);
 const isEdge = /Edg/.test(userAgent);

 if (!isChrome && !isFirefox && !isSafari && !isEdge) {
 console.error('Unsupported browser');
 return false;
 }

 return true;
 }

 async checkDeviceAvailability() {
 try {
 // Check for camera and microphone
 const devices = await navigator.mediaDevices.enumerateDevices();
 const hasCamera = devices.some(device => device.kind === 'videoinput');
 const hasMicrophone = devices.some(device => device.kind === 'audioinput');

 if (!hasCamera && !hasMicrophone) {
 return { success: false, error: 'No camera or microphone found' };
 }

 // Test camera and microphone access
 try {
 const stream = await navigator.mediaDevices.getUserMedia({
 video: hasCamera,
 audio: hasMicrophone
 });

 // Stop the test stream
 stream.getTracks().forEach(track => track.stop());

 return { success: true };
 } catch (permissionError) {
 if (permissionError.name === 'NotAllowedError') {
 return { success: false, error: 'Camera/microphone permission denied' };
 } else if (permissionError.name === 'NotFoundError') {
 return { success: false, error: 'Camera/microphone not found' };
 } else {
 return { success: false, error: 'Failed to access camera/microphone' };
 }
 }
 } catch (error) {
 console.error('Device check failed:', error);
 return { success: false, error: 'Failed to check device availability' };
 }
 }

 handleNetworkReconnection() {
 // Handle network reconnection
 window.addEventListener('online', () => {
 console.log('Network reconnected');
 if (this.isActive && this.api) {
 // Attempt to rejoin the call
 console.log('Attempting to rejoin video call after network reconnection');
 }
 });

 window.addEventListener('offline', () => {
 console.log('Network disconnected');
 if (this.isActive) {
 this.handleVideoCallError('Network error', new Error('Network connection lost'));
 }
 });
 }

 optimizeBandwidth() {
 if (!this.api || !this.isActive) return;

 // Get participant count for bandwidth optimization
 const participantCount = this.participants.size;

 try {
 // Dynamic quality adjustment based on participant count and connection
 const connectionQuality = this.getConnectionQuality();
 let targetQuality = 'high';

 if (participantCount > 6 || connectionQuality < 30) {
 targetQuality = 'low';
 } else if (participantCount > 3 || connectionQuality < 60) {
 targetQuality = 'standard';
 } else if (participantCount > 1) {
 targetQuality = 'high';
 }

 // Apply mobile-specific optimizations
 if (mobileVideoHandler && mobileVideoHandler.isMobile) {
 if (targetQuality === 'high') targetQuality = 'standard';
 if (participantCount > 2) targetQuality = 'low';
 }

 this.api.executeCommand('setVideoQuality', targetQuality);
 console.log(`Optimized video quality to ${targetQuality} for ${participantCount} participants`);

 // Optimize frame rate for large groups
 if (participantCount > 4) {
 this.api.executeCommand('setVideoConstraints', {
 frameRate: { max: 15 }
 });
 } else {
 this.api.executeCommand('setVideoConstraints', {
 frameRate: { max: 30 }
 });
 }

 } catch (error) {
 console.warn('Failed to optimize bandwidth:', error);
 }
 }

 getConnectionQuality() {
 // Estimate connection quality based on various factors
 const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

 if (connection) {
 // Use Network Information API if available
 const effectiveType = connection.effectiveType;
 const downlink = connection.downlink;

 if (effectiveType === '4g' && downlink > 10) return 90;
 if (effectiveType === '4g' && downlink > 5) return 70;
 if (effectiveType === '3g') return 50;
 if (effectiveType === '2g') return 20;
 }

 // Fallback: assume good connection
 return 80;
 }

 // Performance monitoring and optimization
 startPerformanceMonitoring() {
 if (this.performanceMonitor) return;

 this.performanceMonitor = setInterval(() => {
 this.checkPerformanceMetrics();
 }, 10000); // Check every 10 seconds
 }

 stopPerformanceMonitoring() {
 if (this.performanceMonitor) {
 clearInterval(this.performanceMonitor);
 this.performanceMonitor = null;
 }
 }

 checkPerformanceMetrics() {
 if (!this.api || !this.isActive) return;

 try {
 // Monitor CPU usage (if available)
 if ('memory' in performance) {
 const memInfo = performance.memory;
 const memUsage = (memInfo.usedJSHeapSize / memInfo.totalJSHeapSize) * 100;

 if (memUsage > 80) {
 console.warn('High memory usage detected, optimizing video quality');
 this.api.executeCommand('setVideoQuality', 'low');
 }
 }

 // Monitor frame rate and adjust accordingly
 this.monitorFrameRate();

 } catch (error) {
 console.warn('Performance monitoring error:', error);
 }
 }

 monitorFrameRate() {
 // Simple frame rate monitoring
 if (!this.frameRateMonitor) {
 this.frameRateMonitor = {
 lastTime: performance.now(),
 frameCount: 0,
 fps: 0
 };
 }

 const now = performance.now();
 this.frameRateMonitor.frameCount++;

 if (now - this.frameRateMonitor.lastTime >= 1000) {
 this.frameRateMonitor.fps = this.frameRateMonitor.frameCount;
 this.frameRateMonitor.frameCount = 0;
 this.frameRateMonitor.lastTime = now;

 // Adjust quality based on frame rate
 if (this.frameRateMonitor.fps < 15 && this.participants.size > 2) {
 console.warn('Low frame rate detected, reducing video quality');
 this.api.executeCommand('setVideoQuality', 'low');
 }
 }

 requestAnimationFrame(() => this.monitorFrameRate());
 }

 // Optimize DOM updates for participant changes
 optimizeDOMUpdates() {
 // Debounce participant count updates
 if (this.updateTimeout) {
 clearTimeout(this.updateTimeout);
 }

 this.updateTimeout = setTimeout(() => {
 this.updateParticipantCount();
 this.optimizeBandwidth();
 }, 100);
 }

 // Smooth scrolling optimization for video container
 enableSmoothScrolling() {
 const videoContainer = document.getElementById('video-participants-container');
 if (!videoContainer) return;

 // Use CSS scroll behavior
 videoContainer.style.scrollBehavior = 'smooth';

 // Add momentum scrolling for iOS
 videoContainer.style.webkitOverflowScrolling = 'touch';

 // Optimize scroll performance
 let scrollTimeout;
 videoContainer.addEventListener('scroll', () => {
 if (scrollTimeout) {
 clearTimeout(scrollTimeout);
 }

 // Reduce rendering during scroll
 videoContainer.style.pointerEvents = 'none';

 scrollTimeout = setTimeout(() => {
 videoContainer.style.pointerEvents = 'auto';
 }, 150);
 });
 }
 }

 // Initialize video call manager
 const videoCallManager = new VideoCallManager();

 // --- Video Call Status Indicator Manager ---
 class VideoCallStatusIndicator {
     constructor() {
         this.statusContainer = document.getElementById('video-call-status-indicator');
         this.statusDot = document.getElementById('video-status-dot');
         this.statusText = document.getElementById('video-status-text');
         this.participantCount = document.getElementById('video-participant-count');

         this.remoteCallActive = false;
         this.remoteParticipantCount = 0;
         this.participantNames = new Map(); // userId -> userName
         this.tooltip = null; // Will be created dynamically

         this.initializeTooltip();
     }

     initializeTooltip() {
         if (!this.statusContainer) {
             console.log('Video call status container not found');
             return;
         }

         // Create tooltip element and append to body (same as users tooltip)
         const videoTooltip = document.createElement('div');
         videoTooltip.id = 'video-participants-tooltip';
         videoTooltip.className = 'fixed bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-600 rounded-xl shadow-xl p-5 min-w-72 max-w-96 opacity-0 pointer-events-none transition-all duration-300 ease-out scale-95';
         videoTooltip.style.zIndex = '999999';
         videoTooltip.innerHTML = `
             <!-- Tooltip arrow pointing up -->
             <div class="absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-white dark:border-b-slate-800"></div>
             <div class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-3">Video Call Participants</div>
             <div id="video-participants-list" class="space-y-2">
                 <!-- Participants will be populated here -->
             </div>
         `;

         // Append to body to escape all container constraints
         document.body.appendChild(videoTooltip);
         this.tooltip = videoTooltip;
         this.participantsList = document.getElementById('video-participants-list');

         let hoverTimeout;

         // Show tooltip on hover
         this.statusContainer.addEventListener('mouseenter', () => {
             clearTimeout(hoverTimeout);

             console.log('üñ±Ô∏è Mouse enter video status, remoteCallActive:', this.remoteCallActive, 'isActive:', videoCallManager.isActive);
             if (this.remoteCallActive || videoCallManager.isActive) {
                 // Update participants list before showing
                 this.updateParticipantsList();

                 // Calculate position for fixed positioning
                 const rect = this.statusContainer.getBoundingClientRect();
                 const tooltipLeft = rect.left + (rect.width / 2);
                 const tooltipTop = rect.bottom + 8; // 8px gap below the element

                 this.tooltip.style.left = `${tooltipLeft}px`;
                 this.tooltip.style.top = `${tooltipTop}px`;
                 this.tooltip.style.transform = 'translateX(-50%) scale(1)';
                 this.tooltip.style.opacity = '1';
                 this.tooltip.style.pointerEvents = 'auto';
             }
         });

         // Hide tooltip when leaving
         this.statusContainer.addEventListener('mouseleave', () => {
             console.log('üñ±Ô∏è Mouse leave video status');
             hoverTimeout = setTimeout(() => {
                 this.tooltip.style.opacity = '0';
                 this.tooltip.style.transform = 'translateX(-50%) scale(0.95)';
                 this.tooltip.style.pointerEvents = 'none';
             }, 150); // Small delay to prevent flickering
         });

         // Keep tooltip visible when hovering over it
         this.tooltip.addEventListener('mouseenter', () => {
             clearTimeout(hoverTimeout);
         });

         // Hide tooltip when leaving the tooltip itself
         this.tooltip.addEventListener('mouseleave', () => {
             this.tooltip.style.opacity = '0';
             this.tooltip.style.transform = 'translateX(-50%) scale(0.95)';
             this.tooltip.style.pointerEvents = 'none';
         });

         // Click to join video call if others are in call
         this.statusContainer.addEventListener('click', () => {
             if (currentRoomId && !videoCallManager.isActive && this.remoteCallActive) {
                 console.log('üñ±Ô∏è Clicked to join video call');
                 videoCallManager.startCall(currentRoomId);
             }
         });

         // Reposition tooltip on window resize if it's visible
         window.addEventListener('resize', () => {
             if (this.tooltip.style.opacity === '1') {
                 const rect = this.statusContainer.getBoundingClientRect();
                 const tooltipLeft = rect.left + (rect.width / 2);
                 const tooltipTop = rect.bottom + 8;

                 this.tooltip.style.left = `${tooltipLeft}px`;
                 this.tooltip.style.top = `${tooltipTop}px`;
             }
         });
     }

     show() {
         if (currentRoomId) {
             this.statusContainer.classList.remove('hidden');
         }
     }

     hide() {
         this.statusContainer.classList.add('hidden');
         // Hide tooltip if it's visible
         if (this.tooltip) {
             this.tooltip.style.opacity = '0';
             this.tooltip.style.transform = 'translateX(-50%) scale(0.95)';
             this.tooltip.style.pointerEvents = 'none';
         }
     }

     updateParticipantsList() {
         if (!this.participantsList) return;

         console.log('üìã Updating participants list:', {
             isLocalActive: videoCallManager.isActive,
             remoteParticipants: Array.from(this.participantNames.entries()),
             participantCount: this.participantNames.size
         });

         // Clear existing participants
         this.participantsList.innerHTML = '';

         // Add local user if in call
         if (videoCallManager.isActive) {
             const userName = localStorage.getItem('userName') || 'Anonymous';
             const userItem = document.createElement('div');
             userItem.className = 'flex items-center space-x-3 p-2 rounded-lg bg-green-50 dark:bg-green-900/20';
             userItem.innerHTML = `
                 <div class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white text-xs font-semibold">
                     ${userName.charAt(0).toUpperCase()}
                 </div>
                 <div class="flex-1 min-w-0">
                     <div class="text-sm font-medium text-green-700 dark:text-green-300">${userName} (You)</div>
                     <div class="text-xs text-green-600 dark:text-green-400">In video call</div>
                 </div>
                 <div class="w-2 h-2 rounded-full bg-green-500"></div>
             `;
             this.participantsList.appendChild(userItem);
         }

         // Add remote participants
         for (const [userId, userName] of this.participantNames) {
             const userItem = document.createElement('div');
             userItem.className = 'flex items-center space-x-3 p-2 rounded-lg bg-blue-50 dark:bg-blue-900/20';
             userItem.innerHTML = `
                 <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs font-semibold">
                     ${userName.charAt(0).toUpperCase()}
                 </div>
                 <div class="flex-1 min-w-0">
                     <div class="text-sm font-medium text-blue-700 dark:text-blue-300">${userName}</div>
                     <div class="text-xs text-blue-600 dark:text-blue-400">In video call</div>
                 </div>
                 <div class="w-2 h-2 rounded-full bg-blue-500"></div>
             `;
             this.participantsList.appendChild(userItem);
         }

         // Show message if no participants
         if (this.participantsList.children.length === 0) {
             const emptyItem = document.createElement('div');
             emptyItem.className = 'text-center text-slate-500 dark:text-slate-400 py-4';
             emptyItem.textContent = 'No participants in video call';
             this.participantsList.appendChild(emptyItem);
         }

         console.log('üìã Participants list updated with', this.participantsList.children.length, 'items');
     }

     reset() {
         this.participantNames.clear();
         this.remoteCallActive = false;
         this.remoteParticipantCount = 0;
     }

     updateStatus(isLocalActive, isRemoteActive, participantCount) {
         this.remoteCallActive = isRemoteActive;

         // Calculate total participants
         let totalParticipants = this.remoteParticipantCount;
         if (isLocalActive) {
             totalParticipants += 1; // Add local user
         }

         console.log('üìä Video status indicator update:', {
             isLocalActive,
             isRemoteActive,
             participantCount,
             remoteParticipantCount: this.remoteParticipantCount,
             totalParticipants,
             participantNames: Array.from(this.participantNames.entries())
         });

         // Update status based on video call activity
         if (isLocalActive) {
             // User is in video call
             this.statusDot.className = 'w-2 h-2 rounded-full bg-green-500';
             this.statusText.textContent = 'In Call';
             this.participantCount.textContent = totalParticipants;
             this.statusContainer.style.cursor = 'default';
             this.statusContainer.title = 'You are in the video call - hover to see participants';
             this.show();

         } else if (isRemoteActive && this.remoteParticipantCount > 0) {
             // Others are in video call, user is not
             this.statusDot.className = 'w-2 h-2 rounded-full bg-orange-500 animate-pulse';
             this.statusText.textContent = 'Video Call';
             this.participantCount.textContent = this.remoteParticipantCount;
             this.statusContainer.style.cursor = 'pointer';
             this.statusContainer.title = 'Click to join video call - hover to see participants';
             this.show();

         } else {
             // No video call active
             this.statusDot.className = 'w-2 h-2 rounded-full bg-gray-400';
             this.statusText.textContent = 'No Video';
             this.participantCount.textContent = '0';
             this.statusContainer.style.cursor = 'default';
             this.statusContainer.title = '';
             this.hide();
         }

     }

     addParticipant(userId, userName) {
         this.participantNames.set(userId, userName);
         this.remoteParticipantCount = this.participantNames.size;
         this.remoteCallActive = this.remoteParticipantCount > 0;
     }

     removeParticipant(userId) {
         this.participantNames.delete(userId);
         this.remoteParticipantCount = this.participantNames.size;
         this.remoteCallActive = this.remoteParticipantCount > 0;
     }

     onRoomJoined() {
         this.reset();
         this.updateStatus(videoCallManager.isActive, this.remoteCallActive, this.remoteParticipantCount);
     }

     onRoomLeft() {
         this.hide();
         this.reset();
     }
 }

 // Initialize video call status indicator
 const videoCallStatusIndicator = new VideoCallStatusIndicator();

 // Add global debug function for video call state
 window.debugVideoCall = () => {
 const state = videoCallManager.getCallState();
 console.log('=== Video Call Debug State ===');
 console.log(state);
 console.log('Local Stream Tracks:', localStream ? localStream.getTracks().map(t => `${t.kind} (${t.readyState})`) : 'No local stream');
 console.log('Peer Connection States:');
 for (const [userId, pc] of peerConnections) {
 console.log(`  ${userId}: ${pc.connectionState} (ice: ${pc.iceConnectionState})`);
 }
 return state;
 };

 // --- Text Formatting Palette ---
 const textInspector = document.createElement('div');
 textInspector.className =
 'fixed z-50 bg-white dark:bg-slate-800 shadow-lg rounded-xl p-3 flex gap-2 items-center border border-gray-200 dark:border-gray-600';
 textInspector.style.display = 'none';
 document.body.appendChild(textInspector);

 // Helper functions for text inspector
 const fonts = ['Inter', 'Roboto', 'IBM Plex Mono', 'Georgia', 'Times New Roman', 'Arial', 'Helvetica'];
 const sizes = [12, 14, 16, 18, 20, 24, 28, 32, 40, 48];

 function makeSelect(opts, handler, currentValue) {
 const sel = document.createElement('select');
 sel.className = 'px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-slate-700 text-gray-900 dark:text-gray-100';
 opts.forEach(v => {
 const o = document.createElement('option');
 o.value = o.text = v;
 if (v === currentValue) o.selected = true;
 sel.appendChild(o);
 });
 sel.onchange = () => handler(sel.value);
 return sel;
 }

 function applyToSelection(props) {
 const ao = fabricCanvas.getActiveObject();
 if (ao && ao.type === 'i-text') {
 ao.set(props);
 fabricCanvas.renderAll();
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üìù Broadcasting text style change:', ao.id, props);
 sendCanvasOperation('object_modified', {
 object_id: ao.id,
 object: ao.toObject()
 });
 }
 }
 }

 // Create text inspector controls
 const fontSelect = makeSelect(fonts, v => applyToSelection({ fontFamily: v }));
 const sizeSelect = makeSelect(sizes, v => applyToSelection({ fontSize: parseInt(v, 10) }));

 const colorInput = document.createElement('input');
 colorInput.type = 'color';
 colorInput.className = 'w-8 h-8 border border-gray-300 dark:border-gray-600 rounded cursor-pointer';
 colorInput.oninput = () => applyToSelection({ fill: colorInput.value });

 const boldButton = document.createElement('button');
 boldButton.innerHTML = '<strong>B</strong>';
 boldButton.className = 'px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-slate-700 text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-slate-600';
 boldButton.onclick = () => {
 const ao = fabricCanvas.getActiveObject();
 if (ao && ao.type === 'i-text') {
 const newWeight = ao.fontWeight === 'bold' ? 'normal' : 'bold';
 applyToSelection({ fontWeight: newWeight });
 boldButton.style.backgroundColor = newWeight === 'bold' ? '#3b82f6' : '';
 boldButton.style.color = newWeight === 'bold' ? 'white' : '';
 }
 };

 const italicButton = document.createElement('button');
 italicButton.innerHTML = '<em>I</em>';
 italicButton.className = 'px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-slate-700 text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-slate-600';
 italicButton.onclick = () => {
 const ao = fabricCanvas.getActiveObject();
 if (ao && ao.type === 'i-text') {
 const newStyle = ao.fontStyle === 'italic' ? 'normal' : 'italic';
 applyToSelection({ fontStyle: newStyle });
 italicButton.style.backgroundColor = newStyle === 'italic' ? '#3b82f6' : '';
 italicButton.style.color = newStyle === 'italic' ? 'white' : '';
 }
 };

 textInspector.append(fontSelect, sizeSelect, colorInput, boldButton, italicButton);

 // Mobile and responsive handling
 class MobileVideoHandler {
 constructor() {
 this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
 this.isTablet = /iPad|Android/i.test(navigator.userAgent) && window.innerWidth > 768;
 this.setupMobileHandling();
 }

 setupMobileHandling() {
 // Handle orientation changes
 window.addEventListener('orientationchange', () => {
 setTimeout(() => {
 this.handleOrientationChange();
 }, 100);
 });

 // Handle viewport changes
 window.addEventListener('resize', () => {
 this.handleViewportChange();
 });

 // Handle touch interactions for video container
 this.setupTouchInteractions();

 // Optimize for mobile performance
 if (this.isMobile) {
 this.optimizeForMobile();
 }
 }

 handleOrientationChange() {
 const videoContainer = document.getElementById('video-call-container');
 const jitsiContainer = document.getElementById('jitsi-meet-container');

 if (!videoContainer || videoContainer.classList.contains('hidden')) return;

 const isLandscape = window.innerHeight < window.innerWidth;
 const isSmallScreen = window.innerHeight < 500;

 if (isLandscape && isSmallScreen) {
 // Landscape mode on small screens - minimize video
 videoContainer.style.maxHeight = '150px';
 if (jitsiContainer) {
 jitsiContainer.style.height = '90px';
 jitsiContainer.style.minHeight = '90px';
 }
 } else {
 // Portrait or larger screens - normal size
 if (this.isMobile) {
 videoContainer.style.maxHeight = window.innerWidth < 480 ? '200px' : '250px';
 if (jitsiContainer) {
 const height = window.innerWidth < 480 ? '140px' : '190px';
 jitsiContainer.style.height = height;
 jitsiContainer.style.minHeight = height;
 }
 }
 }

 // Recalculate canvas offset after orientation change
 setTimeout(() => {
 if (typeof fabricCanvas !== 'undefined') {
 fabricCanvas.calcOffset();
 }
 }, 300);
 }

 handleViewportChange() {
 // Adjust video container size based on viewport
 const videoContainer = document.getElementById('video-call-container');
 if (!videoContainer || videoContainer.classList.contains('hidden')) return;

 const viewportHeight = window.innerHeight;
 const maxVideoHeight = Math.min(300, viewportHeight * 0.4);

 videoContainer.style.maxHeight = maxVideoHeight + 'px';
 }

 setupTouchInteractions() {
 const videoResizeHandle = document.getElementById('video-resize-handle');
 if (!videoResizeHandle) return;

 // Make resize handle more touch-friendly on mobile
 if (this.isMobile) {
 videoResizeHandle.style.height = '12px';
 videoResizeHandle.style.opacity = '0.7';
 }

 // Add touch feedback
 videoResizeHandle.addEventListener('touchstart', (e) => {
 videoResizeHandle.style.backgroundColor = '#6366f1';
 e.preventDefault();
 });

 videoResizeHandle.addEventListener('touchend', () => {
 videoResizeHandle.style.backgroundColor = '';
 });
 }

 optimizeForMobile() {
 // Reduce video quality on mobile for better performance
 if (videoCallManager.api && videoCallManager.isActive) {
 try {
 videoCallManager.api.executeCommand('setVideoQuality', 'low');
 console.log('Optimized video quality for mobile');
 } catch (error) {
 console.warn('Failed to optimize video quality for mobile:', error);
 }
 }

 // Disable some features on mobile for better performance
 // Screen share functionality removed
 }

 // Check if device supports video calling
 checkMobileVideoSupport() {
 if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
 return false;
 }

 // Check for WebRTC support
 if (!window.RTCPeerConnection) {
 return false;
 }

 return true;
 }

 // Handle mobile-specific video call errors
 handleMobileVideoError(error) {
 if (this.isMobile) {
 // Mobile-specific error messages
 const mobileErrors = {
 'NotAllowedError': 'Please allow camera and microphone access in your browser settings.',
 'NotFoundError': 'Camera or microphone not found. Please check your device.',
 'NotReadableError': 'Camera or microphone is being used by another app.',
 'OverconstrainedError': 'Camera or microphone constraints cannot be satisfied.',
 'SecurityError': 'Camera or microphone access blocked due to security restrictions.'
 };

 const errorMessage = mobileErrors[error.name] || 'Video call failed on mobile device.';
 alert(errorMessage);
 }
 }
 }

 // Initialize mobile handler
 const mobileVideoHandler = new MobileVideoHandler();
 if (!fabricCanvas.freeDrawingBrush) {
 fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
 }
 fabricCanvas.freeDrawingBrush.color = colorPicker.value;
 fabricCanvas.freeDrawingBrush.width = parseInt(brushSizeSlider.value, 10);

 // üöÄ MOBILE OPTIMIZATION: Brush point decimation for better performance
 if (fabricCanvas.freeDrawingBrush) {
 fabricCanvas.freeDrawingBrush.decimate = isCoarse ? 6 : 2; // Aggressive decimation on mobile
 console.log(`üñåÔ∏è Brush decimation set to: ${fabricCanvas.freeDrawingBrush.decimate} (${isCoarse ? 'Mobile' : 'Desktop'})`);
 }

 // ===================================================================
 // UNDO/REDO COMMAND SYSTEM
 // ===================================================================

 /**
  * Base Command class for the Command Pattern implementation
  * All canvas operations should extend this class to support undo/redo
  */
 class Command {
     constructor(description = 'Unknown Command') {
         this.description = description;
         this.timestamp = Date.now();
         this.id = `cmd_${this.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
     }

     /**
      * Execute the command - must be implemented by subclasses
      */
     execute() {
         throw new Error('execute() method must be implemented by subclasses');
     }

     /**
      * Undo the command - must be implemented by subclasses
      */
     undo() {
         throw new Error('undo() method must be implemented by subclasses');
     }

     /**
      * Check if this command can be undone
      */
     canUndo() {
         return true;
     }

     /**
      * Get a description of this command for debugging
      */
     toString() {
         return `${this.description} (${this.id})`;
     }
 }

 /**
  * Command History Manager
  * Manages the undo/redo stack with configurable limits
  */
 class CommandHistory {
     constructor(maxHistorySize = 50) {
         this.undoStack = [];
         this.redoStack = [];
         this.maxHistorySize = maxHistorySize;
         this.isExecuting = false;
     }

     /**
      * Execute a command and add it to the history
      */
     executeCommand(command) {
         if (!command) {
             console.warn('‚ö†Ô∏è Cannot execute null/undefined command');
             return false;
         }

         if (this.isExecuting) {
             console.warn('Command execution already in progress, skipping:', command.toString());
             return false;
         }

         try {
             this.isExecuting = true;
             isExecutingCommand = true;

             console.log('üîÑ Executing command:', command.toString());
             command.execute();

             // Add to undo stack
             this.undoStack.push(command);

             // Clear redo stack when new command is executed
             this.redoStack = [];

             // Maintain stack size limit
             if (this.undoStack.length > this.maxHistorySize) {
                 this.undoStack.shift();
             }

             this.updateUI();
             console.log('‚úÖ Command executed successfully:', command.toString());
             return true;

         } catch (error) {
             console.error('‚ùå Command execution failed:', command.toString(), error);
             // Don't add failed commands to history
             return false;
         } finally {
             this.isExecuting = false;
             isExecutingCommand = false;
         }
     }

     /**
      * Undo the last command
      */
     undo() {
         if (this.undoStack.length === 0) {
             console.log('üì≠ No commands to undo');
             return false;
         }

         if (this.isExecuting) {
             console.warn('Command execution in progress, cannot undo');
             return false;
         }

         try {
             this.isExecuting = true;
             isExecutingCommand = true;

             const command = this.undoStack.pop();
             console.log('‚Ü©Ô∏è Undoing command:', command.toString());

             if (command.canUndo()) {
                 console.log('üìä Canvas objects before undo:', fabricCanvas.getObjects().length);
                 command.undo();
                 console.log('üìä Canvas objects after undo:', fabricCanvas.getObjects().length);
                 this.redoStack.push(command);
                 console.log('üìä Redo stack length after undo:', this.redoStack.length);
                 this.updateUI();
                 console.log('‚úÖ Command undone successfully:', command.toString());
                 return true;
             } else {
                 console.warn('‚ö†Ô∏è Command cannot be undone:', command.toString());
                 this.undoStack.push(command); // Put it back
                 return false;
             }

         } catch (error) {
             console.error('‚ùå Undo failed:', error);
             return false;
         } finally {
             this.isExecuting = false;
             isExecutingCommand = false;
         }
     }

     /**
      * Redo the last undone command
      */
     redo() {
         if (this.redoStack.length === 0) {
             console.log('üì≠ No commands to redo');
             return false;
         }

         if (this.isExecuting) {
             console.warn('Command execution in progress, cannot redo');
             return false;
         }

         try {
             this.isExecuting = true;
             isExecutingCommand = true;

             const command = this.redoStack.pop();
             console.log('‚Ü™Ô∏è Redoing command:', command.toString());
             console.log('üìä Canvas objects before redo:', fabricCanvas.getObjects().length);

             command.execute();
             this.undoStack.push(command);

             console.log('üìä Canvas objects after redo:', fabricCanvas.getObjects().length);
             this.updateUI();
             console.log('‚úÖ Command redone successfully:', command.toString());
             return true;

         } catch (error) {
             console.error('‚ùå Redo failed:', error);
             return false;
         } finally {
             this.isExecuting = false;
             isExecutingCommand = false;
         }
     }

     /**
      * Clear all command history
      */
     clear() {
         this.undoStack = [];
         this.redoStack = [];
         this.updateUI();
         console.log('üóëÔ∏è Command history cleared');
     }

     /**
      * Check if undo is available
      */
     canUndo() {
         return this.undoStack.length > 0 && !this.isExecuting;
     }

     /**
      * Check if redo is available
      */
     canRedo() {
         return this.redoStack.length > 0 && !this.isExecuting;
     }

     /**
      * Update UI buttons state
      */
     updateUI() {
         try {
             // Update undo button
             const undoBtn = document.getElementById('undo-btn');
             if (undoBtn) {
                 undoBtn.disabled = !this.canUndo();
                 undoBtn.title = this.canUndo()
                     ? `Undo: ${this.undoStack[this.undoStack.length - 1]?.description || 'Last Action'} (Ctrl+Z)`
                     : 'Nothing to undo (Ctrl+Z)';
             }

             // Update redo button
             const redoBtn = document.getElementById('redo-btn');
             if (redoBtn) {
                 redoBtn.disabled = !this.canRedo();
                 redoBtn.title = this.canRedo()
                     ? `Redo: ${this.redoStack[this.redoStack.length - 1]?.description || 'Last Undone Action'} (Ctrl+Y)`
                     : 'Nothing to redo (Ctrl+Y)';
             }
         } catch (error) {
             console.warn('‚ö†Ô∏è Error updating undo/redo UI:', error);
         }
     }

     /**
      * Get debug information about the command history
      */
     getDebugInfo() {
         return {
             undoStackSize: this.undoStack.length,
             redoStackSize: this.redoStack.length,
             canUndo: this.canUndo(),
             canRedo: this.canRedo(),
             isExecuting: this.isExecuting,
             lastCommand: this.undoStack[this.undoStack.length - 1]?.toString(),
             nextRedoCommand: this.redoStack[this.redoStack.length - 1]?.toString()
         };
     }
 }

 // ===================================================================
 // DRAWING COMMAND CLASSES
 // ===================================================================

 /**
  * Command for adding objects to the canvas (shapes, text, images, etc.)
  */
 class AddObjectCommand extends Command {
     constructor(object, description = 'Add Object') {
         super(description);
         this.objectData = object.toObject ? object.toObject() : object;
         this.objectId = object.id || generateObjectId();
         this.object = object;
     }

     execute() {
         try {
             // If object is not on canvas, add it
             const existingObj = fabricCanvas.getObjects().find(obj => obj.id === this.objectId);
             if (!existingObj) {
                 if (this.object && this.object.canvas !== fabricCanvas) {
                     this.object.id = this.objectId;
                     fabricCanvas.add(this.object);
                     fabricCanvas.renderAll();
                 } else {
                     // Recreate object from data
                     fabric.util.enlivenObjects([this.objectData], (objects) => {
                         if (objects && objects[0]) {
                             objects[0].id = this.objectId;
                             fabricCanvas.add(objects[0]);
                             fabricCanvas.renderAll();
                         }
                     });
                 }
             }
         } catch (error) {
             console.error('‚ùå Error executing AddObjectCommand:', error);
             throw error;
         }
     }

     undo() {
         try {
             const objToRemove = fabricCanvas.getObjects().find(obj => obj.id === this.objectId);
             if (objToRemove) {
                 // Clear control points if this is an arrow being removed
                 if (objToRemove.type === 'arrow' && selectedLineForEditing === objToRemove) {
                     clearControlPoints();
                     selectedLineForEditing = null;
                 }

                 fabricCanvas.remove(objToRemove);
                 fabricCanvas.renderAll();
                 console.log('‚úÖ Removed object via undo:', objToRemove.type, objToRemove.id);
             } else {
                 console.warn('‚ö†Ô∏è Object not found for undo removal. ID:', this.objectId);
             }
         } catch (error) {
             console.error('‚ùå Error undoing AddObjectCommand:', error);
             throw error;
         }
     }
 }

 /**
  * Command for removing objects from the canvas
  */
 class RemoveObjectCommand extends Command {
     constructor(object, description = 'Remove Object') {
         super(description);
         this.objectData = object.toObject();
         this.objectId = object.id;
         this.object = object;

         // Store exact positioning data
         this.positioning = {
             left: object.left,
             top: object.top,
             scaleX: object.scaleX,
             scaleY: object.scaleY,
             angle: object.angle,
             flipX: object.flipX,
             flipY: object.flipY,
             skewX: object.skewX,
             skewY: object.skewY,
             originX: object.originX,
             originY: object.originY
         };
     }

     execute() {
         const objToRemove = fabricCanvas.getObjects().find(obj => obj.id === this.objectId);
         if (objToRemove) {
             fabricCanvas.remove(objToRemove);
             fabricCanvas.renderAll();
         }
     }

     undo() {
         try {
             // Recreate object from stored data with exact positioning
             fabric.util.enlivenObjects([this.objectData], (objects) => {
                 if (objects && objects[0]) {
                     const obj = objects[0];

                     // Restore exact positioning
                     obj.set({
                         id: this.objectId,
                         left: this.positioning.left,
                         top: this.positioning.top,
                         scaleX: this.positioning.scaleX,
                         scaleY: this.positioning.scaleY,
                         angle: this.positioning.angle,
                         flipX: this.positioning.flipX,
                         flipY: this.positioning.flipY,
                         skewX: this.positioning.skewX,
                         skewY: this.positioning.skewY,
                         originX: this.positioning.originX,
                         originY: this.positioning.originY
                     });

                     obj.setCoords(); // Update object coordinates
                     fabricCanvas.add(obj);
                     fabricCanvas.setActiveObject(obj); // Select the restored object

                     // If this is an arrow, clear any existing control points first
                     if (obj.type === 'arrow') {
                         clearControlPoints();
                         selectedLineForEditing = null;
                     }

                     fabricCanvas.renderAll();

                     console.log(`üìç Restored ${obj.type} to exact position (${this.positioning.left}, ${this.positioning.top})`);
                 }
             });
         } catch (error) {
             console.error('‚ùå Error undoing RemoveObjectCommand:', error);
             throw error;
         }
     }
 }

 /**
  * Command for modifying object properties (move, resize, rotate, style changes)
  */
 class ModifyObjectCommand extends Command {
     constructor(object, oldProperties, newProperties, description = 'Modify Object') {
         super(description);
         this.objectId = object.id;
         this.oldProperties = { ...oldProperties };
         this.newProperties = { ...newProperties };
     }

     execute() {
         const obj = fabricCanvas.getObjects().find(obj => obj.id === this.objectId);
         if (obj) {
             obj.set(this.newProperties);
             obj.setCoords();
             fabricCanvas.renderAll();
         }
     }

     undo() {
         const obj = fabricCanvas.getObjects().find(obj => obj.id === this.objectId);
         if (obj) {
             obj.set(this.oldProperties);
             obj.setCoords();
             fabricCanvas.renderAll();
         }
     }
 }

 /**
  * Command for drawing paths (pen strokes)
  */
 class AddPathCommand extends Command {
     constructor(path, description = 'Draw Path') {
         super(description);
         this.pathData = path.toObject();
         this.pathId = path.id || generateObjectId();
         this.path = path;
     }

     execute() {
         const existingPath = fabricCanvas.getObjects().find(obj => obj.id === this.pathId);
         if (!existingPath) {
             if (this.path && this.path.canvas !== fabricCanvas) {
                 this.path.id = this.pathId;
                 fabricCanvas.add(this.path);
             } else {
                 // Recreate path from data
                 fabric.util.enlivenObjects([this.pathData], (objects) => {
                     if (objects && objects[0]) {
                         objects[0].id = this.pathId;
                         fabricCanvas.add(objects[0]);
                         fabricCanvas.renderAll();
                     }
                 });
             }
             fabricCanvas.renderAll();
         }
     }

     undo() {
         const pathToRemove = fabricCanvas.getObjects().find(obj => obj.id === this.pathId);
         if (pathToRemove) {
             fabricCanvas.remove(pathToRemove);
             fabricCanvas.renderAll();
         }
     }
 }

 /**
  * Command for batch operations (multiple objects at once)
  */
 class BatchCommand extends Command {
     constructor(commands, description = 'Batch Operation') {
         super(description);
         this.commands = commands || [];
     }

     execute() {
         try {
             for (const command of this.commands) {
                 command.execute();
             }
         } catch (error) {
             console.error('‚ùå Error executing BatchCommand:', error);
             throw error;
         }
     }

     undo() {
         try {
             // Undo in reverse order
             for (let i = this.commands.length - 1; i >= 0; i--) {
                 this.commands[i].undo();
             }
         } catch (error) {
             console.error('‚ùå Error undoing BatchCommand:', error);
             throw error;
         }
     }

     canUndo() {
         return this.commands.every(cmd => cmd.canUndo());
     }
 }

 /**
  * Command for removing multiple objects from the canvas
  */
 class RemoveMultipleObjectsCommand extends Command {
     constructor(objects, description = 'Remove Multiple Objects') {
         super(description);
         this.objectsData = [];

         // Store each object's complete data including exact positioning
         objects.forEach((obj, index) => {
             // Get the object data but ensure positioning is preserved
             const objectData = obj.toObject(['id']); // Include ID in serialization

             // Store comprehensive positioning data
             this.objectsData.push({
                 data: objectData,
                 id: obj.id || generateObjectId(),
                 index: fabricCanvas.getObjects().indexOf(obj), // Store original position in canvas
                 // Store exact positioning data (absolute values)
                 left: obj.left,
                 top: obj.top,
                 scaleX: obj.scaleX || 1,
                 scaleY: obj.scaleY || 1,
                 angle: obj.angle || 0,
                 flipX: obj.flipX || false,
                 flipY: obj.flipY || false,
                 skewX: obj.skewX || 0,
                 skewY: obj.skewY || 0,
                 originX: obj.originX || 'left',
                 originY: obj.originY || 'top',
                 // Store additional properties that might affect positioning
                 width: obj.width,
                 height: obj.height,
                 radius: obj.radius, // For circles
                 // Store selection state if it was part of a group
                 wasSelected: fabricCanvas.getActiveObjects().includes(obj)
             });
         });

         // Sort by index to maintain proper order during restoration
         this.objectsData.sort((a, b) => a.index - b.index);

         console.log('üì¶ Stored', this.objectsData.length, 'objects for removal with exact positioning');
         this.objectsData.forEach(data => {
             console.log(`  - ${data.data.type} at (${data.left}, ${data.top})`);
         });
     }

     execute() {
         try {
             // Remove all objects
             this.objectsData.forEach(objData => {
                 const objToRemove = fabricCanvas.getObjects().find(obj => obj.id === objData.id);
                 if (objToRemove) {
                     fabricCanvas.remove(objToRemove);
                 }
             });
             fabricCanvas.discardActiveObject();
             fabricCanvas.renderAll();
         } catch (error) {
             console.error('‚ùå Error executing RemoveMultipleObjectsCommand:', error);
             throw error;
         }
     }

     undo() {
         try {
             console.log('üîÑ Restoring', this.objectsData.length, 'objects to exact positions...');

             // Restore objects one by one to ensure proper positioning
             const objectsToAdd = [];
             let processedCount = 0;

             // Process each object individually to avoid positioning issues
             this.objectsData.forEach((storedData, index) => {
                 fabric.util.enlivenObjects([storedData.data], (objects) => {
                     if (objects && objects[0]) {
                         const obj = objects[0];

                         // Set the ID first
                         obj.id = storedData.id;

                         // Force exact positioning - set each property individually
                         obj.left = storedData.left;
                         obj.top = storedData.top;
                         obj.scaleX = storedData.scaleX;
                         obj.scaleY = storedData.scaleY;
                         obj.angle = storedData.angle;
                         obj.flipX = storedData.flipX;
                         obj.flipY = storedData.flipY;
                         obj.skewX = storedData.skewX;
                         obj.skewY = storedData.skewY;
                         obj.originX = storedData.originX;
                         obj.originY = storedData.originY;

                         // Update coordinates after setting position
                         obj.setCoords();

                         // Add to canvas immediately
                         fabricCanvas.add(obj);

                         objectsToAdd.push({
                             obj: obj,
                             index: storedData.index,
                             wasSelected: storedData.wasSelected
                         });

                         console.log(`üìç Restored ${obj.type} to position (${obj.left}, ${obj.top})`);

                         processedCount++;

                         // When all objects are processed, handle selection
                         if (processedCount === this.objectsData.length) {
                             // Sort by original index to maintain layer order
                             objectsToAdd.sort((a, b) => a.index - b.index);

                             // Reorder objects on canvas if needed
                             objectsToAdd.forEach((item, idx) => {
                                 const currentIndex = fabricCanvas.getObjects().indexOf(item.obj);
                                 if (currentIndex !== item.index && item.index < fabricCanvas.getObjects().length) {
                                     fabricCanvas.moveTo(item.obj, item.index);
                                 }
                             });

                             // Select all restored objects that were originally selected
                             const objectsToSelect = objectsToAdd.filter(item => item.wasSelected).map(item => item.obj);

                             if (objectsToSelect.length > 1) {
                                 // Create selection without affecting positioning
                                 const selection = new fabric.ActiveSelection(objectsToSelect, {
                                     canvas: fabricCanvas,
                                 });
                                 fabricCanvas.setActiveObject(selection);
                                 console.log('‚úÖ Restored selection of', objectsToSelect.length, 'objects');
                             } else if (objectsToSelect.length === 1) {
                                 fabricCanvas.setActiveObject(objectsToSelect[0]);
                                 console.log('‚úÖ Restored selection of single object');
                             }

                             fabricCanvas.renderAll();
                             console.log('‚úÖ All objects restored to exact positions');
                         }
                     }
                 });
             });
         } catch (error) {
             console.error('‚ùå Error undoing RemoveMultipleObjectsCommand:', error);
             throw error;
         }
     }
 }

 /**
  * Command for clearing the entire canvas
  */
 class ClearCanvasCommand extends Command {
     constructor(description = 'Clear Canvas') {
         super(description);
         this.savedObjects = [];
         this.savedBackground = fabricCanvas.backgroundColor;

         // Store all current objects
         fabricCanvas.getObjects().forEach(obj => {
             this.savedObjects.push({
                 data: obj.toObject(),
                 id: obj.id
             });
         });
     }

     execute() {
         fabricCanvas.clear();
         fabricCanvas.setBackgroundColor('#ffffff');
         fabricCanvas.renderAll();
     }

     undo() {
         fabricCanvas.clear();
         fabricCanvas.setBackgroundColor(this.savedBackground);

         // Restore all objects
         if (this.savedObjects.length > 0) {
             const objectsData = this.savedObjects.map(item => item.data);
             fabric.util.enlivenObjects(objectsData, (objects) => {
                 objects.forEach((obj, index) => {
                     if (obj && this.savedObjects[index]) {
                         obj.id = this.savedObjects[index].id;
                         fabricCanvas.add(obj);
                     }
                 });
                 fabricCanvas.renderAll();
             });
         } else {
             fabricCanvas.renderAll();
         }
     }
 }

 /**
  * Command for text editing changes (content, style, etc.)
  */
 class TextEditCommand extends Command {
     constructor(textObject, oldProperties, newProperties, description = 'Edit Text') {
         super(description);
         this.textId = textObject.id;
         this.oldProperties = { ...oldProperties };
         this.newProperties = { ...newProperties };
     }

     execute() {
         const textObj = fabricCanvas.getObjects().find(obj => obj.id === this.textId);
         if (textObj) {
             textObj.set(this.newProperties);
             textObj.setCoords();
             fabricCanvas.renderAll();
         }
     }

     undo() {
         const textObj = fabricCanvas.getObjects().find(obj => obj.id === this.textId);
         if (textObj) {
             textObj.set(this.oldProperties);
             textObj.setCoords();
             fabricCanvas.renderAll();
         }
     }
 }

 // ===================================================================
 // END DRAWING COMMAND CLASSES
 // ===================================================================

 // ===================================================================
 // END UNDO/REDO COMMAND SYSTEM
 // ===================================================================

 // --- Tool State Management ---
 function resetAllToolStates() {
 // Reset all tool-specific states
 isAddingText = false;
 isDrawingHighlight = false;
 isDrawingShape = false;

 // Reset Pan Mode if active
 if (isPanModeActive) {
     isPanModeActive = false;
     canvasParent.style.cursor = '';
     console.log('‚úÖ Pan Mode deactivated by tool selection');
 }

 // Reset canvas states
 fabricCanvas.selection = true;
 fabricCanvas.isDrawingMode = false;

 // Restore object selectability
 fabricCanvas.getObjects().forEach(obj => {
 obj.selectable = true;
 obj.evented = true;
 });

 console.log('üîÑ All tool states reset');
 }

 // --- Tool Selection Visuals ---
 function setActiveToolButton(selectedButton) {
 console.log('üîÑ setActiveToolButton called with:', selectedButton?.id || 'null');
 console.log('üìã All tool buttons:', allToolButtons.filter(btn => btn).map(btn => btn.id));

 // Remove active state from ALL toolbar buttons (more comprehensive)
 document.querySelectorAll('.toolbar-button').forEach(btn => {
     btn.classList.remove('active-tool', 'active');
 });

 // Also remove from the specific allToolButtons array
 allToolButtons.forEach(btn => {
     if (btn) {
         btn.classList.remove('active-tool', 'active');
         console.log('üîπ Removed active-tool from:', btn.id);
     }
 });

 if (selectedButton) {
     selectedButton.classList.add('active-tool');
     console.log('üî∏ Added active-tool to:', selectedButton.id);
     updateToolIndicator(selectedButton);
 }
 }

 // Update the selected tool indicator
 function updateToolIndicator(button) {
 const toolIcon = document.getElementById('tool-icon');
 const toolName = document.getElementById('tool-name');

 if (!button) {
 console.warn('‚ö†Ô∏è updateToolIndicator called with no button');
 return;
 }

 console.log('üéØ Updating tool indicator to:', button.id);

 // Get the SVG icon from the button
 const buttonSvg = button.querySelector('svg');
 if (buttonSvg) {
 toolIcon.innerHTML = buttonSvg.outerHTML;
 } else {
 console.warn('‚ö†Ô∏è No SVG found in button:', button.id);
 }

 // Update tool name based on button ID
 const toolNames = {
 'pen-tool': 'Pen',
 'line-tool': 'Line',
 'arrow-tool': 'Arrow',
 'circle-tool': 'Circle',
 'rectangle-tool': 'Rectangle',
 'highlighter-rect-tool': 'Highlight Rect',
 'highlighter-circle-tool': 'Highlight Circle',
 'text-tool': 'Text',
 'select-tool': 'Select',
 'pan-mode-tool': 'Pan Mode'
 };

 const toolName_text = toolNames[button.id] || 'Unknown';
 toolName.textContent = toolName_text;

 console.log('‚úÖ Tool indicator updated to:', toolName_text);
 }
 setActiveToolButton(penToolButton); // Default active tool

 // --- Keyboard Shortcuts for Drawing Tools ---
 const toolShortcuts = {
 '1': penToolButton,
 '2': lineToolButton,
 '3': arrowToolButton,
 '4': circleToolButton,
 '5': rectangleToolButton,
 '6': highlighterRectButton,
 '7': highlighterCircleButton,
 '8': textToolButton,
 '9': selectToolButton
 };

 // Function to check if user is typing in an input field
 function isTypingInInputField() {
 const activeElement = document.activeElement;
 if (!activeElement) return false;

 const tagName = activeElement.tagName.toLowerCase();
 const inputTypes = ['input', 'textarea', 'select'];
 const editableElements = activeElement.contentEditable === 'true';

 // Check for specific input fields that should disable shortcuts
 const inputIds = [
 'chat-input', // AI chat
 'group-message-input', // Group messaging
 'room-name-input', // Room creation
 'room-id-input', // Room joining
 'user-name-input', // User name input
 'custom-api-key', // AI settings API key (updated ID)
 'ai-model-select', // AI model selection
 'pdf-page-input', // PDF page navigation
 'zoom-level-input' // Zoom input
 ];

 // Check for Jupyter notebook cells
 const isJupyterCell = activeElement.closest('.jupyter-cell') !== null;

 // Check for text tool active (when adding text to canvas)
 const isTextToolActive = currentTool === 'text' && isAddingText;

 // Additional check for any input with type password (API keys)
 const isPasswordInput = activeElement.type === 'password';

 const shouldDisable = inputTypes.includes(tagName) ||
 editableElements ||
 inputIds.includes(activeElement.id) ||
 isJupyterCell ||
 isTextToolActive ||
 isPasswordInput;

 // Debug logging
 if (shouldDisable) {
 console.log('üö´ Shortcuts disabled because:', {
 tagName,
 id: activeElement.id,
 isInput: inputTypes.includes(tagName),
 isEditable: editableElements,
 isSpecificInput: inputIds.includes(activeElement.id),
 isJupyter: isJupyterCell,
 isTextTool: isTextToolActive,
 isPassword: isPasswordInput
 });
 }

 return shouldDisable;
 }

 // Add keyboard event listener for tool shortcuts
 document.addEventListener('keydown', (e) => {
 // Only handle number keys 1-9
 if (!/^[1-9]$/.test(e.key)) return;

 // Debug logging for troubleshooting
 console.log(`‚å®Ô∏è Key ${e.key} pressed - Active element:`, document.activeElement.tagName, document.activeElement.id);
 console.log(`‚å®Ô∏è Is typing in input field:`, isTypingInInputField());
 console.log(`‚å®Ô∏è Current tool:`, currentTool);
 console.log(`‚å®Ô∏è Text tool active:`, isAddingText);

 // Don't trigger shortcuts if user is typing
 if (isTypingInInputField()) {
 console.log('üö´ Tool shortcut disabled - user is typing in:', document.activeElement.tagName, document.activeElement.id);
 return;
 }

 // Don't trigger if modifier keys are pressed (Ctrl, Alt, Shift, Meta)
 if (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) return;

 const toolButton = toolShortcuts[e.key];
 if (toolButton) {
 e.preventDefault(); // Prevent default behavior
 console.log(`üéØ Tool shortcut ${e.key} pressed - switching to:`, toolButton.id);
 toolButton.click(); // Trigger the tool button click
 } else {
 console.log(`‚ùå No tool button found for key ${e.key}`);
 }
 });

 console.log('‚úÖ Tool keyboard shortcuts initialized (1-9)');



 // --- Initialize Command History Manager ---
 try {
 if (typeof fabric !== 'undefined' && fabricCanvas && undoRedoEnabled) {
 commandHistory = new CommandHistory(50); // 50 command limit
 window.commandHistory = commandHistory; // Make it globally accessible
 console.log('‚úÖ Command History Manager initialized with 50 command limit');

 // Initial UI update
 commandHistory.updateUI();

 // Test that buttons are properly connected
 setTimeout(() => {
     const undoBtn = document.getElementById('undo-btn');
     const redoBtn = document.getElementById('redo-btn');
     console.log('üîç Button states:', {
         undoButton: !!undoBtn,
         redoButton: !!redoBtn,
         undoDisabled: undoBtn?.disabled,
         redoDisabled: redoBtn?.disabled
     });
 }, 100);

 } else {
 console.warn('‚ö†Ô∏è Command History not initialized - fabric.js, canvas, or undo/redo disabled');
 }
 } catch (error) {
 console.error('‚ùå Error initializing Command History:', error);
 undoRedoEnabled = false;
 }

 // --- Debug and Testing Functions for Undo/Redo ---
 window.debugUndoRedo = function() {
 if (!commandHistory) {
 console.log('‚ùå Command history not initialized');
 return;
 }

 const info = commandHistory.getDebugInfo();
 console.log('üîç Undo/Redo Debug Info:', info);
 console.log('üìö Undo Stack:', commandHistory.undoStack.map(cmd => cmd.toString()));
 console.log('üìö Redo Stack:', commandHistory.redoStack.map(cmd => cmd.toString()));
 return info;
 };

 window.testUndoRedo = function() {
 console.log('üß™ Testing Undo/Redo functionality...');

 // Test 1: Create a simple rectangle
 console.log('1Ô∏è‚É£ Creating test rectangle...');
 const rect = new fabric.Rect({
 left: 100,
 top: 100,
 width: 100,
 height: 100,
 fill: 'red',
 id: generateObjectId()
 });

 const addCommand = new AddObjectCommand(rect, 'Test Rectangle');
 commandHistory.executeCommand(addCommand);

 setTimeout(() => {
 console.log('2Ô∏è‚É£ Testing undo...');
 commandHistory.undo();

 setTimeout(() => {
 console.log('3Ô∏è‚É£ Testing redo...');
 commandHistory.redo();

 setTimeout(() => {
 console.log('4Ô∏è‚É£ Testing clear canvas...');
 const clearCommand = new ClearCanvasCommand('Test Clear');
 commandHistory.executeCommand(clearCommand);

 setTimeout(() => {
 console.log('5Ô∏è‚É£ Testing undo clear...');
 commandHistory.undo();
 console.log('‚úÖ Undo/Redo test completed!');
 }, 1000);
 }, 1000);
 }, 1000);
 }, 1000);
 };

 window.clearUndoHistory = function() {
 if (commandHistory) {
 commandHistory.clear();
 console.log('üóëÔ∏è Undo/Redo history cleared');
 } else {
 console.log('‚ùå Command history not initialized');
 }
 };

 // Simple undo/redo test function
 window.quickUndoRedoTest = function() {
 console.log('üß™ Quick Undo/Redo Test');
 console.log('Command History:', !!commandHistory);
 console.log('Can Undo:', commandHistory?.canUndo());
 console.log('Can Redo:', commandHistory?.canRedo());
 console.log('Undo Stack Length:', commandHistory?.undoStack?.length);
 console.log('Redo Stack Length:', commandHistory?.redoStack?.length);

 const undoBtn = document.getElementById('undo-btn');
 const redoBtn = document.getElementById('redo-btn');
 console.log('Undo Button:', !!undoBtn, 'Disabled:', undoBtn?.disabled);
 console.log('Redo Button:', !!redoBtn, 'Disabled:', redoBtn?.disabled);
 };

 // Test button clicks programmatically
 window.testButtonClicks = function() {
 console.log('üß™ Testing button clicks programmatically...');

 const undoBtn = document.getElementById('undo-btn');
 const redoBtn = document.getElementById('redo-btn');

 if (undoBtn) {
     console.log('üîÑ Simulating undo button click...');
     undoBtn.click();
 } else {
     console.log('‚ùå Undo button not found');
 }

 setTimeout(() => {
     if (redoBtn) {
         console.log('üîÑ Simulating redo button click...');
         redoBtn.click();
     } else {
         console.log('‚ùå Redo button not found');
     }
 }, 1000);
 };

 // Force button setup
 window.forceSetupButtons = function() {
 console.log('üîß Force setting up undo/redo buttons...');
 setupUndoRedoButtons();
 };

 // Test redo button specifically
 window.testRedoButton = function() {
 console.log('üß™ Testing redo button specifically...');

 const redoBtn = document.getElementById('redo-btn');
 console.log('Redo button found:', !!redoBtn);
 console.log('Redo button disabled:', redoBtn?.disabled);
 console.log('Redo button style:', redoBtn?.style.cssText);
 console.log('Can redo:', commandHistory?.canRedo());
 console.log('Redo stack length:', commandHistory?.redoStack?.length);

 if (redoBtn) {
     console.log('üîÑ Manually triggering redo button click...');
     redoBtn.click();
 }
 };

 // Test if button is being blocked by CSS or other issues
 window.debugRedoButton = function() {
 const redoBtn = document.getElementById('redo-btn');
 if (redoBtn) {
     console.log('üîç Redo button debug info:');
     console.log('- Element:', redoBtn);
     console.log('- Disabled:', redoBtn.disabled);
     console.log('- Style display:', getComputedStyle(redoBtn).display);
     console.log('- Style visibility:', getComputedStyle(redoBtn).visibility);
     console.log('- Style pointer-events:', getComputedStyle(redoBtn).pointerEvents);
     console.log('- Parent element:', redoBtn.parentElement);
     console.log('- Event listeners:', getEventListeners ? getEventListeners(redoBtn) : 'getEventListeners not available');
 }
 };

 // Force enable redo button and test
 window.forceEnableRedoButton = function() {
 const redoBtn = document.getElementById('redo-btn');
 if (redoBtn) {
     console.log('üîß Force enabling redo button...');
     redoBtn.disabled = false;
     redoBtn.style.pointerEvents = 'auto';
     redoBtn.style.opacity = '1';
     console.log('‚úÖ Redo button force enabled. Try clicking it now.');
 }
 };

 // Complete redo button test
 window.completeRedoTest = function() {
 console.log('üß™ Complete redo button test...');

 // Step 1: Check state
 console.log('1Ô∏è‚É£ Checking current state...');
 quickUndoRedoTest();

 // Step 2: Force enable button
 console.log('2Ô∏è‚É£ Force enabling button...');
 forceEnableRedoButton();

 // Step 3: Debug button
 console.log('3Ô∏è‚É£ Debugging button...');
 debugRedoButton();

 // Step 4: Test click
 console.log('4Ô∏è‚É£ Testing programmatic click...');
 const redoBtn = document.getElementById('redo-btn');
 if (redoBtn) {
     redoBtn.click();
 }
 };

 // Test Pan Mode button selection
 window.testPanModeSelection = function() {
 console.log('üß™ Testing Pan Mode button selection...');

 // Check current active buttons
 const activeButtons = document.querySelectorAll('.toolbar-button.active-tool, .toolbar-button.active');
 console.log('üîç Currently active buttons:', Array.from(activeButtons).map(btn => btn.id));

 // Test Pan Mode activation
 console.log('üéØ Activating Pan Mode...');
 if (panModeToolButton) {
     panModeToolButton.click();
 }

 // Check active buttons after Pan Mode
 setTimeout(() => {
     const activeAfterPan = document.querySelectorAll('.toolbar-button.active-tool, .toolbar-button.active');
     console.log('üîç Active buttons after Pan Mode:', Array.from(activeAfterPan).map(btn => btn.id));

     // Test deactivation
     console.log('üîÑ Deactivating Pan Mode...');
     if (panModeToolButton) {
         panModeToolButton.click();
     }

     setTimeout(() => {
         const activeAfterDeactivate = document.querySelectorAll('.toolbar-button.active-tool, .toolbar-button.active');
         console.log('üîç Active buttons after deactivation:', Array.from(activeAfterDeactivate).map(btn => btn.id));
     }, 100);
 }, 100);
 };

 // Test Pan Mode selection blocking
 window.testPanModeBlocking = function() {
 console.log('üß™ Testing Pan Mode selection blocking...');

 // First, make sure there are objects on canvas
 const objects = fabricCanvas.getObjects();
 console.log('üìä Objects on canvas:', objects.length);

 if (objects.length === 0) {
     console.log('‚ûï Adding test rectangle for selection test...');
     const testRect = new fabric.Rect({
         left: 100,
         top: 100,
         width: 100,
         height: 100,
         fill: 'red',
         id: 'test-selection-rect'
     });
     fabricCanvas.add(testRect);
     fabricCanvas.renderAll();
 }

 // Test normal selection first
 console.log('1Ô∏è‚É£ Testing normal selection...');
 fabricCanvas.setActiveObject(fabricCanvas.getObjects()[0]);
 console.log('Selected object:', !!fabricCanvas.getActiveObject());

 // Activate Pan Mode
 console.log('2Ô∏è‚É£ Activating Pan Mode...');
 if (!isPanModeActive) {
     togglePanMode();
 }

 // Try to select object in Pan Mode
 setTimeout(() => {
     console.log('3Ô∏è‚É£ Trying to select object in Pan Mode...');
     try {
         fabricCanvas.setActiveObject(fabricCanvas.getObjects()[0]);
         const selectedInPanMode = !!fabricCanvas.getActiveObject();
         console.log('Selection in Pan Mode:', selectedInPanMode ? '‚ùå FAILED - Selection still works!' : '‚úÖ SUCCESS - Selection blocked!');
     } catch (error) {
         console.log('‚úÖ SUCCESS - Selection properly blocked:', error.message);
     }

     // Deactivate Pan Mode
     console.log('4Ô∏è‚É£ Deactivating Pan Mode...');
     togglePanMode();

     // Test selection after Pan Mode
     setTimeout(() => {
         console.log('5Ô∏è‚É£ Testing selection after Pan Mode...');
         fabricCanvas.setActiveObject(fabricCanvas.getObjects()[0]);
         const selectedAfterPanMode = !!fabricCanvas.getActiveObject();
         console.log('Selection after Pan Mode:', selectedAfterPanMode ? '‚úÖ SUCCESS - Selection restored!' : '‚ùå FAILED - Selection still blocked!');
     }, 100);
 }, 100);
 };

 window.disableUndoRedo = function() {
 undoRedoEnabled = false;
 console.log('üö´ Undo/Redo system disabled');
 };

 window.enableUndoRedo = function() {
 undoRedoEnabled = true;
 console.log('‚úÖ Undo/Redo system enabled');
 };

 // Force restore selection functionality
 window.forceRestoreSelection = function() {
 console.log('üîß Force restoring selection functionality...');

 // Ensure Pan Mode is off
 if (isPanModeActive) {
     isPanModeActive = false;
     console.log('üîÑ Disabled Pan Mode');
 }

 // Restore canvas properties
 fabricCanvas.selection = true;
 fabricCanvas.skipTargetFind = false;
 fabricCanvas.interactive = true;
 fabricCanvas.isDrawingMode = false;

 // Restore object properties
 fabricCanvas.getObjects().forEach(obj => {
     obj.selectable = true;
     obj.evented = true;
     obj.hoverCursor = 'move';
     obj.moveCursor = 'move';
 });

 // Restore cursors
 fabricCanvas.defaultCursor = 'default';
 fabricCanvas.hoverCursor = 'move';
 fabricCanvas.moveCursor = 'move';
 canvasParent.style.cursor = '';

 // Clear any active tool and set to select
 setActiveToolButton(selectToolButton);
 resetAllToolStates();

 console.log('‚úÖ Selection functionality force restored');
 console.log('üìä Canvas state:', {
     selection: fabricCanvas.selection,
     skipTargetFind: fabricCanvas.skipTargetFind,
     interactive: fabricCanvas.interactive,
     isDrawingMode: fabricCanvas.isDrawingMode
 });
 };

 // Test selection functionality
 window.testSelection = function() {
 console.log('üß™ Testing selection functionality...');

 const objects = fabricCanvas.getObjects();
 console.log('üìä Objects on canvas:', objects.length);

 if (objects.length === 0) {
     console.log('‚ûï Adding test rectangle...');
     const testRect = new fabric.Rect({
         left: 150,
         top: 150,
         width: 100,
         height: 100,
         fill: 'blue',
         id: 'test-selection-rect'
     });
     fabricCanvas.add(testRect);
     fabricCanvas.renderAll();
 }

 // Try to select the first object
 setTimeout(() => {
     const firstObject = fabricCanvas.getObjects()[0];
     console.log('üéØ Attempting to select object...');

     try {
         fabricCanvas.setActiveObject(firstObject);
         fabricCanvas.renderAll();

         const activeObject = fabricCanvas.getActiveObject();
         console.log('Selection result:', activeObject ? '‚úÖ SUCCESS - Object selected!' : '‚ùå FAILED - No object selected');

         if (activeObject) {
             console.log('Selected object ID:', activeObject.id || 'no-id');
         }
     } catch (error) {
         console.log('‚ùå Selection error:', error.message);
     }
 }, 100);
 };

 // Test mobile touch object movement
 window.testMobileTouch = function() {
 console.log('üì± Testing mobile touch object movement...');

 // Ensure we're in select mode
 if (currentTool !== 'select') {
     console.log('üîÑ Switching to select tool...');
     selectToolButton.click();
 }

 // Check canvas state
 console.log('üìä Canvas state for touch:', {
     selection: fabricCanvas.selection,
     skipTargetFind: fabricCanvas.skipTargetFind,
     interactive: fabricCanvas.interactive,
     isDrawingMode: fabricCanvas.isDrawingMode,
     currentTool: currentTool,
     isGesturing: isGesturing
 });

 // Check objects
 const objects = fabricCanvas.getObjects();
 console.log('üìä Objects on canvas:', objects.length);

 if (objects.length === 0) {
     console.log('‚ûï Adding test object for touch test...');
     const testRect = new fabric.Rect({
         left: 200,
         top: 200,
         width: 120,
         height: 120,
         fill: 'green',
         id: 'touch-test-rect'
     });
     fabricCanvas.add(testRect);
     fabricCanvas.renderAll();
 }

 // Check object properties
 objects.forEach((obj, index) => {
     console.log(`üì¶ Object ${index}:`, {
         selectable: obj.selectable,
         evented: obj.evented,
         lockMovementX: obj.lockMovementX,
         lockMovementY: obj.lockMovementY,
         hoverCursor: obj.hoverCursor,
         moveCursor: obj.moveCursor
     });
 });

 console.log('‚úÖ Touch test setup complete. Try touching and dragging objects on mobile.');
 console.log('üí° If objects still don\'t move, try: forceRestoreSelection()');
 };

 // Test and optimize panning performance
 window.testPanPerformance = function() {
 console.log('üöÄ Testing pan performance...');

 // Check current performance settings
 console.log('üìä Current performance settings:', {
     renderOnAddRemove: fabricCanvas.renderOnAddRemove,
     skipOffscreen: fabricCanvas.skipOffscreen,
     enableRetinaScaling: fabricCanvas.enableRetinaScaling,
     imageSmoothingEnabled: fabricCanvas.imageSmoothingEnabled
 });

 // Optimize canvas for better panning performance
 console.log('üîß Optimizing canvas for panning...');

 // Disable expensive rendering options during panning
 fabricCanvas.renderOnAddRemove = false;
 fabricCanvas.skipOffscreen = true;
 fabricCanvas.imageSmoothingEnabled = false;

 console.log('‚úÖ Canvas optimized for panning performance');
 console.log('üì± Try panning now - should be much more responsive');
 console.log('üí° Use two fingers on mobile, scroll wheel on PC, or Space+drag');
 };

 // Restore full quality rendering
 window.restoreRenderQuality = function() {
 console.log('üé® Restoring full render quality...');

 fabricCanvas.renderOnAddRemove = true;
 fabricCanvas.skipOffscreen = false;
 fabricCanvas.imageSmoothingEnabled = true;
 fabricCanvas.requestRenderAll();

 console.log('‚úÖ Full render quality restored');
 };

 // Force immediate pan mode for testing
 window.forcePanMode = function() {
 console.log('üéØ Force activating Pan Mode...');

 if (!isPanModeActive) {
     togglePanMode();
 }

 // Additional optimizations for pan mode
 testPanPerformance();

 console.log('‚úÖ Pan Mode force activated with performance optimizations');
 console.log('üñ±Ô∏è Try panning - should be very responsive now');
 };

 // Test group messaging functionality
 window.testGroupMessaging = function() {
 console.log('üí¨ Testing group messaging functionality...');

 // Check current state
 console.log('üìä Group messaging state:', {
 isGroupConnected: isGroupConnected,
 currentGroupRoomId: currentGroupRoomId,
 unreadMessageCount: unreadMessageCount,
 activeTab: activeTab,
 notificationsEnabled: notificationsEnabled
 });

 // Check message counter visibility
 const counterBadge = document.getElementById('message-counter-badge');
 console.log('üî¢ Message counter:', {
 element: !!counterBadge,
 hidden: counterBadge?.classList.contains('hidden'),
 text: counterBadge?.textContent
 });

 // Check AI chat container state
 const aiChatContainer = document.getElementById('ai-chat-container');
 const aiChatToggle = document.getElementById('ai-chat-toggle');
 console.log('üíª AI Chat container:', {
 container: !!aiChatContainer,
 hidden: aiChatContainer?.classList.contains('hidden'),
 toggle: !!aiChatToggle,
 toggleActive: aiChatToggle?.classList.contains('active')
 });

 console.log('‚úÖ Group messaging test complete');
 console.log('üí° To test notifications: Join a room, close AI chat, have someone send a message');
 };

 // Force reset message counter
 window.forceResetMessageCounter = function() {
 console.log('üîÑ Force resetting message counter...');
 resetUnreadCount();
 console.log('‚úÖ Message counter reset');
 };

 // Debug message counter state
 window.debugMessageCounter = function() {
 console.log('üîç Message Counter Debug Info:');
 console.log('- isGroupConnected:', isGroupConnected);
 console.log('- currentGroupRoomId:', currentGroupRoomId);
 console.log('- unreadMessageCount:', unreadMessageCount);
 console.log('- lastSeenMessageTime:', new Date(lastSeenMessageTime).toLocaleTimeString());
 console.log('- activeTab:', activeTab);
 console.log('- messageCounterBadge element:', !!messageCounterBadge);
 console.log('- messageCounterBadge hidden:', messageCounterBadge?.classList.contains('hidden'));
 console.log('- messageCounterBadge text:', messageCounterBadge?.textContent);

 // Test counter functions
 console.log('üß™ Testing counter functions...');
 updateMessageCounter();
 };

 // Test message counter
 window.testMessageCounter = function() {
 console.log('üß™ Testing message counter...');
 console.log('1. Current state:');
 debugMessageCounter();

 console.log('2. Simulating message received...');
 incrementUnreadCount();

 console.log('3. After increment:');
 debugMessageCounter();

 console.log('4. Simulating tab switch to group messages...');
 switchTab('group-message');

 console.log('5. After tab switch:');
 debugMessageCounter();

 console.log('6. Switching back to AI chat...');
 switchTab('ai-chat');

 console.log('7. After switching back:');
 debugMessageCounter();
 };

 // Test notifications specifically
 window.testNotifications = function() {
 console.log('üîî Testing notification system...');

 console.log('Current state:');
 console.log('- notificationsEnabled:', notificationsEnabled);
 console.log('- activeTab:', activeTab);
 console.log('- isGroupConnected:', isGroupConnected);

 console.log('üß™ Simulating group message notification...');
 showGroupMessageNotification({
 id: 'test-' + Date.now(),
 sender: 'Test User',
 content: 'This is a test notification message',
 message: 'This is a test notification message'
 });

 console.log('‚úÖ Notification test completed');
 };

 // Test notification click
 window.testNotificationClick = function() {
 console.log('üîî Testing notification click behavior...');

 // Simulate notification click
 navigateToGroupMessage('test-message-123');

 console.log('‚úÖ Notification click test complete');
 console.log('üí° Check if AI chat container opened and switched to group messages');
 };

 // Test undo/redo buttons directly
 window.testUndoRedoButtons = function() {
 console.log('üß™ Testing undo/redo buttons directly...');

 const undoBtn = document.getElementById('undo-btn');
 const redoBtn = document.getElementById('redo-btn');

 console.log('üîç Button elements:', {
     undoBtn: !!undoBtn,
     redoBtn: !!redoBtn,
     undoDisabled: undoBtn?.disabled,
     redoDisabled: redoBtn?.disabled,
     commandHistory: !!commandHistory,
     canUndo: commandHistory?.canUndo(),
     canRedo: commandHistory?.canRedo()
 });

 if (undoBtn) {
     console.log('üîÑ Manually triggering undo button click...');
     undoBtn.click();
 }

 setTimeout(() => {
     if (redoBtn) {
         console.log('üîÑ Manually triggering redo button click...');
         redoBtn.click();
     }
 }, 1000);
 };

 // Force setup undo/redo buttons
 window.forceSetupUndoRedo = function() {
 console.log('üîß Force setting up undo/redo buttons...');

 const undoBtn = document.getElementById('undo-btn');
 const redoBtn = document.getElementById('redo-btn');

 if (undoBtn) {
     undoBtn.onclick = function() {
         console.log('üîÑ FORCE UNDO CLICKED');
         if (commandHistory && commandHistory.canUndo()) {
             commandHistory.undo();
             console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
         } else {
             console.log('‚ùå Cannot undo');
         }
     };
     console.log('‚úÖ Force undo setup complete');
 }

 if (redoBtn) {
     redoBtn.onclick = function() {
         console.log('üîÑ FORCE REDO CLICKED');
         if (commandHistory && commandHistory.canRedo()) {
             commandHistory.redo();
             console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
         } else {
             console.log('‚ùå Cannot redo');
         }
     };
     console.log('‚úÖ Force redo setup complete');
 }
 };

 window.testMultipleObjectDeletion = function() {
 console.log('Testing multiple object deletion and undo/redo with exact positioning...');

 try {
 // Clear canvas first
 fabricCanvas.clear();

 // Create multiple test objects at specific positions
 const objects = [];
 const originalPositions = [];

 // Create a red rectangle at specific position
 const rect = new fabric.Rect({
 left: 200,
 top: 150,
 width: 100,
 height: 80,
 fill: 'red',
 id: generateObjectId()
 });
 objects.push(rect);
 originalPositions.push({type: 'rect', left: 200, top: 150});
 fabricCanvas.add(rect);

 // Create a blue circle at different position
 const circle = new fabric.Circle({
 left: 400,
 top: 200,
 radius: 40,
 fill: 'blue',
 id: generateObjectId()
 });
 objects.push(circle);
 originalPositions.push({type: 'circle', left: 400, top: 200});
 fabricCanvas.add(circle);

 // Create green text at another position
 const text = new fabric.IText('TEST', {
 left: 250,
 top: 300,
 fill: 'green',
 fontSize: 24,
 id: generateObjectId()
 });
 objects.push(text);
 originalPositions.push({type: 'text', left: 250, top: 300});
 fabricCanvas.add(text);

 fabricCanvas.renderAll();
 console.log('üìç Created objects at positions:', originalPositions);

 // Wait a moment then test
 setTimeout(() => {
 console.log('1Ô∏è‚É£ Selecting all objects...');
 const selection = new fabric.ActiveSelection(objects, {
 canvas: fabricCanvas,
 });
 fabricCanvas.setActiveObject(selection);
 fabricCanvas.renderAll();

 setTimeout(() => {
 console.log('2Ô∏è‚É£ Deleting selected objects...');
 eraseSelectedObjects(objects);

 setTimeout(() => {
 console.log('3Ô∏è‚É£ Testing undo (should restore to exact positions)...');
 commandHistory.undo();

 // Check positions after undo
 setTimeout(() => {
 const restoredObjects = fabricCanvas.getObjects();
 console.log('üìç Checking restored positions:');
 restoredObjects.forEach((obj, index) => {
 console.log(`  ${obj.type}: (${obj.left}, ${obj.top})`);
 });

 setTimeout(() => {
 console.log('4Ô∏è‚É£ Testing redo...');
 commandHistory.redo();
 console.log('‚úÖ Test completed! Check positions above.');
 }, 1000);
 }, 500);
 }, 1000);
 }, 1000);
 }, 1000);

 } catch (error) {
 console.error('Error in test function:', error);
 }
 };

 // Test function for arrow and text undo/redo fixes
 window.testArrowTextUndoRedo = function() {
 console.log('üß™ Testing Arrow and Text Undo/Redo fixes...');

 try {
 // Clear canvas first
 fabricCanvas.clear();
 commandHistory.clear();

 console.log('1Ô∏è‚É£ Creating test arrow...');
 const testArrow = new fabric.Arrow({
 x1: 100, y1: 100,
 x2: 200, y2: 150,
 stroke: '#ff0000',
 strokeWidth: 3,
 id: generateObjectId()
 });

 const arrowCommand = new AddObjectCommand(testArrow, 'Test Arrow');
 commandHistory.executeCommand(arrowCommand);

 setTimeout(() => {
 console.log('2Ô∏è‚É£ Creating test text...');
 const testText = new fabric.IText('Test Text for Undo/Redo', {
 left: 250, top: 200,
 fill: '#0066cc',
 fontSize: 18,
 id: generateObjectId()
 });

 // Add text to canvas - this will trigger object:added event which creates the undo command
 fabricCanvas.add(testText);
 fabricCanvas.renderAll();
 console.log('üìù Text added to canvas:', testText.id);

 setTimeout(() => {
 console.log('3Ô∏è‚É£ Testing undo (should remove text)...');
 commandHistory.undo();

 setTimeout(() => {
 console.log('4Ô∏è‚É£ Testing undo again (should remove arrow)...');
 commandHistory.undo();

 setTimeout(() => {
 console.log('5Ô∏è‚É£ Testing redo (should restore arrow)...');
 commandHistory.redo();

 setTimeout(() => {
 console.log('6Ô∏è‚É£ Testing redo again (should restore text)...');
 commandHistory.redo();

 console.log('‚úÖ Arrow and Text Undo/Redo test completed!');
 console.log('üìù Instructions for manual testing:');
 console.log('- Select the arrow and double-click to edit (should show control points)');
 console.log('- Select the text and double-click to edit content');
 console.log('- Try undo/redo after editing text content');
 console.log('- Control points should not appear during undo/redo operations');

 }, 1000);
 }, 1000);
 }, 1000);
 }, 1000);
 }, 1000);

 } catch (error) {
 console.error('Error in arrow/text test function:', error);
 }
 };

 // Specific test for text undo/redo deletion
 window.testTextUndoRedoDeletion = function() {
 console.log('üß™ Testing Text Undo/Redo Deletion specifically...');

 try {
 // Clear canvas and history
 fabricCanvas.clear();
 commandHistory.clear();

 console.log('1Ô∏è‚É£ Creating text object...');
 const testText = new fabric.IText('This text should be deletable via undo', {
 left: 150, top: 150,
 fill: '#ff6600',
 fontSize: 20,
 id: generateObjectId()
 });

 // Add text to canvas - this should trigger object:added event
 fabricCanvas.add(testText);
 fabricCanvas.renderAll();

 console.log('üìù Text created with ID:', testText.id);
 console.log('üìä Canvas objects:', fabricCanvas.getObjects().length);
 console.log('üìö Undo stack size:', commandHistory.undoStack.length);

 setTimeout(() => {
 console.log('2Ô∏è‚É£ Testing undo (should delete the text)...');
 const beforeUndo = fabricCanvas.getObjects().length;
 commandHistory.undo();
 const afterUndo = fabricCanvas.getObjects().length;

 console.log('üìä Objects before undo:', beforeUndo);
 console.log('üìä Objects after undo:', afterUndo);

 if (afterUndo < beforeUndo) {
 console.log('‚úÖ SUCCESS: Text was deleted via undo!');
 } else {
 console.log('‚ùå FAILED: Text was not deleted via undo');
 }

 setTimeout(() => {
 console.log('3Ô∏è‚É£ Testing redo (should restore the text)...');
 const beforeRedo = fabricCanvas.getObjects().length;
 commandHistory.redo();
 const afterRedo = fabricCanvas.getObjects().length;

 console.log('üìä Objects before redo:', beforeRedo);
 console.log('üìä Objects after redo:', afterRedo);

 if (afterRedo > beforeRedo) {
 console.log('‚úÖ SUCCESS: Text was restored via redo!');
 } else {
 console.log('‚ùå FAILED: Text was not restored via redo');
 }

 console.log('üéØ Text undo/redo deletion test completed!');
 }, 1000);
 }, 1000);

 } catch (error) {
 console.error('Error in text deletion test:', error);
 }
 };

 // --- Object State Tracking for Undo/Redo ---
 // Capture object state before modification starts
 fabricCanvas.on('object:moving', (e) => {
 const obj = e.target;
 if (obj && obj.id && !objectStatesBeforeModification.has(obj.id) && !isExecutingCommand) {
 objectStatesBeforeModification.set(obj.id, {
 left: obj.left,
 top: obj.top,
 scaleX: obj.scaleX,
 scaleY: obj.scaleY,
 angle: obj.angle
 });
 }
 });

 fabricCanvas.on('object:scaling', (e) => {
 const obj = e.target;
 if (obj && obj.id && !objectStatesBeforeModification.has(obj.id) && !isExecutingCommand) {
 objectStatesBeforeModification.set(obj.id, {
 left: obj.left,
 top: obj.top,
 scaleX: obj.scaleX,
 scaleY: obj.scaleY,
 angle: obj.angle
 });
 }
 });

 fabricCanvas.on('object:rotating', (e) => {
 const obj = e.target;
 if (obj && obj.id && !objectStatesBeforeModification.has(obj.id) && !isExecutingCommand) {
 objectStatesBeforeModification.set(obj.id, {
 left: obj.left,
 top: obj.top,
 scaleX: obj.scaleX,
 scaleY: obj.scaleY,
 angle: obj.angle
 });
 }
 });

 // --- Event Listeners (Adapted for new UI) ---
  // Track a color change transaction for undo/redo grouping
  let colorChangeSession = null; // { targets: [{ obj, id, old:{...} }] }

  function applyColorToObject(obj, color) {
    if (!obj) return;
    // Highlighter shapes use semi‚Äëtransparent fill + stroke
    if (obj.isAIHighlight) {
      const fillRGBA = fabric.Color.fromHex(color).setAlpha(0.3).toRgba();
      const strokeRGBA = fabric.Color.fromHex(color).setAlpha(0.7).toRgba();
      console.log('üé® Applying highlighter colors:', {
        objectId: obj.id,
        color: color,
        fillRGBA: fillRGBA,
        strokeRGBA: strokeRGBA,
        isAIHighlight: obj.isAIHighlight
      });
      obj.set('fill', fillRGBA);
      if ('stroke' in obj) obj.set('stroke', strokeRGBA);
      return;
    }

    // Text uses fill color
    if (obj.type === 'i-text' || obj.type === 'textbox') {
      obj.set('fill', color);
      return;
    }

    // Groups: apply recursively to children
    if (obj.type === 'group' && typeof obj.getObjects === 'function') {
      obj.getObjects().forEach(child => applyColorToObject(child, color));
      return;
    }

    // Paths and shapes: set stroke only; ensure fill stays transparent
    if ('stroke' in obj) obj.set('stroke', color);
    if ('fill' in obj) obj.set('fill', null);
  }

  function broadcastModified(obj) {
    try {
      if (!obj) return;
      if (!obj.id) obj.id = generateObjectId();
      if (currentRoomId && !isProcessingRemoteOperation) {
        const objectData = obj.toObject();
        console.log('üì° Broadcasting object modification:', {
          objectId: obj.id,
          type: obj.type,
          isAIHighlight: obj.isAIHighlight,
          serializedIsAIHighlight: objectData.isAIHighlight,
          fill: objectData.fill,
          stroke: objectData.stroke
        });
        sendCanvasOperation('object_modified', {
          object_id: obj.id,
          object: objectData
        });
      }
    } catch (_) {}
  }

  function collectColorTargets(objects) {
    const targets = [];
    const pushTarget = (o) => {
      if (!o) return;
      if (!o.id) o.id = generateObjectId();
      // Snapshot old props for undo
      const old = {};
      if (o.stroke !== undefined) old.stroke = o.stroke;
      if (o.fill !== undefined) old.fill = o.fill;
      targets.push({ obj: o, id: o.id, old });
    };
    objects.forEach((obj) => {
      if (!obj) return;
      if (obj.type === 'group' && typeof obj.getObjects === 'function') {
        obj.getObjects().forEach(child => pushTarget(child));
      } else {
        pushTarget(obj);
      }
    });
    return targets;
  }

  colorPicker.addEventListener('input', (e) => { // live update
    const newColor = e.target.value;
    if (fabricCanvas.freeDrawingBrush) fabricCanvas.freeDrawingBrush.color = newColor;
    const selected = fabricCanvas.getActiveObjects();
    if (selected && selected.length) {
      // Start a color change session on first input to snapshot old state
      if (!colorChangeSession) {
        colorChangeSession = { targets: collectColorTargets(selected) };
      }
      selected.forEach(obj => {
        applyColorToObject(obj, newColor);
        broadcastModified(obj);
      });
      fabricCanvas.renderAll();
    }
  });

 brushSizeSlider.addEventListener('input', (e) => {
 const size = parseInt(e.target.value, 10);
 if (fabricCanvas.freeDrawingBrush) fabricCanvas.freeDrawingBrush.width = size;
 updateSelectedObjectsStroke({ strokeWidth: size });
 });

  colorPicker.addEventListener('change', (e) => {
    const color = e.target.value;
    if (fabricCanvas.freeDrawingBrush) fabricCanvas.freeDrawingBrush.color = color;
    const selected = fabricCanvas.getActiveObjects();
    if (selected && selected.length) {
      // Apply final color (already applied by input) and push undo/redo command
      const cmds = [];
      const ensureTargets = colorChangeSession ? colorChangeSession.targets : collectColorTargets(selected);
      ensureTargets.forEach(({ obj, id, old }) => {
        const newProps = {};
        if (obj.isAIHighlight) {
          const fillRGBA = fabric.Color.fromHex(color).setAlpha(0.3).toRgba();
          const strokeRGBA = fabric.Color.fromHex(color).setAlpha(0.7).toRgba();
          newProps.fill = fillRGBA;
          if ('stroke' in obj) newProps.stroke = strokeRGBA;
        } else if (obj.type === 'i-text' || obj.type === 'textbox') {
          newProps.fill = color;
        } else {
          if ('stroke' in obj) newProps.stroke = color;
          if ('fill' in obj) newProps.fill = null;
        }

        // Create a ModifyObjectCommand for this object
        if (typeof ModifyObjectCommand === 'function') {
          cmds.push(new ModifyObjectCommand(obj, old, newProps, 'Change Color'));
        } else {
          // Fallback: apply directly (should not happen in this codebase)
          obj.set(newProps);
        }

        broadcastModified(obj);
      });

      if (cmds.length && typeof BatchCommand === 'function' && commandHistory) {
        const batch = new BatchCommand(cmds, 'Change Color');
        // Execute to register a single undo step; objects already in final state
        commandHistory.executeCommand(batch);
      }

      fabricCanvas.renderAll();
      colorChangeSession = null;
    }
  });

 // Function to update stroke properties of selected objects
  function updateSelectedObjectsStroke(properties) {
  const activeObjects = fabricCanvas.getActiveObjects();
  if (activeObjects.length > 0) {
  activeObjects.forEach(obj => {
  // Handle different object types
  if (obj.type === 'group') {
  // For groups (like arrows), update all objects in the group
  obj.getObjects().forEach(groupObj => {
  if (properties.stroke) {
    // For color updates: text children get fill; everything else gets stroke and no fill
    if (groupObj.type === 'i-text' || groupObj.type === 'textbox') {
      groupObj.set('fill', properties.stroke);
    } else {
      if (groupObj.stroke !== undefined) groupObj.set('stroke', properties.stroke);
      if (groupObj.fill !== undefined) groupObj.set('fill', null);
    }
  }
  if (properties.strokeWidth && groupObj.strokeWidth !== undefined) {
  groupObj.set('strokeWidth', properties.strokeWidth);
  }
  });
  } else {
  // For individual objects
  if (properties.stroke) {
    if (obj.type === 'i-text' || obj.type === 'textbox') {
      obj.set('fill', properties.stroke);
    } else {
      if (obj.stroke !== undefined) obj.set('stroke', properties.stroke);
      if (obj.fill !== undefined) obj.set('fill', null);
    }
  }
  if (properties.strokeWidth && obj.strokeWidth !== undefined) {
  obj.set('strokeWidth', properties.strokeWidth);
  }
  }
  obj.setCoords();

 // üî¥ NEW ‚Äì broadcast style changes
 if (currentRoomId && !isProcessingRemoteOperation) {
 sendCanvasOperation('object_modified', {
 object_id: obj.id,
 object: obj.toObject()
 });
 }
 });
 fabricCanvas.renderAll();
 }
 }

 penToolButton.addEventListener('click', () => {
 // Reset all tool states
 resetAllToolStates();

 currentTool = 'pen';
 fabricCanvas.isDrawingMode = true;
 fabricCanvas.selection = false; // Disable selection during pen drawing
 fabricCanvas.freeDrawingBrush = new fabric.PencilBrush(fabricCanvas);
 fabricCanvas.freeDrawingBrush.color = colorPicker.value;
 fabricCanvas.freeDrawingBrush.width = parseInt(brushSizeSlider.value, 10);

 // üöÄ MOBILE OPTIMIZATION: Apply brush decimation
 fabricCanvas.freeDrawingBrush.decimate = isCoarse ? 6 : 2;

 // Make all objects non-selectable during pen drawing
 fabricCanvas.getObjects().forEach(obj => {
 obj.selectable = false;
 obj.evented = false;
 });

 setActiveToolButton(penToolButton);
 });

 const startShapeDrawing = (shapeType, buttonToActivate) => {
 // Reset all tool states first
 resetAllToolStates();

 currentTool = shapeType;
 fabricCanvas.isDrawingMode = false;
 isDrawingShape = true;
 fabricCanvas.selection = false;
 fabricCanvas.discardActiveObject();

 // Make all objects non-selectable during drawing
 fabricCanvas.getObjects().forEach(obj => {
 obj.selectable = false;
 obj.evented = false;
 });

 fabricCanvas.renderAll();
 setActiveToolButton(buttonToActivate);
 };

 lineToolButton.addEventListener('click', () => startShapeDrawing('line', lineToolButton));
 arrowToolButton.addEventListener('click', () => startShapeDrawing('arrow', arrowToolButton));
 circleToolButton.addEventListener('click', () => startShapeDrawing('circle', circleToolButton));
 rectangleToolButton.addEventListener('click', () => startShapeDrawing('rectangle', rectangleToolButton));

 const startHighlightDrawing = (shapeType, buttonToActivate) => {
 // Reset all tool states first
 resetAllToolStates();

 currentTool = shapeType;
 fabricCanvas.isDrawingMode = false;
 isDrawingHighlight = true;
 fabricCanvas.selection = false;
 fabricCanvas.discardActiveObject();

 // Make all objects non-selectable during drawing
 fabricCanvas.getObjects().forEach(obj => {
 obj.selectable = false;
 obj.evented = false;
 });

 fabricCanvas.renderAll();
 setActiveToolButton(buttonToActivate);
 };
 highlighterRectButton.addEventListener('click', () => startHighlightDrawing('highlighter-rect', highlighterRectButton));
 highlighterCircleButton.addEventListener('click', () => startHighlightDrawing('highlighter-circle', highlighterCircleButton));

 textToolButton.addEventListener('click', () => {
 // Reset all tool states first
 resetAllToolStates();

 currentTool = 'text';
 isAddingText = true;
 fabricCanvas.isDrawingMode = false;
 fabricCanvas.selection = false;

 // Make all objects non-selectable during text tool
 fabricCanvas.getObjects().forEach(obj => {
 obj.selectable = false;
 obj.evented = false;
 });

 setActiveToolButton(textToolButton);
 });

 // Image Upload Tool
 imageUploadToolButton.addEventListener('click', () => {
 console.log('üì∑ Image upload tool clicked');
 try {
 imageUploadInput.click(); // Trigger file input
 } catch (error) {
 console.error('‚ùå Error triggering file input:', error);
 }
 });

 // Handle file selection
 imageUploadInput.addEventListener('change', (e) => {
 const files = e.target.files;
 if (files && files.length > 0) {
 console.log(`üì∑ Selected ${files.length} image(s) for upload`);

 // Process each selected file
 Array.from(files).forEach((file, index) => {
 if (file.type.startsWith('image/')) {
 console.log(`üì∑ Processing image ${index + 1}: ${file.name} (${file.type})`);
 handleImageUpload(file);
 } else {
 console.warn(`‚ö†Ô∏è Skipping non-image file: ${file.name}`);
 }
 });

 // Clear the input so the same file can be selected again
 imageUploadInput.value = '';
 }
 });

 selectToolButton.addEventListener('click', () => {
 // Reset all tool states first
 resetAllToolStates();

 currentTool = 'select';
 fabricCanvas.isDrawingMode = false;
 fabricCanvas.selection = true;

 // IMPORTANT: Ensure objects are fully interactive for mobile touch
 fabricCanvas.skipTargetFind = false;
 fabricCanvas.interactive = true;

 // Make sure all objects are selectable and movable
 fabricCanvas.getObjects().forEach(obj => {
     obj.selectable = true;
     obj.evented = true;
     obj.lockMovementX = false;
     obj.lockMovementY = false;
     obj.lockScalingX = false;
     obj.lockScalingY = false;
     obj.lockRotation = false;
     obj.hoverCursor = 'move';
     obj.moveCursor = 'move';
 });

 // Restore normal cursors
 fabricCanvas.defaultCursor = 'default';
 fabricCanvas.hoverCursor = 'move';
 fabricCanvas.moveCursor = 'move';

 // Disable pan mode if it was active
 if (isPanModeActive) {
     isPanModeActive = false;
 }

 setActiveToolButton(selectToolButton);
 console.log('‚úÖ Select tool activated - objects should be movable on touch');
 });

 // Pan Mode Tool - Navigation Only Mode
 if (panModeToolButton) {
     panModeToolButton.addEventListener('click', () => {
         togglePanMode();
     });
 } else {
     console.error('‚ùå Cannot add Pan Mode event listener - button not found');
 }

 eraseSelectedButton.addEventListener('click', () => {
 const activeObjects = fabricCanvas.getActiveObjects();
 if (activeObjects.length === 0) {
 // Removed noisy system message - user will see no visual change if nothing selected
 return;
 }

 if (confirm(`Are you sure you want to erase ${activeObjects.length} selected object(s)? This action cannot be undone.`)) {
 eraseSelectedObjects(activeObjects);
 // Removed noisy system message - action is self-evident
 }
 });

 eraseCanvasButton.addEventListener('click', () => {
 if (confirm('Are you sure you want to erase the entire canvas? This action cannot be undone and will affect all users.')) {
 eraseWholeCanvas();
 // Removed noisy system message - action is self-evident
 }
 });

 // --- Undo/Redo Button Event Listeners ---
 // Use a more robust approach to ensure buttons are found
 function setupUndoRedoButtons() {
     const undoBtn = document.getElementById('undo-btn');
     const redoBtn = document.getElementById('redo-btn');

     console.log('üîç Setting up undo/redo buttons:', {
         undoButton: !!undoBtn,
         redoButton: !!redoBtn,
         commandHistory: !!commandHistory,
         undoElement: undoBtn,
         redoElement: redoBtn
     });

     if (undoBtn) {
         // Remove any existing listeners first
         undoBtn.replaceWith(undoBtn.cloneNode(true));
         const freshUndoBtn = document.getElementById('undo-btn');

         freshUndoBtn.addEventListener('click', (e) => {
             e.preventDefault();
             e.stopPropagation();

             // EXACT COPY of keyboard shortcut code from lines 9605-9608
             if (commandHistory && commandHistory.canUndo()) {
                 commandHistory.undo();
                 console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
             }
         });
         console.log('‚úÖ Undo button listener attached');
     } else {
         console.warn('‚ö†Ô∏è Undo button not found');
     }

     if (redoBtn) {
         // Remove any existing listeners first
         redoBtn.replaceWith(redoBtn.cloneNode(true));
         const freshRedoBtn = document.getElementById('redo-btn');

         freshRedoBtn.addEventListener('click', (e) => {
             e.preventDefault();
             e.stopPropagation();

             // EXACT COPY of keyboard shortcut code from lines 9612-9615
             if (commandHistory && commandHistory.canRedo()) {
                 commandHistory.redo();
                 console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
             }
         });
         console.log('‚úÖ Redo button listener attached');
     } else {
         console.warn('‚ö†Ô∏è Redo button not found');
     }
 }

 // Setup buttons immediately and also after a delay
 setupUndoRedoButtons();
 setTimeout(setupUndoRedoButtons, 100);
 setTimeout(setupUndoRedoButtons, 500);

 // SIMPLE DIRECT APPROACH - Add event listeners directly
 document.addEventListener('DOMContentLoaded', () => {
     console.log('üîß DOM loaded - setting up simple undo/redo button listeners');

     const undoBtn = document.getElementById('undo-btn');
     const redoBtn = document.getElementById('redo-btn');

     if (undoBtn) {
         undoBtn.onclick = function() {
             console.log('üîÑ UNDO BUTTON CLICKED - DIRECT');
             if (commandHistory && commandHistory.canUndo()) {
                 commandHistory.undo();
                 console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
             } else {
                 console.log('‚ùå Cannot undo - no commandHistory or canUndo false');
             }
         };
         console.log('‚úÖ Direct undo button listener added');
     } else {
         console.log('‚ùå Undo button not found in DOM');
     }

     if (redoBtn) {
         redoBtn.onclick = function() {
             console.log('üîÑ REDO BUTTON CLICKED - DIRECT');
             if (commandHistory && commandHistory.canRedo()) {
                 commandHistory.redo();
                 console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
             } else {
                 console.log('‚ùå Cannot redo - no commandHistory or canRedo false');
             }
         };
         console.log('‚úÖ Direct redo button listener added');
     } else {
         console.log('‚ùå Redo button not found in DOM');
     }
 });

 // BACKUP APPROACH - Try again after everything is loaded
 window.addEventListener('load', () => {
     console.log('üîß Window loaded - backup undo/redo setup');

     const undoBtn = document.getElementById('undo-btn');
     const redoBtn = document.getElementById('redo-btn');

     if (undoBtn && !undoBtn.onclick) {
         undoBtn.onclick = function() {
             console.log('üîÑ UNDO BUTTON CLICKED - BACKUP');
             if (commandHistory && commandHistory.canUndo()) {
                 commandHistory.undo();
                 console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
             }
         };
     }

     if (redoBtn && !redoBtn.onclick) {
         redoBtn.onclick = function() {
             console.log('üîÑ REDO BUTTON CLICKED - BACKUP');
             if (commandHistory && commandHistory.canRedo()) {
                 commandHistory.redo();
                 console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
             }
         };
     }
 });

 // Alternative approach: Direct event delegation
 document.addEventListener('click', (e) => {
     if (e.target.id === 'undo-btn' || e.target.closest('#undo-btn')) {
         e.preventDefault();
         e.stopPropagation();

         // EXACT COPY of keyboard shortcut code from lines 9605-9608
         if (commandHistory && commandHistory.canUndo()) {
             commandHistory.undo();
             console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
         }
     }

     if (e.target.id === 'redo-btn' || e.target.closest('#redo-btn')) {
         e.preventDefault();
         e.stopPropagation();

         // EXACT COPY of keyboard shortcut code from lines 9612-9615
         if (commandHistory && commandHistory.canRedo()) {
             commandHistory.redo();
             console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
         }
     }
 });

 // Additional mousedown event for redo button (in case click is being blocked)
 document.addEventListener('mousedown', (e) => {
     if (e.target.id === 'redo-btn' || e.target.closest('#redo-btn')) {
         setTimeout(() => {
             // EXACT COPY of keyboard shortcut code from lines 9612-9615
             if (commandHistory && commandHistory.canRedo()) {
                 commandHistory.redo();
                 console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
             }
         }, 10);
     }
 });





 askAiCanvasButton.addEventListener('click', () => {
 // Removed noisy system message - user can see the action happening
 console.log('üé® Starting canvas capture for AI...');

 const originalBackgroundColor = fabricCanvas.backgroundColor;
 // Ensure a non-transparent background for the screenshot
 if (fabricCanvas.backgroundColor === 'transparent' || !fabricCanvas.backgroundColor) {
 fabricCanvas.backgroundColor = document.documentElement.classList.contains('dark') ? '#0f172a' : '#FFFFFF';
 }
 fabricCanvas.renderAll(); // Render with temporary background if changed
 const dataURL = fabricCanvas.toDataURL({ format: 'png', quality: 0.9 });

 console.log('üì∏ Canvas captured, data URL length:', dataURL.length);
 console.log('üì∏ Data URL preview:', dataURL.substring(0, 100) + '...');

 // Restore original background if it was temporarily changed
 if (fabricCanvas.backgroundColor !== originalBackgroundColor) {
 fabricCanvas.backgroundColor = originalBackgroundColor;
 fabricCanvas.renderAll();
 }

 if (dataURL && dataURL.length > 100) {
 addChatMessage('User', '', false, dataURL);
        pendingImageForChat = dataURL;
        pendingImageMetadata = { type: 'canvas' };
        addChatMessage('AI', 'Canvas captured! Type your question below and press Send.');
 console.log('‚úÖ Canvas image ready for AI analysis');
 chatInput.focus();
 } else {
 console.error('‚ùå Failed to capture canvas - invalid data URL');
 addChatMessage('AI', 'Sorry, failed to capture canvas. Please try again.');
 }
 });

 toggleHighContrastButton.addEventListener('click', () => {
 // Temporarily disable transitions for smooth theme switching
 document.body.classList.add('theme-switching');

 // Immediately toggle the theme for instant visual feedback
 document.documentElement.classList.toggle('dark');
 const isDarkMode = document.documentElement.classList.contains('dark');
 localStorage.setItem('darkMode', isDarkMode);

 // Re-enable transitions after a brief moment
 setTimeout(() => {
 document.body.classList.remove('theme-switching');
 }, 100);

 // Defer expensive operations to prevent UI blocking
 requestAnimationFrame(() => {
 // Skip canvas background update - preserve user's chosen pattern
 setTimeout(() => {
 if (fabricCanvas) {
 // Only render to refresh the canvas, don't change background
 fabricCanvas.renderAll();
 }
 }, 150);

 // Re-process MathJax with a longer delay to avoid blocking
 setTimeout(() => {
 if (typeof MathJax !== 'undefined' && MathJax.typesetPromise && chatHistory) {
 MathJax.typesetPromise([chatHistory]).catch((err) =>
 console.error('MathJax re-typesetting error on contrast toggle:', err)
 );
 }
 }, 300);
 });
 });

 // Helper function for smooth theme switching (used by button and session import)
 function toggleDarkMode() {
 // Temporarily disable transitions for smooth theme switching
 document.body.classList.add('theme-switching');

 // Toggle the theme
 document.documentElement.classList.toggle('dark');
 const isDarkMode = document.documentElement.classList.contains('dark');
 localStorage.setItem('darkMode', isDarkMode);

 // Re-enable transitions after a brief moment
 setTimeout(() => {
 document.body.classList.remove('theme-switching');
 }, 100);

 // Defer expensive operations to prevent UI blocking
 requestAnimationFrame(() => {
 // Skip canvas background update - preserve user's chosen pattern
 setTimeout(() => {
 if (fabricCanvas) {
 // Only render to refresh the canvas, don't change background
 fabricCanvas.renderAll();
 }
 }, 150);

 // Re-process MathJax with a longer delay to avoid blocking
 setTimeout(() => {
 if (typeof MathJax !== 'undefined' && MathJax.typesetPromise && chatHistory) {
 MathJax.typesetPromise([chatHistory]).catch((err) =>
 console.error('MathJax re-typesetting error on theme toggle:', err)
 );
 }
 }, 300);
 });
 }

 // Canvas zoom level (removed interface zoom for natural browser-like behavior)
 function updateZoomLevel() {
     zoomLevelDisplay.textContent = Math.round(currentZoom * 100) + '%';
 }

 zoomInButton.addEventListener('click', () => {
 // Canvas zoom only (browser-like behavior) - OPTIMIZED: No bitmap resize
 currentZoom = Math.min(currentZoom * 1.2, 10);
 fabricCanvas.setZoom(currentZoom);
 // ‚ùå REMOVED: fabricCanvas.setWidth/setHeight - causes expensive bitmap reallocation
 fabricCanvas.requestRenderAll(); // üëà Use requestRenderAll for better performance
 canvasParent.scrollLeft = (canvasParent.scrollWidth - canvasParent.clientWidth) / 2;
 canvasParent.scrollTop = (canvasParent.scrollHeight - canvasParent.clientHeight) / 2;
 updateZoomLevel();

 // Reapply pattern after canvas resize
 if (currentCanvasPattern) {
 setTimeout(() => reapplyCanvasPatternOnResize(), 50);
 }
 });

 zoomOutButton.addEventListener('click', () => {
 // Canvas zoom only (browser-like behavior) - OPTIMIZED: No bitmap resize
 currentZoom = Math.max(currentZoom / 1.2, 0.1);
 fabricCanvas.setZoom(currentZoom);
 // ‚ùå REMOVED: fabricCanvas.setWidth/setHeight - causes expensive bitmap reallocation
 fabricCanvas.requestRenderAll(); // üëà Use requestRenderAll for better performance
 canvasParent.scrollLeft = (canvasParent.scrollWidth - canvasParent.clientWidth) / 2;
 canvasParent.scrollTop = (canvasParent.scrollHeight - canvasParent.clientHeight) / 2;
 updateZoomLevel();

 // Reapply pattern after canvas resize
 if (currentCanvasPattern) {
 setTimeout(() => reapplyCanvasPatternOnResize(), 50);
 }
 });

 zoomResetButton.addEventListener('click', () => {
 // üåå INFINITE CANVAS: Smart zoom reset - fit to content or reset to 1x
 const objects = fabricCanvas.getObjects();
 if (objects.length > 0) {
     // Fit to content if there are objects
     centerCanvasView();
 } else {
     // Reset to 1x zoom and center if no content
     currentZoom = 1.0;
     fabricCanvas.setZoom(currentZoom);
     fabricCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
     fabricCanvas.requestRenderAll();
     updateZoomLevel();
 }

 // Reapply pattern after canvas changes
 if (currentCanvasPattern) {
 setTimeout(() => reapplyCanvasPatternOnResize(), 50);
 }
 });

 // Initialize zoom level display
 updateZoomLevel();

 // Prevent browser zoom globally and use our custom canvas zoom instead
 document.addEventListener('keydown', (e) => {
     if (e.ctrlKey || e.metaKey) {
         if (e.key === '=' || e.key === '+') {
             e.preventDefault();
             zoomInButton.click();
         } else if (e.key === '-') {
             e.preventDefault();
             zoomOutButton.click();
         } else if (e.key === '0') {
             e.preventDefault();
             zoomResetButton.click();
         }
     }
 });

 // Undo/Redo keyboard shortcuts
 document.addEventListener('keydown', (e) => {
     // Only handle if not typing in input fields
     if (isUserTypingInTextField()) {
         return;
     }

     if (e.ctrlKey || e.metaKey) {
         if (e.key === 'z' && !e.shiftKey) {
             // Undo: Ctrl+Z / Cmd+Z
             e.preventDefault();
             if (commandHistory && commandHistory.canUndo()) {
                 commandHistory.undo();
                 console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
             }
         } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
             // Redo: Ctrl+Y / Cmd+Y or Ctrl+Shift+Z / Cmd+Shift+Z
             e.preventDefault();
             if (commandHistory && commandHistory.canRedo()) {
                 commandHistory.redo();
                 console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
             }
         }
     }
 });

 // Prevent browser zoom on wheel events globally (but allow canvas panning)
 document.addEventListener('wheel', (e) => {
     // Only prevent default for zoom (Ctrl/Cmd), not for canvas panning
     if (e.ctrlKey || e.metaKey) {
         e.preventDefault();
     }
     // Let canvas handle its own wheel events for panning
 }, { passive: false });

 // Enhanced mouse wheel: zoom with Ctrl/Cmd, infinite scroll panning, horizontal pan with Shift
 canvasParent.addEventListener('wheel', (e) => {
     e.preventDefault(); // Prevent immediately for better performance

     if (e.ctrlKey || e.metaKey) {
         // Zoom with Ctrl/Cmd + wheel
         const rect = canvasParent.getBoundingClientRect();
         const mouseX = e.clientX - rect.left;
         const mouseY = e.clientY - rect.top;

         // Calculate zoom delta
         const zoomDelta = e.deltaY > 0 ? 1/1.1 : 1.1;
         const newZoom = Math.max(0.1, Math.min(10, currentZoom * zoomDelta));

         if (newZoom !== currentZoom) {
             // Store scroll position before zoom
             const scrollLeft = canvasParent.scrollLeft;
             const scrollTop = canvasParent.scrollTop;

             // Calculate the point under mouse in canvas coordinates
             const canvasPoint = new fabric.Point(
                 (scrollLeft + mouseX) / currentZoom,
                 (scrollTop + mouseY) / currentZoom
             );

             // Apply new zoom - OPTIMIZED: No bitmap resize
             currentZoom = newZoom;
             fabricCanvas.setZoom(currentZoom);
             // ‚ùå REMOVED: fabricCanvas.setWidth/setHeight - causes expensive bitmap reallocation
             fabricCanvas.requestRenderAll(); // üëà Use requestRenderAll for better performance

             // Adjust scroll to keep the point under mouse
             const newScrollLeft = canvasPoint.x * currentZoom - mouseX;
             const newScrollTop = canvasPoint.y * currentZoom - mouseY;

             canvasParent.scrollLeft = Math.max(0, newScrollLeft);
             canvasParent.scrollTop = Math.max(0, newScrollTop);

             updateZoomLevel();

             // Reapply pattern after canvas resize
             if (currentCanvasPattern) {
                 setTimeout(() => reapplyCanvasPatternOnResize(), 50);
             }
         }
     } else {
         // Infinite scroll panning - BOTH vertical AND horizontal (optimized)
         const deltaY = e.deltaY; // Vertical scroll
         const deltaX = e.deltaX; // Horizontal scroll (trackpad/mouse)

         // Apply panning multiplier for more responsive feel
         const panMultiplier = 1.2;
         const adjustedDeltaX = deltaX * panMultiplier;
         const adjustedDeltaY = deltaY * panMultiplier;

         const vpt = fabricCanvas.viewportTransform;

         // Pan both directions simultaneously
         vpt[4] -= adjustedDeltaX; // Horizontal panning
         vpt[5] -= adjustedDeltaY; // Vertical panning

         fabricCanvas.setViewportTransform(vpt);
         fabricCanvas.requestRenderAll();
     }
 }, { passive: false });

 toggleMagnifierButton.addEventListener('click', () => {
 magnifierActive = !magnifierActive;
 magnifierPreview.style.display = magnifierActive ? 'block' : 'none';
 // Removed noisy system message - magnifier state is visually obvious
 });

 // --- AI Settings Canvas Background Pattern Functionality ---
 let aiCurrentPattern = null;

 // Initialize AI pattern functionality
 function initializeAIPatternControls() {
 console.log('üé® Initializing AI pattern controls...');

 // AI Pattern buttons
 const aiPatternButtons = document.querySelectorAll('.ai-pattern-btn');
 console.log('Found AI pattern buttons:', aiPatternButtons.length);

 aiPatternButtons.forEach(btn => {
 btn.addEventListener('click', () => {
 const patternType = btn.dataset.pattern;
 console.log('üé® Pattern button clicked:', patternType);
 aiCurrentPattern = patternType;

 // Show pattern controls
 const aiPatternControls = document.getElementById('ai-pattern-controls');
 if (aiPatternControls) {
 aiPatternControls.classList.remove('hidden');
 console.log('‚úÖ Pattern controls shown');
 } else {
 console.error('‚ùå AI pattern controls element not found');
 }

 // Handle Plain pattern - disable pattern color and opacity
 const patternColorInput = document.getElementById('ai-pattern-color');
 const opacityInput = document.getElementById('ai-pattern-opacity');
 const patternColorLabel = patternColorInput?.parentElement.querySelector('label');
 const opacityLabel = opacityInput?.parentElement.querySelector('label');

 if (patternType === 'plain') {
 // Disable pattern color and opacity for plain background
 if (patternColorInput) {
 patternColorInput.disabled = true;
 patternColorInput.style.opacity = '0.5';
 patternColorInput.style.cursor = 'not-allowed';
 }
 if (opacityInput) {
 opacityInput.disabled = true;
 opacityInput.style.opacity = '0.5';
 opacityInput.style.cursor = 'not-allowed';
 }
 if (patternColorLabel) patternColorLabel.style.opacity = '0.5';
 if (opacityLabel) opacityLabel.style.opacity = '0.5';
 console.log('üé® Plain pattern selected - disabled pattern color and opacity');
 } else {
 // Enable pattern color and opacity for other patterns
 if (patternColorInput) {
 patternColorInput.disabled = false;
 patternColorInput.style.opacity = '1';
 patternColorInput.style.cursor = 'pointer';
 }
 if (opacityInput) {
 opacityInput.disabled = false;
 opacityInput.style.opacity = '1';
 opacityInput.style.cursor = 'pointer';
 }
 if (patternColorLabel) patternColorLabel.style.opacity = '1';
 if (opacityLabel) opacityLabel.style.opacity = '1';
 console.log('üé® Pattern selected - enabled all controls');
 }

 // Update button states
 document.querySelectorAll('.ai-pattern-btn').forEach(b => {
 b.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/30', 'border-indigo-300', 'dark:border-indigo-600');
 });
 btn.classList.add('bg-indigo-50', 'dark:bg-indigo-900/30', 'border-indigo-300', 'dark:border-indigo-600');

 // Immediately apply the pattern with current control values
 console.log('üé® Immediately applying pattern:', patternType);
 applyAIPattern(patternType);
 });
 });

 // AI Apply pattern button
 const aiApplyPatternBtn = document.getElementById('ai-apply-pattern');
 if (aiApplyPatternBtn) {
 aiApplyPatternBtn.addEventListener('click', () => {
 console.log('üé® Apply pattern clicked, current pattern:', aiCurrentPattern);
 if (aiCurrentPattern) {
 applyAIPattern(aiCurrentPattern);
 } else {
 console.warn('‚ö†Ô∏è No pattern selected');
 }
 });
 console.log('‚úÖ Apply pattern button initialized');
 } else {
 console.error('‚ùå Apply pattern button not found');
 }

 // AI Clear pattern button
 const aiClearPatternBtn = document.getElementById('ai-clear-pattern');
 if (aiClearPatternBtn) {
 aiClearPatternBtn.addEventListener('click', () => {
 console.log('üé® Clear pattern clicked');
 clearCanvasPattern();
 aiCurrentPattern = null;

 // Hide pattern controls
 const aiPatternControls = document.getElementById('ai-pattern-controls');
 if (aiPatternControls) {
 aiPatternControls.classList.add('hidden');
 }

 // Reset button states
 document.querySelectorAll('.ai-pattern-btn').forEach(btn => {
 btn.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/30', 'border-indigo-300', 'dark:border-indigo-600');
 });
 });
 console.log('‚úÖ Clear pattern button initialized');
 } else {
 console.error('‚ùå Clear pattern button not found');
 }

 // AI Pattern control inputs - real-time updates with debouncing
 const aiPatternBackgroundColor = document.getElementById('ai-pattern-background-color');
 const aiPatternColor = document.getElementById('ai-pattern-color');
 const aiPatternOpacity = document.getElementById('ai-pattern-opacity');
 const aiPatternScale = document.getElementById('ai-pattern-scale');

 console.log('AI pattern controls found:', {
 backgroundColor: !!aiPatternBackgroundColor,
 patternColor: !!aiPatternColor,
 opacity: !!aiPatternOpacity,
 scale: !!aiPatternScale
 });

 // Debounce timer for real-time pattern updates
 let patternUpdateTimeout;

 [aiPatternBackgroundColor, aiPatternColor, aiPatternOpacity, aiPatternScale].forEach(input => {
 if (input) {
 input.addEventListener('input', () => {
 if (aiCurrentPattern) {
 console.log('üé® Pattern control changed, scheduling pattern update');

 // Clear previous timeout
 clearTimeout(patternUpdateTimeout);

 // Apply pattern immediately for visual feedback
 applyAIPattern(aiCurrentPattern);

 // Debounce the broadcasting to avoid spam
 patternUpdateTimeout = setTimeout(() => {
 console.log('üé® Debounced pattern update - ensuring broadcast');
 if (currentRoomId && aiCurrentPattern) {
 // Force a broadcast after debounce period
 const currentPattern = {
 type: aiCurrentPattern,
 backgroundColor: aiPatternBackgroundColor?.value || '#ffffff',
 patternColor: aiPatternColor?.value || '#6366f1',
 opacity: parseFloat(aiPatternOpacity?.value || '0.3'),
 scale: parseInt(aiPatternScale?.value || '30')
 };

 console.log('üöÄ Force broadcasting pattern after debounce:', currentPattern);
 sendCanvasOperation('background_changed', {
 background: 'css_pattern',
 pattern: currentPattern,
 changed_by: currentUserId,
 timestamp: Date.now()
 });
 }
 }, 300); // 300ms debounce
 }
 });
 }
 });
 }

 // Apply AI pattern function
 function applyAIPattern(patternType) {
 console.log('üé® Applying AI pattern:', patternType);

 const aiPatternBackgroundColor = document.getElementById('ai-pattern-background-color');
 const aiPatternColor = document.getElementById('ai-pattern-color');
 const aiPatternOpacity = document.getElementById('ai-pattern-opacity');
 const aiPatternScale = document.getElementById('ai-pattern-scale');

 const backgroundColor = aiPatternBackgroundColor ? aiPatternBackgroundColor.value : '#ffffff';
 const patternColor = aiPatternColor ? aiPatternColor.value : '#6366f1';
 const opacity = aiPatternOpacity ? parseFloat(aiPatternOpacity.value) : 0.3;
 const scale = aiPatternScale ? parseInt(aiPatternScale.value) : 30;

 console.log('üé® Pattern settings:', { backgroundColor, patternColor, opacity, scale });

 let cssPattern;
 switch (patternType) {
 case 'plain':
 // Plain background - just use the background color
 cssPattern = {
 backgroundColor: backgroundColor,
 backgroundImage: '',
 backgroundSize: '',
 backgroundPosition: '',
 backgroundRepeat: ''
 };
 break;
 case 'boxes':
 cssPattern = generateBoxesPattern(backgroundColor, patternColor, opacity, scale);
 break;
 case 'polka':
 cssPattern = generatePolkaPattern(backgroundColor, patternColor, opacity, scale);
 break;
 case 'graph':
 cssPattern = generateGraphPattern(backgroundColor, patternColor, opacity, scale);
 break;
 case 'lines':
 cssPattern = generateLinesPattern(backgroundColor, patternColor, opacity, scale);
 break;
 default:
 console.error('‚ùå Unknown pattern type:', patternType);
 return;
 }

 console.log('üé® Generated CSS pattern:', cssPattern);

 // Apply CSS pattern to canvas element
 applyCSSBackgroundToCanvas(cssPattern);

 // Store current pattern for persistence
 currentCanvasPattern = {
 type: patternType,
 backgroundColor: backgroundColor,
 patternColor: patternColor,
 opacity: opacity,
 scale: scale
 };

 // Save to localStorage
 saveCanvasPatternSettings();

 // Send pattern change to collaboration if in room
 if (currentRoomId) {
 console.log('üöÄ Broadcasting background pattern change to room:', currentRoomId);
 console.log('üé® Pattern data being sent:', currentCanvasPattern);

 const success = sendCanvasOperation('background_changed', {
 background: 'css_pattern',
 pattern: currentCanvasPattern,
 changed_by: currentUserId,
 timestamp: Date.now()
 });

 if (success) {
 console.log('‚úÖ Background pattern broadcast successful');
 } else {
 console.error('‚ùå Background pattern broadcast failed');
 }
 } else {
 console.log('‚ö†Ô∏è Not in a room, skipping background pattern broadcast');
 }

 console.log('‚úÖ Pattern applied successfully');
 }

 // Test function for background pattern broadcasting (call from console)
 window.testBackgroundBroadcast = function() {
 console.log('üß™ Testing background pattern broadcast...');
 console.log('üß™ Current room ID:', currentRoomId);
 console.log('üß™ Current user ID:', currentUserId);
 console.log('üß™ WebSocket state:', collaborationSocket?.readyState);

 if (!currentRoomId) {
 console.error('‚ùå Not in a room! Join a room first.');
 return;
 }

 const testPattern = {
 type: 'polka',
 backgroundColor: '#ff0000',
 patternColor: '#ffffff',
 opacity: 0.5,
 scale: 40
 };

 console.log('üß™ Sending test pattern:', testPattern);

 const success = sendCanvasOperation('background_changed', {
 background: 'css_pattern',
 pattern: testPattern,
 changed_by: currentUserId,
 timestamp: Date.now()
 });

 console.log('üß™ Test broadcast result:', success ? 'SUCCESS' : 'FAILED');
 };

 // Test function for debugging canvas state (call from console)
 window.debugCanvasState = function() {
 console.log('üß™ Canvas State Debug:');
 console.log('üß™ fabricCanvas.backgroundColor:', fabricCanvas.backgroundColor);
 console.log('üß™ currentCanvasPattern:', currentCanvasPattern);
 console.log('üß™ Current room ID:', currentRoomId);
 console.log('üß™ Is in room:', !!currentRoomId);

 const canvasElement = document.getElementById('main-canvas');
 if (canvasElement) {
 console.log('üß™ Canvas element styles:');
 console.log('  - backgroundColor:', canvasElement.style.backgroundColor);
 console.log('  - backgroundImage:', canvasElement.style.backgroundImage);
 console.log('  - backgroundSize:', canvasElement.style.backgroundSize);
 }

 // Show what would be sent in room creation
 const testCanvasState = {
 objects: [],
 background: fabricCanvas.backgroundColor || '#ffffff'
 };

 if (currentCanvasPattern) {
 testCanvasState.background = 'css_pattern';
 testCanvasState.pattern = currentCanvasPattern;
 }

 console.log('üß™ Canvas state that would be sent:', testCanvasState);
 };

 // Test function for keyboard shortcuts (call from console)
 window.testKeyboardShortcuts = function() {
 console.log('‚å®Ô∏è Testing keyboard shortcuts...');
 console.log('‚å®Ô∏è Available shortcuts:');
 console.log('  1 = Pen Tool');
 console.log('  2 = Line Tool');
 console.log('  3 = Arrow Tool');
 console.log('  4 = Circle Tool');
 console.log('  5 = Rectangle Tool');
 console.log('  6 = Highlight Rectangle Tool');
 console.log('  7 = Highlight Circle Tool');
 console.log('  8 = Text Tool');
 console.log('  9 = Select Tool');
 console.log('‚å®Ô∏è Current active element:', document.activeElement.tagName, document.activeElement.id);
 console.log('‚å®Ô∏è Is typing in input field:', isTypingInInputField());
 console.log('‚å®Ô∏è Current tool:', currentTool);
 console.log('‚å®Ô∏è Try pressing 1-9 keys to test shortcuts!');
 };

 // PDF Modal Variables
 let pdfModalDoc = null;
 let pdfModalCurrentPage = 1;
 let pdfModalTotalPages = 1;
 let pdfModalZoom = 1.0;
 let pdfModalCanvas = null;
 let pdfModalContext = null;

 // Function to preview PDF from group message in modal viewer
 window.previewPdfFromMessage = async function(downloadUrl, fileName) {
 try {
 console.log('üîÑ Loading PDF in modal viewer:', fileName);

 // Show the modal
 const modal = document.getElementById('pdf-viewer-modal');
 const loading = document.getElementById('pdf-modal-loading');
 const canvas = document.getElementById('pdf-modal-canvas');
 const canvasWrapper = document.getElementById('pdf-modal-canvas-wrapper');
 const filenameEl = document.getElementById('pdf-modal-filename');
 const downloadBtn = document.getElementById('pdf-modal-download');

 if (!modal || !loading || !canvas || !canvasWrapper || !filenameEl) {
 throw new Error('PDF modal elements not found');
 }

 // Setup modal
 modal.classList.remove('hidden');
 loading.style.display = 'flex';
 canvasWrapper.style.display = 'none';
 filenameEl.textContent = fileName;
 downloadBtn.href = downloadUrl;
 downloadBtn.download = fileName;

 // Initialize canvas
 pdfModalCanvas = canvas;
 pdfModalContext = canvas.getContext('2d');

 // Fetch and load PDF
 const response = await fetch(downloadUrl);
 if (!response.ok) {
 throw new Error(`Failed to fetch PDF: ${response.status}`);
 }

 const arrayBuffer = await response.arrayBuffer();
 const uint8Array = new Uint8Array(arrayBuffer);

 // Load PDF using PDF.js
 const loadingTask = pdfjsLib.getDocument(uint8Array);
 pdfModalDoc = await loadingTask.promise;
 pdfModalTotalPages = pdfModalDoc.numPages;
 pdfModalCurrentPage = 1;
 pdfModalZoom = 1.0;

 // Update UI
 document.getElementById('pdf-modal-total-pages').textContent = pdfModalTotalPages;
 document.getElementById('pdf-modal-current-page').textContent = pdfModalCurrentPage;
 document.getElementById('pdf-modal-zoom-level').textContent = '100%';

 // Render first page
 await renderPdfModalPage();

 // Hide loading, show canvas
 loading.style.display = 'none';
 canvasWrapper.style.display = 'flex';

 console.log('‚úÖ PDF loaded successfully in modal:', fileName);

 } catch (error) {
 console.error('‚ùå Error loading PDF in modal:', error);

 // Hide modal on error
 const modal = document.getElementById('pdf-viewer-modal');
 if (modal) modal.classList.add('hidden');

 addChatMessage('System', `‚ùå Error loading PDF: ${error.message}`, 'error');
 }
 };

 // Function to render current page in modal
 async function renderPdfModalPage() {
 if (!pdfModalDoc || !pdfModalCanvas || !pdfModalContext) return;

 try {
 const page = await pdfModalDoc.getPage(pdfModalCurrentPage);

 // Get the container dimensions (the scrollable area)
 const container = document.getElementById('pdf-modal-container');
 const containerRect = container.getBoundingClientRect();
 const availableWidth = containerRect.width - 32; // Account for padding
 const availableHeight = containerRect.height - 32;

 // Get the original page dimensions
 const originalViewport = page.getViewport({ scale: 1.0 });

 // Calculate the scale to fit the page within available space at 100% zoom
 const fitScale = Math.min(
 availableWidth / originalViewport.width,
 availableHeight / originalViewport.height,
 1.0 // Don't scale up beyond original size at 100%
 );

 // Apply user zoom to the fit scale
 const finalScale = fitScale * pdfModalZoom;
 const viewport = page.getViewport({ scale: finalScale });

 // Use device pixel ratio for crisp rendering
 const devicePixelRatio = window.devicePixelRatio || 1;
 const canvasWidth = viewport.width * devicePixelRatio;
 const canvasHeight = viewport.height * devicePixelRatio;

 // Set canvas size
 pdfModalCanvas.width = canvasWidth;
 pdfModalCanvas.height = canvasHeight;

 // Set display size (this is what the user sees)
 pdfModalCanvas.style.width = Math.floor(viewport.width) + 'px';
 pdfModalCanvas.style.height = Math.floor(viewport.height) + 'px';

 // Reset and scale context for device pixel ratio
 pdfModalContext.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
 pdfModalContext.scale(devicePixelRatio, devicePixelRatio);

 // Clear canvas
 pdfModalContext.clearRect(0, 0, viewport.width, viewport.height);

 // Render the page
 const renderContext = {
 canvasContext: pdfModalContext,
 viewport: viewport
 };

 await page.render(renderContext).promise;

 // Update page number display
 document.getElementById('pdf-modal-current-page').textContent = pdfModalCurrentPage;

 console.log(`üìÑ Rendered page ${pdfModalCurrentPage} at ${Math.round(pdfModalZoom * 100)}% zoom (${Math.floor(viewport.width)}x${Math.floor(viewport.height)})`);

 } catch (error) {
 console.error('Error rendering PDF page:', error);
 }
 }

 // Initialize PDF modal controls
 function initializePdfModal() {
 // Close button
 const closeBtn = document.getElementById('close-pdf-viewer');
 if (closeBtn) {
 closeBtn.addEventListener('click', () => {
 const modal = document.getElementById('pdf-viewer-modal');
 if (modal) modal.classList.add('hidden');
 });
 }

 // Previous page
 const prevBtn = document.getElementById('pdf-modal-prev');
 if (prevBtn) {
 prevBtn.addEventListener('click', async () => {
 if (pdfModalCurrentPage > 1) {
 pdfModalCurrentPage--;
 await renderPdfModalPage();
 }
 });
 }

 // Next page
 const nextBtn = document.getElementById('pdf-modal-next');
 if (nextBtn) {
 nextBtn.addEventListener('click', async () => {
 if (pdfModalCurrentPage < pdfModalTotalPages) {
 pdfModalCurrentPage++;
 await renderPdfModalPage();
 }
 });
 }

 // Zoom in
 const zoomInBtn = document.getElementById('pdf-modal-zoom-in');
 if (zoomInBtn) {
 zoomInBtn.addEventListener('click', async () => {
 pdfModalZoom = Math.min(pdfModalZoom * 1.25, 4.0); // Increased max zoom and better increment
 document.getElementById('pdf-modal-zoom-level').textContent = Math.round(pdfModalZoom * 100) + '%';
 await renderPdfModalPage();
 });
 }

 // Zoom out
 const zoomOutBtn = document.getElementById('pdf-modal-zoom-out');
 if (zoomOutBtn) {
 zoomOutBtn.addEventListener('click', async () => {
 pdfModalZoom = Math.max(pdfModalZoom / 1.25, 0.25); // Decreased min zoom and better increment
 document.getElementById('pdf-modal-zoom-level').textContent = Math.round(pdfModalZoom * 100) + '%';
 await renderPdfModalPage();
 });
 }

 // Zoom reset (click on zoom percentage)
 const zoomLevel = document.getElementById('pdf-modal-zoom-level');
 if (zoomLevel) {
 zoomLevel.addEventListener('click', async () => {
 pdfModalZoom = 1.0;
 document.getElementById('pdf-modal-zoom-level').textContent = '100%';
 await renderPdfModalPage();
 });
 }

 // Keyboard navigation
 document.addEventListener('keydown', (e) => {
 const modal = document.getElementById('pdf-viewer-modal');
 if (!modal || modal.classList.contains('hidden')) return;

 switch (e.key) {
 case 'Escape':
 modal.classList.add('hidden');
 break;
 case 'ArrowLeft':
 if (pdfModalCurrentPage > 1) {
 pdfModalCurrentPage--;
 renderPdfModalPage();
 }
 break;
 case 'ArrowRight':
 if (pdfModalCurrentPage < pdfModalTotalPages) {
 pdfModalCurrentPage++;
 renderPdfModalPage();
 }
 break;
 case '+':
 case '=':
 pdfModalZoom = Math.min(pdfModalZoom * 1.25, 4.0);
 document.getElementById('pdf-modal-zoom-level').textContent = Math.round(pdfModalZoom * 100) + '%';
 renderPdfModalPage();
 break;
 case '-':
 pdfModalZoom = Math.max(pdfModalZoom / 1.25, 0.25);
 document.getElementById('pdf-modal-zoom-level').textContent = Math.round(pdfModalZoom * 100) + '%';
 renderPdfModalPage();
 break;
 }
 });

 console.log('‚úÖ PDF modal controls initialized');
 }

 // Debug function to check host status
 window.debugHostStatus = function() {
 console.log('=== HOST STATUS DEBUG ===');
 console.log('Current state:');
 console.log('- currentUserId:', currentUserId);
 console.log('- currentRoomId:', currentRoomId);
 console.log('- currentRoomHostId:', currentRoomHostId);
 console.log('- isConnected:', isConnected);
 console.log('- Am I the host?:', currentUserId === currentRoomHostId);

 const savedSession = loadRoomSession();
 console.log('Saved session:');
 console.log('- Session exists:', !!savedSession);
 if (savedSession) {
 console.log('- roomId:', savedSession.roomId);
 console.log('- userId:', savedSession.userId);
 console.log('- userName:', savedSession.userName);
 console.log('- isHost:', savedSession.isHost);
 console.log('- timestamp:', new Date(savedSession.timestamp));
 }

 console.log('Room users:');
 roomUsers.forEach((user, userId) => {
 console.log(`- ${userId}: ${user.name} ${userId === currentRoomHostId ? '(HOST)' : ''} ${userId === currentUserId ? '(ME)' : ''}`);
 });

 console.log('=== END HOST DEBUG ===');
 };

 // Function to manually request host restoration
 window.requestHostRestoration = function() {
 console.log('üîÑ Manually requesting host restoration...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 console.log('‚ùå No saved session or user was not host');
 addChatMessage('System', 'Cannot request host restoration - you were not previously a host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 console.log('‚ùå Not connected to collaboration server');
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ You are already the host');
 addChatMessage('System', 'You are already the host');
 return;
 }

 console.log('üì§ Sending host restoration request...');
 collaborationSocket.send(JSON.stringify({
 type: 'request_host_restoration',
 reason: 'manual_request'
 }));

 addChatMessage('System', 'Requesting host privilege restoration...');
 };

 // Function to request host transfer from current host
 window.requestHostFromCurrent = function() {
 console.log('üîÑ Requesting host transfer from current host...');

 if (!currentRoomHostId || !collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 console.log('‚ùå Not connected or no current host');
 addChatMessage('System', 'Not connected to room or no current host found');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ You are already the host');
 addChatMessage('System', 'You are already the host');
 return;
 }

 const currentHost = roomUsers.get(currentRoomHostId);
 const hostName = currentHost ? currentHost.name : 'Unknown';
 const myName = localStorage.getItem('userName') || 'Anonymous';

 console.log(`üì§ Sending host transfer request to ${hostName}...`);

 // Send a message to the current host requesting transfer
 collaborationSocket.send(JSON.stringify({
 type: 'request_host_transfer',
 from_user_id: currentUserId,
 from_user_name: myName,
 to_user_id: currentRoomHostId,
 to_user_name: hostName,
 reason: 'previous_host_restoration'
 }));

 addChatMessage('System', `Sent host transfer request to ${hostName}. They will see a notification and can choose to transfer host privileges to you.`);
 };

 // Function to automatically reclaim host if we're the only user
 window.reclaimHostIfAlone = function() {
 console.log('üîÑ Checking if we can reclaim host status...');

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 console.log('‚ùå Not connected to collaboration server');
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ You are already the host');
 addChatMessage('System', 'You are already the host');
 return;
 }

 console.log('Room analysis:');
 console.log('- Room users count:', roomUsers.size);
 console.log('- Current host ID:', currentRoomHostId);
 console.log('- My user ID:', currentUserId);

 if (roomUsers.size <= 1) {
 console.log('üì§ Only user in room - claiming host privileges...');
 addChatMessage('System', 'You are the only user in the room. Claiming host privileges...');

 collaborationSocket.send(JSON.stringify({
 type: 'claim_host',
 reason: 'only_user_manual'
 }));
 } else {
 const currentHost = roomUsers.get(currentRoomHostId);
 if (currentHost) {
 addChatMessage('System', `Cannot reclaim host - ${currentHost.name} is currently the host. Use requestHostFromCurrent() to ask them to transfer it to you.`);
 } else {
 console.log('üì§ Current host not in room - claiming host privileges...');
 addChatMessage('System', 'Current host not found in room. Claiming host privileges...');

 collaborationSocket.send(JSON.stringify({
 type: 'claim_host',
 reason: 'host_not_found_manual'
 }));
 }
 }
 };

 // Simple host restoration that works with existing server
 window.simpleHostRestore = function() {
 console.log('üîÑ Attempting simple host restoration...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You were not previously a host of this room');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 console.log('üì§ Attempting host restoration via room recreation...');
 addChatMessage('System', 'Attempting to restore host privileges...');

 // Store current room state
 const currentRoom = currentRoomId;

 // Strategy: Leave room and immediately rejoin
 // This sometimes triggers host assignment if you're the first to rejoin
 collaborationSocket.send(JSON.stringify({
 type: 'leave_room'
 }));

 setTimeout(() => {
 console.log('üîÑ Rejoining room for host restoration...');
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: currentRoom
 }));

 // Check if we got host after rejoining
 setTimeout(() => {
 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ Host restoration successful!');
 addChatMessage('System', '‚úÖ Host privileges successfully restored!');

 // Update session
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoom, currentUserId, userName, true);
 } else {
 console.log('‚ùå Host restoration failed');
 addChatMessage('System', 'Host restoration failed. You may need to ask the current host to transfer privileges to you.');
 }
 }, 2000);
 }, 1000);
 };

 // Room owner restoration function
 window.restoreRoomOwner = function() {
 console.log('üîÑ Attempting to restore room owner privileges...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the owner of this room');
 console.log('‚ùå No saved session or user was not room owner');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 console.log('‚úÖ You are already the host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 console.log('‚ùå Not connected to collaboration server');
 return;
 }

 console.log('üì§ Sending room owner restoration request...');
 addChatMessage('System', 'Requesting room owner privilege restoration...');

 // Send room owner restoration request
 collaborationSocket.send(JSON.stringify({
 type: 'restore_room_owner',
 room_id: currentRoomId,
 owner_id: currentUserId,
 owner_name: savedSession.userName
 }));

 // Also try to register as owner in case it wasn't done before
 setTimeout(() => {
 collaborationSocket.send(JSON.stringify({
 type: 'register_room_owner',
 room_id: currentRoomId,
 owner_id: currentUserId,
 owner_name: savedSession.userName
 }));
 }, 1000);
 };

 // Function to check room ownership status
 window.checkRoomOwnership = function() {
 console.log('=== ROOM OWNERSHIP DEBUG ===');

 const savedSession = loadRoomSession();
 console.log('Saved session:', savedSession);
 console.log('- Is room owner:', savedSession?.isHost);
 console.log('- Room ID:', savedSession?.roomId);
 console.log('- User ID:', savedSession?.userId);
 console.log('- User Name:', savedSession?.userName);

 console.log('Current state:');
 console.log('- Current room ID:', currentRoomId);
 console.log('- Current user ID:', currentUserId);
 console.log('- Current host ID:', currentRoomHostId);
 console.log('- Am I the host?:', currentUserId === currentRoomHostId);

 if (savedSession?.isHost && currentUserId !== currentRoomHostId) {
 console.log('‚ö†Ô∏è You should be the room owner but are not currently host');
 console.log('üí° Run restoreRoomOwner() to attempt restoration');
 } else if (savedSession?.isHost && currentUserId === currentRoomHostId) {
 console.log('‚úÖ You are the room owner and currently have host privileges');
 } else {
 console.log('‚ÑπÔ∏è You are not the room owner');
 }

 console.log('=== END OWNERSHIP DEBUG ===');
 };

 // WORKING HOST RESTORATION - Forces host transfer using existing server functionality
 window.forceHostTransfer = function() {
 console.log('üîÑ FORCING host transfer using existing server functionality...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 console.log('‚ùå You are not the room creator');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 console.log('‚úÖ You are already the host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 console.log('‚ùå Not connected to collaboration server');
 return;
 }

 // Find the current host
 const currentHost = roomUsers.get(currentRoomHostId);
 if (!currentHost) {
 console.log('üì§ No current host found - claiming host status directly');
 addChatMessage('System', 'No current host found. Claiming host status...');

 // Force ourselves as host locally
 currentRoomHostId = currentUserId;
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);
 addChatMessage('System', '‚úÖ Host status claimed successfully');
 updateUsersTooltip();
 return;
 }

 console.log(`üì§ Requesting host transfer from ${currentHost.name}...`);
 addChatMessage('System', `Requesting host transfer from ${currentHost.name} (current host)...`);

 // Send a message to the current host requesting transfer
 // This uses the existing group messaging system
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 const myName = localStorage.getItem('userName') || 'Anonymous';
 const transferMessage = `üè† HOST TRANSFER REQUEST: ${myName} (room creator) is requesting host privileges back. Please transfer host to ${myName}.`;

 groupMessageSocket.send(JSON.stringify({
 type: 'send_message',
 room_id: currentRoomId,
 content: transferMessage,
 sender_name: 'System'
 }));

 addChatMessage('System', `Host transfer request sent to ${currentHost.name} via group chat`);
 }

 // Also try to use the existing transfer_host functionality if we can
 // This is a hack but might work
 setTimeout(() => {
 console.log('üîß Attempting direct host transfer...');

 // Temporarily set ourselves as host to use transfer function
 const originalHostId = currentRoomHostId;
 currentRoomHostId = currentUserId;

 // Try to transfer to ourselves (this might work)
 collaborationSocket.send(JSON.stringify({
 type: 'transfer_host',
 target_user_id: currentUserId
 }));

 // Restore original host if it doesn't work
 setTimeout(() => {
 if (currentUserId !== currentRoomHostId) {
 currentRoomHostId = originalHostId;
 console.log('‚ùå Direct transfer failed, restored original host');
 } else {
 console.log('‚úÖ Direct transfer succeeded!');
 addChatMessage('System', '‚úÖ Host privileges restored via direct transfer!');
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);
 }
 }, 2000);
 }, 3000);
 };

 // WORKING SIMPLE SOLUTION - Just claim host status locally
 window.claimHostLocally = function() {
 console.log('üîß CLAIMING host status locally...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 return;
 }

 console.log('üîß Setting host status locally...');
 currentRoomHostId = currentUserId;

 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);

 addChatMessage('System', '‚úÖ Host status claimed locally (you are the room creator)');
 updateUsersTooltip();

 console.log('‚úÖ Host status set locally - you now have host privileges');
 };

 // === CLIENT-SIDE HOST OVERRIDE SYSTEM ===

 // Function to check if current user is host (with override support)
 function isCurrentUserHost() {
 // If client-side override is active, use that
 if (hostOverrideActive && clientSideHostOverride === currentUserId) {
 return true;
 }

 // Otherwise use server's host assignment
 return currentUserId === currentRoomHostId;
 }

 // Function to activate host override for room creator
 function activateHostOverride() {
 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 console.log('‚ùå Cannot activate host override - you are not the room creator');
 return false;
 }

 console.log('üîß ACTIVATING CLIENT-SIDE HOST OVERRIDE');
 clientSideHostOverride = currentUserId;
 roomCreatorId = currentUserId;
 hostOverrideActive = true;

 // Update UI to reflect host status
 updateUsersTooltip();

 addChatMessage('System', 'üîß CLIENT-SIDE HOST OVERRIDE ACTIVATED - You now have host privileges regardless of server state');
 console.log('‚úÖ Host override activated - you are now the host');

 return true;
 }

 // Function to deactivate host override
 function deactivateHostOverride() {
 console.log('üîß DEACTIVATING CLIENT-SIDE HOST OVERRIDE');
 clientSideHostOverride = null;
 hostOverrideActive = false;

 updateUsersTooltip();
 addChatMessage('System', 'üîß Client-side host override deactivated - using server host assignment');
 console.log('‚úÖ Host override deactivated');
 }

 // Function to force host status (NUCLEAR OPTION)
 window.forceHostStatus = function() {
 console.log('üí• NUCLEAR OPTION: FORCING HOST STATUS');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', '‚ùå You are not the room creator - cannot force host status');
 return;
 }

 // Activate client-side override
 if (activateHostOverride()) {
 // Also try to set server-side host
 currentRoomHostId = currentUserId;

 // Save session
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);

 addChatMessage('System', 'üí• HOST STATUS FORCED - You now have full host privileges');
 console.log('üí• HOST STATUS FORCED SUCCESSFULLY');
 }
 };

 // Function to check host override status
 window.checkHostOverride = function() {
 console.log('=== HOST OVERRIDE STATUS ===');
 console.log('- Host override active:', hostOverrideActive);
 console.log('- Client-side host:', clientSideHostOverride);
 console.log('- Room creator:', roomCreatorId);
 console.log('- Server host:', currentRoomHostId);
 console.log('- Current user:', currentUserId);
 console.log('- Is user host (with override):', isCurrentUserHost());
 console.log('- Is user host (server only):', currentUserId === currentRoomHostId);

 const savedSession = loadRoomSession();
 console.log('- Saved session isHost:', savedSession?.isHost);

 if (hostOverrideActive) {
 console.log('‚úÖ HOST OVERRIDE IS ACTIVE - You have host privileges');
 } else if (savedSession?.isHost) {
 console.log('üí° You are the room creator - run forceHostStatus() to activate override');
 } else {
 console.log('‚ÑπÔ∏è You are not the room creator');
 }
 console.log('=== END HOST OVERRIDE STATUS ===');
 };

 // Test host powers function
 window.testHostPowers = function() {
 console.log('üß™ TESTING HOST POWERS...');

 if (!isCurrentUserHost()) {
 console.log('‚ùå You are not the host - cannot test host powers');
 addChatMessage('System', '‚ùå You are not the host - cannot test host powers');
 return;
 }

 console.log('‚úÖ Host check passed - you have host privileges');
 addChatMessage('System', '‚úÖ Host powers test: You have host privileges');

 // Test if host controls are visible
 const usersList = document.getElementById('users-list');
 if (usersList) {
 const hostControls = usersList.querySelectorAll('button[title*="Kick"], button[title*="Mute"]');
 console.log(`Found ${hostControls.length} host control buttons in UI`);
 addChatMessage('System', `Found ${hostControls.length} host control buttons in UI`);
 } else {
 console.log('Users list not found');
 }

 // List available host actions
 console.log('Available host actions:');
 console.log('- kickUser(userId, userName) - Kick a user');
 console.log('- transferHost(userId, userName) - Transfer host');
 console.log('- hostMuteUserVideo(userId, userName) - Mute user video');
 console.log('- hostMuteUserAudio(userId, userName) - Mute user audio');

 addChatMessage('System', 'Host powers test complete - check console for details');
 };

 // === REAL SERVER-SIDE HOST RESTORATION ===

 // Function to actually restore host status on the server
 window.realHostRestore = function() {
 console.log('üîß ATTEMPTING REAL SERVER-SIDE HOST RESTORATION...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 console.log('üîß Strategy: Exploiting room creation mechanism...');
 addChatMessage('System', 'Attempting to restore host privileges on server...');

 // Strategy 1: Try to "create" the existing room (this might make us host)
 console.log('üì§ Sending create_room request for existing room...');
 collaborationSocket.send(JSON.stringify({
 type: 'create_room',
 room_id: currentRoomId // Try to create the room we're already in
 }));

 // Strategy 2: If that doesn't work, try leaving and rejoining as "creator"
 setTimeout(() => {
 if (currentUserId !== currentRoomHostId) {
 console.log('üîß Room creation didn\'t work, trying leave/rejoin as creator...');

 // Leave the room
 collaborationSocket.send(JSON.stringify({
 type: 'leave_room'
 }));

 // Wait a moment then rejoin
 setTimeout(() => {
 console.log('üì§ Rejoining room as original creator...');
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: currentRoomId
 }));

 // Check if we got host after rejoining
 setTimeout(() => {
 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ Real host restoration successful!');
 addChatMessage('System', '‚úÖ Host privileges restored on server!');

 // Deactivate client-side override since server now recognizes us
 if (hostOverrideActive) {
 hostOverrideActive = false;
 clientSideHostOverride = null;
 console.log('üîß Deactivated client-side override - server now recognizes host status');
 }

 updateUsersTooltip();
 } else {
 console.log('‚ùå Real host restoration failed');
 addChatMessage('System', 'Server-side host restoration failed. You may need to ask current host to transfer privileges.');
 }
 }, 3000);
 }, 1000);
 }
 }, 2000);
 };

 // Function to force server to recognize you as host by recreating room
 window.forceServerHostRecognition = function() {
 console.log('üí• FORCING SERVER TO RECOGNIZE HOST STATUS...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 addChatMessage('System', 'Forcing server to recognize your host status...');
 console.log('üîß Using aggressive host restoration...');

 // Store current room info
 const roomId = currentRoomId;
 const userName = localStorage.getItem('userName') || 'Anonymous';

 // Strategy: Disconnect and reconnect as room creator
 console.log('üì§ Step 1: Disconnecting from collaboration server...');
 collaborationSocket.close();

 // Wait for disconnect then reconnect
 setTimeout(() => {
 console.log('üì§ Step 2: Reconnecting to collaboration server...');

 // Reconnect to collaboration server
 connectToCollaborationServer(() => {
 console.log('üì§ Step 3: Creating room as original creator...');

 // Try to create the room (this should make us host)
 collaborationSocket.send(JSON.stringify({
 type: 'create_room',
 room_id: roomId
 }));

 // If creation fails, join the room
 setTimeout(() => {
 if (!isConnected || currentRoomId !== roomId) {
 console.log('üì§ Step 4: Joining room as fallback...');
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: roomId
 }));
 }

 // Check final result
 setTimeout(() => {
 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ FORCED HOST RECOGNITION SUCCESSFUL!');
 addChatMessage('System', '‚úÖ Server now recognizes you as host!');

 // Deactivate override
 if (hostOverrideActive) {
 hostOverrideActive = false;
 clientSideHostOverride = null;
 }

 updateUsersTooltip();
 } else {
 console.log('‚ùå Forced host recognition failed');
 addChatMessage('System', 'Failed to force server recognition. Server may not support this method.');
 }
 }, 3000);
 }, 1000);
 });
 }, 2000);
 };

 // === REAL SERVER-SIDE HOST RESTORATION ===

 // Function to actually restore host status on the server
 window.realHostRestore = function() {
 console.log('üîß ATTEMPTING REAL SERVER-SIDE HOST RESTORATION...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (currentUserId === currentRoomHostId) {
 addChatMessage('System', 'You are already the host');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 console.log('üîß Strategy: Exploiting room creation mechanism...');
 addChatMessage('System', 'Attempting to restore host privileges on server...');

 // Strategy 1: Try to "create" the existing room (this might make us host)
 console.log('üì§ Sending create_room request for existing room...');
 collaborationSocket.send(JSON.stringify({
 type: 'create_room',
 room_id: currentRoomId // Try to create the room we're already in
 }));

 // Strategy 2: If that doesn't work, try leaving and rejoining as "creator"
 setTimeout(() => {
 if (currentUserId !== currentRoomHostId) {
 console.log('üîß Room creation didn\'t work, trying leave/rejoin as creator...');

 // Leave the room
 collaborationSocket.send(JSON.stringify({
 type: 'leave_room'
 }));

 // Wait a moment then rejoin
 setTimeout(() => {
 console.log('üì§ Rejoining room as original creator...');
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: currentRoomId
 }));

 // Check if we got host after rejoining
 setTimeout(() => {
 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ Real host restoration successful!');
 addChatMessage('System', '‚úÖ Host privileges restored on server!');

 // Deactivate client-side override since server now recognizes us
 if (hostOverrideActive) {
 hostOverrideActive = false;
 clientSideHostOverride = null;
 console.log('üîß Deactivated client-side override - server now recognizes host status');
 }

 updateUsersTooltip();
 } else {
 console.log('‚ùå Real host restoration failed');
 addChatMessage('System', 'Server-side host restoration failed. You may need to ask current host to transfer privileges.');
 }
 }, 3000);
 }, 1000);
 }
 }, 2000);
 };

 // Function to force server to recognize you as host by recreating room
 window.forceServerHostRecognition = function() {
 console.log('üí• FORCING SERVER TO RECOGNIZE HOST STATUS...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 addChatMessage('System', 'Forcing server to recognize your host status...');
 console.log('üîß Using aggressive host restoration...');

 // Store current room info
 const roomId = currentRoomId;
 const userName = localStorage.getItem('userName') || 'Anonymous';

 // Strategy: Disconnect and reconnect as room creator
 console.log('üì§ Step 1: Disconnecting from collaboration server...');
 collaborationSocket.close();

 // Wait for disconnect then reconnect
 setTimeout(() => {
 console.log('üì§ Step 2: Reconnecting to collaboration server...');

 // Reconnect to collaboration server
 connectToCollaborationServer(() => {
 console.log('üì§ Step 3: Creating room as original creator...');

 // Try to create the room (this should make us host)
 collaborationSocket.send(JSON.stringify({
 type: 'create_room',
 room_id: roomId
 }));

 // If creation fails, join the room
 setTimeout(() => {
 if (!isConnected || currentRoomId !== roomId) {
 console.log('üì§ Step 4: Joining room as fallback...');
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: roomId
 }));
 }

 // Check final result
 setTimeout(() => {
 if (currentUserId === currentRoomHostId) {
 console.log('‚úÖ FORCED HOST RECOGNITION SUCCESSFUL!');
 addChatMessage('System', '‚úÖ Server now recognizes you as host!');

 // Deactivate override
 if (hostOverrideActive) {
 hostOverrideActive = false;
 clientSideHostOverride = null;
 }

 updateUsersTooltip();
 } else {
 console.log('‚ùå Forced host recognition failed');
 addChatMessage('System', 'Failed to force server recognition. Server may not support this method.');
 }
 }, 3000);
 }, 1000);
 });
 }, 2000);
 };

 // === NUCLEAR HOST POWERS - BYPASS SERVER ENTIRELY ===

 // Nuclear kick function - bypasses server validation
 window.nuclearKick = function(targetUserId, targetUserName) {
 console.log(`üí• NUCLEAR KICK: Removing ${targetUserName} (${targetUserId}) client-side`);

 if (!targetUserId || targetUserId === currentUserId) {
 addChatMessage('System', 'Cannot kick yourself or invalid user');
 return;
 }

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 // Confirm kick action
 if (!confirm(`NUCLEAR KICK: Remove ${targetUserName} from the room? This bypasses server validation.`)) {
 return;
 }

 // Remove user locally immediately
 const kickedUser = roomUsers.get(targetUserId);
 if (kickedUser) {
 console.log(`üîß Removing ${targetUserName} from local room state...`);

 // Remove from room users
 roomUsers.delete(targetUserId);

 // Remove cursor
 removeUserCursor(targetUserId);

 // Update UI
 updateUserCount();
 updateUsersTooltip();

 // Remove from video call if active
 if (videoCallManager && videoCallManager.isActive && targetUserId !== currentUserId) {
 videoCallManager.handleUserLeft(targetUserId);
 console.log(`Removed ${targetUserName} from video call`);
 }

 // Update video status indicator
 if (typeof videoCallStatusIndicator !== 'undefined') {
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, videoCallStatusIndicator.remoteCallActive, videoCallManager.participants.size);
 }

 // Add system message
 addChatMessage('System', `üí• ${targetUserName} was removed from the room (nuclear kick)`);
 console.log(`‚úÖ Nuclear kick successful: ${targetUserName}`);

 // Try to send a message to group chat about the kick
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 const myName = localStorage.getItem('userName') || 'Anonymous';
 groupMessageSocket.send(JSON.stringify({
 type: 'send_message',
 room_id: currentRoomId,
 content: `üö´ ${targetUserName} was removed from the room by ${myName} (room creator)`,
 sender_name: 'System'
 }));
 }
 } else {
 console.log(`‚ùå User ${targetUserId} not found in room`);
 addChatMessage('System', 'User not found in room');
 }
 };

 // Nuclear mute function - handles muting locally
 window.nuclearMute = function(targetUserId, targetUserName, muteType = 'video') {
 console.log(`üí• NUCLEAR MUTE: Muting ${targetUserName}'s ${muteType}`);

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (!targetUserId || targetUserId === currentUserId) {
 addChatMessage('System', 'Cannot mute yourself or invalid user');
 return;
 }

 // For video calls, try to mute them locally
 if (videoCallManager && videoCallManager.isActive) {
 console.log(`üîß Attempting to mute ${targetUserName}'s ${muteType} in video call...`);

 // This is a hack - try to access their media stream and mute it
 // Note: This might not work due to browser security, but worth trying
 const peerConnection = videoCallManager.peerConnections?.get(targetUserId);
 if (peerConnection) {
 console.log(`Found peer connection for ${targetUserName}`);
 // Add logic here to mute their stream if possible
 }
 }

 // Send message about the mute
 addChatMessage('System', `üí• Attempted to mute ${targetUserName}'s ${muteType} (nuclear mute)`);

 // Send notification via group chat
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 const myName = localStorage.getItem('userName') || 'Anonymous';
 groupMessageSocket.send(JSON.stringify({
 type: 'send_message',
 room_id: currentRoomId,
 content: `üîá ${targetUserName}'s ${muteType} was muted by ${myName} (room creator)`,
 sender_name: 'System'
 }));
 }
 };

 // Nuclear transfer host - forces host transfer locally
 window.nuclearTransferHost = function(targetUserId, targetUserName) {
 console.log(`üí• NUCLEAR TRANSFER: Making ${targetUserName} the host`);

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', 'You are not the room creator');
 return;
 }

 if (!targetUserId || targetUserId === currentUserId) {
 addChatMessage('System', 'Cannot transfer to yourself or invalid user');
 return;
 }

 if (!roomUsers.has(targetUserId)) {
 addChatMessage('System', 'Target user not found in room');
 return;
 }

 // Confirm transfer
 if (!confirm(`NUCLEAR TRANSFER: Make ${targetUserName} the host? This bypasses server validation.`)) {
 return;
 }

 console.log(`üîß Transferring host to ${targetUserName} locally...`);

 // Update host locally
 const oldHostId = currentRoomHostId;
 currentRoomHostId = targetUserId;

 // Deactivate our override since we're transferring
 if (hostOverrideActive && clientSideHostOverride === currentUserId) {
 hostOverrideActive = false;
 clientSideHostOverride = null;
 console.log('üîß Deactivated host override after transfer');
 }

 // Update UI
 updateUsersTooltip();

 // Add system message
 addChatMessage('System', `üí• Host privileges transferred to ${targetUserName} (nuclear transfer)`);
 console.log(`‚úÖ Nuclear transfer successful: ${targetUserName} is now host`);

 // Send notification via group chat
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 const myName = localStorage.getItem('userName') || 'Anonymous';
 groupMessageSocket.send(JSON.stringify({
 type: 'send_message',
 room_id: currentRoomId,
 content: `üëë ${myName} transferred host privileges to ${targetUserName}`,
 sender_name: 'System'
 }));
 }
 };

 // === COMPREHENSIVE HOST POWERS TEST ===

 window.testNuclearPowers = function() {
 console.log('üí• TESTING NUCLEAR HOST POWERS...');

 const savedSession = loadRoomSession();
 if (!savedSession || !savedSession.isHost) {
 addChatMessage('System', '‚ùå You are not the room creator - cannot use nuclear powers');
 return;
 }

 console.log('‚úÖ Room creator check passed');
 addChatMessage('System', 'üí• Nuclear host powers available - you are the room creator');

 // List available nuclear commands
 console.log('Available nuclear commands:');
 console.log('- nuclearKick(userId, userName) - Remove user from room');
 console.log('- nuclearMute(userId, userName, "video") - Mute user video');
 console.log('- nuclearMute(userId, userName, "audio") - Mute user audio');
 console.log('- nuclearTransferHost(userId, userName) - Transfer host');

 // Show current room users for reference
 console.log('Current room users:');
 roomUsers.forEach((user, userId) => {
 console.log(`- ${userId}: ${user.name} ${userId === currentUserId ? '(YOU)' : ''}`);
 });

 addChatMessage('System', 'üí• Nuclear powers test complete - check console for available commands');
 addChatMessage('System', 'Example: nuclearKick("user123", "Alice") to remove Alice');
 };

 // Quick nuclear kick function for easy use
 window.quickKick = function(userName) {
 console.log(`üîç Looking for user: ${userName}`);

 let targetUserId = null;
 let targetUserName = null;

 // Find user by name
 roomUsers.forEach((user, userId) => {
 if (user.name.toLowerCase().includes(userName.toLowerCase())) {
 targetUserId = userId;
 targetUserName = user.name;
 }
 });

 if (targetUserId) {
 console.log(`Found user: ${targetUserName} (${targetUserId})`);
 nuclearKick(targetUserId, targetUserName);
 } else {
 console.log(`‚ùå User not found: ${userName}`);
 addChatMessage('System', `User not found: ${userName}`);

 // Show available users
 console.log('Available users:');
 roomUsers.forEach((user, userId) => {
 if (userId !== currentUserId) {
 console.log(`- ${user.name}`);
 }
 });
 }
 };

 // Initialize AI pattern controls when DOM is ready
 setTimeout(initializeAIPatternControls, 100);

 // Setup pattern transform listeners
 setTimeout(setupPatternTransformListeners, 200);

 // Also reinitialize when AI settings modal is opened
 const aiSettingsBtn = document.getElementById('ai-settings-btn');
 if (aiSettingsBtn) {
 aiSettingsBtn.addEventListener('click', () => {
 setTimeout(initializeAIPatternControls, 100);
 });
 }

 // CSS Pattern generation functions
 // NOTE: CSS backgrounds won't appear in Fabric.js exports - they only affect the canvas element's visual appearance
 function generateLinesPattern(backgroundColor, patternColor, opacity, scale) {
 // Lines v3: horizontal lines pattern based on your exact CSS specification
 const baseSize = 32; // Base pattern size in pixels
 const lineWidth = 1.6; // Line thickness in pixels

 // Scale calculations
 const scaledSize = baseSize * (scale / 50); // Normalize scale (50 is middle value)
 const scaledLineWidth = lineWidth * (scale / 50);

 // Colors - use the exact colors from your specification
 const bgColor = backgroundColor; // Use the background color as-is
 const lineColor = patternColor; // Use the pattern color as-is

 // Create the exact pattern from your CSS
 return {
 backgroundColor: bgColor,
 backgroundSize: `${scaledSize}px ${scaledSize}px`,
 backgroundImage: `repeating-linear-gradient(0deg, ${lineColor}, ${lineColor} ${scaledLineWidth}px, ${bgColor} ${scaledLineWidth}px, ${bgColor})`,
 backgroundPosition: '0 0'
 };
 }

 function generateBoxesPattern(backgroundColor, patternColor, opacity, scale) {
 // Box: thin grid with two perpendicular linear-gradients
 // Use RGBA for pattern color to ensure visibility on any background
 const patternRgba = hexToRgba(patternColor, opacity);

 return {
 backgroundColor: backgroundColor,
 backgroundImage: `
 linear-gradient(${patternRgba} 1px, transparent 1px),
 linear-gradient(90deg, ${patternRgba} 1px, transparent 1px)
 `,
 backgroundSize: `${scale}px ${scale}px`,
 backgroundPosition: '0 0'
 };
 }



 function generatePolkaPattern(backgroundColor, patternColor, opacity, scale) {
 // Polka: dots using radial-gradient - use RGBA for better visibility
 const scaleFactor = scale / 19; // Base scale is 19px
 const dotSize = 0.95 * scaleFactor;
 const patternSize = 19 * scaleFactor;

 // Use RGBA for pattern color to ensure visibility on any background
 const patternRgba = hexToRgba(patternColor, opacity);
 const bgRgba = hexToRgba(backgroundColor, opacity);

 return {
 backgroundColor: bgRgba,
 backgroundImage: `radial-gradient(${patternRgba} ${dotSize}px, ${bgRgba} ${dotSize}px)`,
 backgroundSize: `${patternSize}px ${patternSize}px`,
 backgroundPosition: '0 0'
 };
 }

 function generateGraphPattern(backgroundColor, patternColor, opacity, scale) {
 // Brand new graph sheet pattern using SVG data URL approach

 const gridSpacing = 24; // Base grid unit
 const heavyLineEvery = 5; // Heavy line frequency
 const adjustedScale = scale / 50;

 const unitSize = gridSpacing * adjustedScale;
 const blockSize = unitSize * heavyLineEvery;

 // Create color values
 const lightGridColor = hexToRgba(patternColor, opacity * 0.3);
 const heavyGridColor = hexToRgba(patternColor, opacity * 0.7);

 // Build SVG pattern as data URL
 const svgPattern = `
 <svg width="${blockSize}" height="${blockSize}" xmlns="http://www.w3.org/2000/svg">
 <defs>
 <pattern id="smallGrid" width="${unitSize}" height="${unitSize}" patternUnits="userSpaceOnUse">
 <path d="M ${unitSize} 0 L 0 0 0 ${unitSize}" fill="none" stroke="${lightGridColor}" stroke-width="6"/>
 </pattern>
 <pattern id="largeGrid" width="${blockSize}" height="${blockSize}" patternUnits="userSpaceOnUse">
 <path d="M ${blockSize} 0 L 0 0 0 ${blockSize}" fill="none" stroke="${heavyGridColor}" stroke-width="8"/>
 </pattern>
 </defs>
 <rect width="100%" height="100%" fill="url(#smallGrid)"/>
 <rect width="100%" height="100%" fill="url(#largeGrid)"/>
 </svg>
 `;

 const encodedSvg = encodeURIComponent(svgPattern);

 return {
 backgroundColor: backgroundColor,
 backgroundImage: `url("data:image/svg+xml,${encodedSvg}")`,
 backgroundSize: `${blockSize}px ${blockSize}px`,
 backgroundRepeat: 'repeat',
 backgroundPosition: '0 0'
 };
 }

 // Helper function to convert hex color to RGBA with opacity
 function hexToRgba(hex, opacity) {
 // Remove # if present
 hex = hex.replace('#', '');

 // Parse hex values
 const r = parseInt(hex.substr(0, 2), 16);
 const g = parseInt(hex.substr(2, 2), 16);
 const b = parseInt(hex.substr(4, 2), 16);

 return `rgba(${r}, ${g}, ${b}, ${opacity})`;
 }



 // Apply CSS background styles to canvas element
 function applyCSSBackgroundToCanvas(cssPattern) {
 const canvasElement = document.getElementById('main-canvas');

 console.log('üé® Applying CSS background to canvas element:', canvasElement ? 'found' : 'not found');

 if (canvasElement && fabricCanvas) {
 console.log('üé® CSS Pattern being applied:', cssPattern);

 // Check if this is a plain background (no pattern)
 const isPlainBackground = !cssPattern.backgroundImage || cssPattern.backgroundImage === '';

 if (isPlainBackground) {
 // For plain backgrounds, clear CSS styles and use Fabric.js background
 canvasElement.style.backgroundColor = '';
 canvasElement.style.backgroundImage = '';
 canvasElement.style.backgroundSize = '';
 canvasElement.style.backgroundPosition = '';
 canvasElement.style.backgroundRepeat = '';

 // Set Fabric.js canvas background to the solid color
 fabricCanvas.setBackgroundColor(cssPattern.backgroundColor);
 fabricCanvas.renderAll();

 console.log('‚úÖ Plain background applied to Fabric.js canvas:', cssPattern.backgroundColor);
 } else {
 // For patterns, apply to canvas element and make Fabric.js transparent
 canvasElement.style.backgroundColor = cssPattern.backgroundColor;
 canvasElement.style.backgroundImage = cssPattern.backgroundImage;
 canvasElement.style.backgroundSize = cssPattern.backgroundSize;
 canvasElement.style.backgroundPosition = cssPattern.backgroundPosition;
 canvasElement.style.backgroundRepeat = 'repeat';

 // Set Fabric.js canvas background to transparent so CSS pattern shows
 fabricCanvas.setBackgroundColor('transparent');
 fabricCanvas.renderAll();

 console.log('‚úÖ CSS pattern applied to canvas element');

 // Update pattern position when canvas transforms change
 updatePatternPosition();
 }

 } else {
 console.error('‚ùå Canvas element or Fabric canvas not found!');
 }
 }

 // Update pattern position based on current canvas transform
 function updatePatternPosition() {
 const canvasElement = document.getElementById('main-canvas');
 if (canvasElement && fabricCanvas && currentCanvasPattern) {
 const zoom = fabricCanvas.getZoom();
 const vpt = fabricCanvas.viewportTransform;
 const translateX = vpt[4];
 const translateY = vpt[5];

 // Calculate scaled background size
 const baseSize = currentCanvasPattern.scale;
 const scaledSize = baseSize * zoom;

 // Update canvas element background
 canvasElement.style.backgroundSize = `${scaledSize}px ${scaledSize}px`;
 canvasElement.style.backgroundPosition = `${translateX}px ${translateY}px`;

 console.log('üé® Updated pattern position:', { zoom, translateX, translateY, scaledSize });
 }
 }

 // Clear CSS background pattern
 function clearCanvasPattern() {
 const canvasElement = document.getElementById('main-canvas');

 console.log('üé® Clearing canvas pattern');

 if (canvasElement) {
 canvasElement.style.backgroundColor = '';
 canvasElement.style.backgroundImage = '';
 canvasElement.style.backgroundSize = '';
 canvasElement.style.backgroundPosition = '';
 canvasElement.style.backgroundRepeat = '';
 console.log('‚úÖ Canvas background cleared');
 }

 // Restore Fabric.js canvas background based on theme
 if (fabricCanvas) {
 const isDark = document.documentElement.classList.contains('dark');
 const defaultBg = isDark ? '#0f172a' : '#ffffff';
 fabricCanvas.setBackgroundColor(defaultBg);
 fabricCanvas.renderAll();
 console.log('üé® Restored Fabric.js canvas background to:', defaultBg);
 }

 currentCanvasPattern = null;
 saveCanvasPatternSettings();
 }

 // Add event listeners for canvas zoom and pan to update pattern position
 function setupPatternTransformListeners() {
 if (fabricCanvas) {
 // Listen for viewport transform changes (zoom, pan)
 fabricCanvas.on('after:render', () => {
 if (currentCanvasPattern) {
 updatePatternPosition();
 }
 });

 // Listen for mouse wheel zoom
 fabricCanvas.on('mouse:wheel', () => {
 if (currentCanvasPattern) {
 setTimeout(updatePatternPosition, 10); // Small delay to ensure transform is applied
 }
 });

 console.log('‚úÖ Pattern transform listeners setup');
 }
 }

 // Save canvas pattern settings to localStorage
 function saveCanvasPatternSettings() {
 if (currentCanvasPattern) {
 localStorage.setItem('canvasPatternSettings', JSON.stringify(currentCanvasPattern));
 } else {
 localStorage.removeItem('canvasPatternSettings');
 }
 }

 // Load canvas pattern settings from localStorage
 function loadCanvasPatternSettings() {
 const saved = localStorage.getItem('canvasPatternSettings');
 if (saved) {
 try {
 currentCanvasPattern = JSON.parse(saved);
 return currentCanvasPattern;
 } catch (e) {
 console.warn('Failed to parse saved canvas pattern settings:', e);
 localStorage.removeItem('canvasPatternSettings');
 }
 }
 return null;
 }

 // Restore canvas pattern on page load
 function restoreCanvasPattern() {
 const pattern = loadCanvasPatternSettings();
 if (pattern) {
 // Update AI settings UI controls
 const aiBackgroundColorInput = document.getElementById('ai-pattern-background-color');
 const aiPatternColorInput = document.getElementById('ai-pattern-color');
 const aiOpacityInput = document.getElementById('ai-pattern-opacity');
 const aiScaleInput = document.getElementById('ai-pattern-scale');

 if (aiBackgroundColorInput) aiBackgroundColorInput.value = pattern.backgroundColor;
 if (aiPatternColorInput) aiPatternColorInput.value = pattern.patternColor;
 if (aiOpacityInput) aiOpacityInput.value = pattern.opacity;
 if (aiScaleInput) aiScaleInput.value = pattern.scale;

 // Set current pattern and apply it
 aiCurrentPattern = pattern.type;
 applyAIPattern(pattern.type);

 // Show pattern controls in AI settings
 const aiPatternControls = document.getElementById('ai-pattern-controls');
 if (aiPatternControls) {
 aiPatternControls.classList.remove('hidden');
 }

 // Update button states and handle control disabling for plain pattern
 document.querySelectorAll('.ai-pattern-btn').forEach(btn => {
 btn.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/30', 'border-indigo-300', 'dark:border-indigo-600');
 if (btn.dataset.pattern === pattern.type) {
 btn.classList.add('bg-indigo-50', 'dark:bg-indigo-900/30', 'border-indigo-300', 'dark:border-indigo-600');
 }
 });

 // Handle Plain pattern control disabling
 const patternColorInput = document.getElementById('ai-pattern-color');
 const opacityInput = document.getElementById('ai-pattern-opacity');
 const patternColorLabel = patternColorInput?.parentElement.querySelector('label');
 const opacityLabel = opacityInput?.parentElement.querySelector('label');

 if (pattern.type === 'plain') {
 // Disable pattern color and opacity for plain background
 if (patternColorInput) {
 patternColorInput.disabled = true;
 patternColorInput.style.opacity = '0.5';
 patternColorInput.style.cursor = 'not-allowed';
 }
 if (opacityInput) {
 opacityInput.disabled = true;
 opacityInput.style.opacity = '0.5';
 opacityInput.style.cursor = 'not-allowed';
 }
 if (patternColorLabel) patternColorLabel.style.opacity = '0.5';
 if (opacityLabel) opacityLabel.style.opacity = '0.5';
 console.log('üé® Restored plain pattern - disabled pattern color and opacity');
 } else {
 // Enable pattern color and opacity for other patterns
 if (patternColorInput) {
 patternColorInput.disabled = false;
 patternColorInput.style.opacity = '1';
 patternColorInput.style.cursor = 'pointer';
 }
 if (opacityInput) {
 opacityInput.disabled = false;
 opacityInput.style.opacity = '1';
 opacityInput.style.cursor = 'pointer';
 }
 if (patternColorLabel) patternColorLabel.style.opacity = '1';
 if (opacityLabel) opacityLabel.style.opacity = '1';
 console.log('üé® Restored pattern - enabled all controls');
 }
 }
 }

 // Reapply pattern on window resize (ensures proper scaling)
 function reapplyCanvasPatternOnResize() {
 if (currentCanvasPattern) {
 console.log('üîÑ Reapplying canvas pattern after resize:', currentCanvasPattern.type);
 console.log('üîÑ Using saved pattern settings:', currentCanvasPattern);

 // Use the saved pattern settings instead of reading from UI controls
 // This prevents the pattern from changing during resize
 let cssPattern;
 switch (currentCanvasPattern.type) {
 case 'plain':
 cssPattern = {
 backgroundColor: currentCanvasPattern.backgroundColor,
 backgroundImage: '',
 backgroundSize: '',
 backgroundPosition: '',
 backgroundRepeat: ''
 };
 break;
 case 'boxes':
 cssPattern = generateBoxesPattern(
 currentCanvasPattern.backgroundColor,
 currentCanvasPattern.patternColor,
 currentCanvasPattern.opacity,
 currentCanvasPattern.scale
 );
 break;
 case 'polka':
 cssPattern = generatePolkaPattern(
 currentCanvasPattern.backgroundColor,
 currentCanvasPattern.patternColor,
 currentCanvasPattern.opacity,
 currentCanvasPattern.scale
 );
 break;
 case 'graph':
 cssPattern = generateGraphPattern(
 currentCanvasPattern.backgroundColor,
 currentCanvasPattern.patternColor,
 currentCanvasPattern.opacity,
 currentCanvasPattern.scale
 );
 break;
 case 'lines':
 cssPattern = generateLinesPattern(
 currentCanvasPattern.backgroundColor,
 currentCanvasPattern.patternColor,
 currentCanvasPattern.opacity,
 currentCanvasPattern.scale
 );
 break;
 default:
 console.error('‚ùå Unknown pattern type during resize:', currentCanvasPattern.type);
 return;
 }

 if (cssPattern) {
 // Apply the pattern directly without updating UI or broadcasting
 applyCSSBackgroundToCanvas(cssPattern);
 console.log('‚úÖ Pattern reapplied after resize with preserved settings');
 }
 } else {
 console.log('üîÑ No canvas pattern to reapply after resize');
 }
 }

 // Update pattern when canvas viewport changes
 function onCanvasViewportChange() {
 if (currentCanvasPattern) {
 updatePatternPosition();
 }
 }

 fontSizer.addEventListener('input', (e) => {
 chatHistory.style.fontSize = e.target.value + 'px';
 });

 exportPdfButton.addEventListener('click', () => {
 const { jsPDF } = window.jspdf;
 const imgData = fabricCanvas.toDataURL({ format: 'png', quality: 1.0 });
 const pdf = new jsPDF({
 orientation: fabricCanvas.width > fabricCanvas.height ? 'l' : 'p',
 unit: 'px',
 format: [fabricCanvas.width, fabricCanvas.height]
 });
 pdf.addImage(imgData, 'PNG', 0, 0, fabricCanvas.width, fabricCanvas.height);
 pdf.save("notebook_export.pdf");
 // Removed noisy system message - PDF download is self-evident
 });



 // Enhanced synchronized erase functions using new operation system
 function eraseSelectedObjects(objects) {
 if (!objects || objects.length === 0) return;

 console.log('üóëÔ∏è Erasing', objects.length, 'selected objects');

 // Ensure all objects have IDs for synchronization
 objects.forEach((obj, index) => {
 if (!obj.id) {
 obj.id = generateObjectId();
 console.log('Generated ID for object without ID:', obj.id);
 }
 });

 // Create remove command for undo/redo support
 if (commandHistory && undoRedoEnabled) {
 try {
 if (objects.length === 1) {
 // Single object removal
 const command = new RemoveObjectCommand(objects[0], `Remove ${objects[0].type}`);
 commandHistory.executeCommand(command);
 } else {
 // Multiple objects removal
 const command = new RemoveMultipleObjectsCommand(objects, `Remove ${objects.length} Objects`);
 commandHistory.executeCommand(command);
 }
 } catch (error) {
 console.warn('‚ö†Ô∏è Error creating remove command:', error);
 // Fallback to direct removal
 objects.forEach((obj) => {
 fabricCanvas.remove(obj);
 });
 fabricCanvas.discardActiveObject().renderAll();
 }
 } else {
 // Fallback if command history not available
 objects.forEach((obj) => {
 fabricCanvas.remove(obj);
 });
 fabricCanvas.discardActiveObject().renderAll();
 }

 // Send removal operations for each object (for collaboration)
 if (currentRoomId) {
 objects.forEach((obj, index) => {
 console.log(`üöÄ Sending object removal for object ${index + 1}/${objects.length}:`, obj.id);
 sendCanvasOperation('object_removed', {
 object_id: obj.id,
 object_type: obj.type,
 removal_method: 'selected_erase'
 });
 });
 }

 console.log('‚úÖ Selected objects erased and synchronized');
 }

 function eraseWholeCanvas() {
 console.log('üóëÔ∏è Erasing whole canvas');

 // Create clear canvas command for undo/redo support
 if (commandHistory) {
 const command = new ClearCanvasCommand('Clear Canvas');
 commandHistory.executeCommand(command);
 } else {
 // Fallback if command history not available
 fabricCanvas.clear();
 fabricCanvas.backgroundColor = document.documentElement.classList.contains('dark') ? '#0f172a' : '#ffffff';
 fabricCanvas.renderAll();
 }

    pendingImageForChat = null;
    pendingImageMetadata = null;

 // Send canvas cleared operation (for collaboration)
 if (currentRoomId) {
 sendCanvasOperation('canvas_cleared', {
 background: fabricCanvas.backgroundColor,
 cleared_by: currentUserId,
 timestamp: Date.now()
 });
 }

 console.log('‚úÖ Whole canvas erased and synchronized');
 }

 // Enhanced keyboard shortcuts for erase functionality
 document.addEventListener('keydown', function(e) {
 // Debug shortcut: Ctrl+Shift+D to debug canvas images
 if (e.ctrlKey && e.shiftKey && e.key === 'D' && document.activeElement !== chatInput) {
 e.preventDefault();
 console.log('üîç Debug shortcut triggered');
 const debugInfo = debugCanvasImages();
 addChatMessage('System', `Debug: ${debugInfo.totalObjects} objects, ${debugInfo.totalImages} images on canvas`);
 return;
 }

 // Test image shortcut: Ctrl+Shift+I to add test image
 if (e.ctrlKey && e.shiftKey && e.key === 'I' && document.activeElement !== chatInput) {
 e.preventDefault();
 console.log('üß™ Test image shortcut triggered');
 addTestImage();
 return;
 }

 // Comprehensive diagnostics: Ctrl+Shift+T
 if (e.ctrlKey && e.shiftKey && e.key === 'T' && document.activeElement !== chatInput) {
 e.preventDefault();
 console.log('üî¨ Comprehensive diagnostics triggered');
 runImageDiagnostics();
 return;
 }

 // Direct paste test: Ctrl+Shift+P
 if (e.ctrlKey && e.shiftKey && e.key === 'P' && document.activeElement !== chatInput) {
 e.preventDefault();
 console.log('üß™ Direct paste test triggered');
 testImagePasteDirectly();
 return;
 }

 // Copy shortcut: Ctrl+C (or Cmd+C on Mac)
 if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
 // Don't interfere with text field operations
 if (isUserTypingInTextField()) {
 console.log('üìù User typing in text field, allowing normal text copy');
 return; // Let normal text copy happen
 }

 const activeObjects = fabricCanvas.getActiveObjects();
 if (activeObjects.length > 0) {
 e.preventDefault();
 console.log('üìã Copy shortcut triggered');
 copySelectedObjects();
 }
 return;
 }

  // Paste shortcut: let the 'paste' event decide whether to paste images or objects
  if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
    // Don't interfere with text field operations
    if (isUserTypingInTextField()) {
      console.log('üìù User typing in text field, allowing normal text paste');
      return; // Let normal text paste happen
    }

    // Do not preventDefault here; the 'paste' event below will handle images first,
    // otherwise it will fall back to pasting copied Fabric objects.
    console.log('üìã Ctrl+V detected, letting paste event handle it');
    return;
  }

 if ((e.key === 'Delete' || e.key === 'Backspace')) {
 // Don't interfere with text field operations
 if (isUserTypingInTextField()) {
 console.log('üìù User typing in text field, allowing normal delete/backspace');
 return;
 }

 if (fabricCanvas.getActiveObjects().length > 0) {
 console.log('üî• Delete/Backspace key triggered');
 const activeObjects = fabricCanvas.getActiveObjects();

 // Check if we have a text object in editing mode
 const textInEditingMode = activeObjects.find(obj =>
 obj.type === 'i-text' && obj.isEditing
 );

 if (textInEditingMode) {
 // If text is in editing mode (cursor blinking), let fabric handle the backspace naturally
 console.log('üìù Text is in editing mode, allowing normal text editing');
 return; // Don't prevent default, let fabric handle character deletion
 }

 // Only prevent default and delete objects if no text is being edited
 e.preventDefault(); // Prevent default browser behavior

 if (activeObjects.length > 0) {
 console.log('Active objects for removal:', activeObjects.map(obj => ({
 id: obj.id,
 type: obj.type,
 hasId: !!obj.id,
 isEditing: obj.type === 'i-text' ? obj.isEditing : 'N/A'
 })));

 // Use new synchronized erase system
 eraseSelectedObjects(activeObjects);
 }
 }
 }
 });

 // --- Image Paste Functionality ---
 // Handle Ctrl/Cmd+V anywhere on the page (canvas first)
 document.addEventListener('paste', function(e) {
 // Don't interfere with text field operations
 if (isUserTypingInTextField()) {
 console.log('üìã Paste event ignored - user typing in text field');
 return;
 }

 console.log('üìã PASTE EVENT TRIGGERED! Checking for images...');
 console.log('üìã Active element:', document.activeElement?.tagName, document.activeElement?.id);

  const items = e.clipboardData?.items;
  const files = e.clipboardData?.files;
  if (!items && !files) {
    console.log('üìã No clipboard items or files found');
    return;
  }

  let foundImage = false;

  // Check clipboard items first
  if (items) {
    console.log('üìã Checking', items.length, 'clipboard items');
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      console.log('üìã Item', i, ':', item.type, item.kind);

      // Check if the item is an image
      if (item.type.indexOf('image') !== -1) {
        e.preventDefault();

        const file = item.getAsFile();
        if (file) {
          console.log('üìã Image pasted from clipboard:', file.type, file.size, 'bytes');
          handleImagePaste(file);
        }
        foundImage = true;
        break;
      }
    }
  }

  // Fallback: some platforms put screenshots in clipboardData.files only
  if (!foundImage && files && files.length > 0) {
    console.log('üìã Checking', files.length, 'files');
    for (let i = 0; i < files.length; i++) {
      const f = files[i];
      console.log('üìã File', i, ':', f.type, f.size, 'bytes');
      if (f.type && f.type.indexOf('image') !== -1) {
        e.preventDefault();
        console.log('üìã Processing image file from clipboard');
        handleImagePaste(f);
        foundImage = true;
        break;
      }
    }
  }

  // If no image found but we have copied objects, paste those
  if (!foundImage && copiedObjects && copiedObjects.length > 0) {
    e.preventDefault();
    console.log('üìã No image found, pasting copied objects instead');
    pasteObjects();
  } else if (!foundImage) {
    console.log('üìã No image or copied objects found to paste');
  }
 });

 mainCanvasEl.parentElement.addEventListener('contextmenu', (e) => e.preventDefault());

 // --- New fabric.Arrow Class ---
 fabric.Arrow = fabric.util.createClass(fabric.Path, {
 type: 'arrow',

 initialize: function(options) {
 options = options || {};

 // Set default values
 this.x1 = options.x1 || 0;
 this.y1 = options.y1 || 0;
 this.x2 = options.x2 || 100;
 this.y2 = options.y2 || 100;
 this.cp1 = options.cp1 || { x: this.x1 + (this.x2 - this.x1) * 0.33, y: this.y1 + (this.y2 - this.y1) * 0.33 };
 this.cp2 = options.cp2 || { x: this.x1 + (this.x2 - this.x1) * 0.66, y: this.y1 + (this.y2 - this.y1) * 0.66 };
 this.headSize = options.headSize || Math.max((options.strokeWidth || 2) * 2, 8);

 // Generate initial path
 const pathString = this._generatePath();

 // Set default style options
 const defaultOptions = {
 stroke: options.stroke || '#000000',
 strokeWidth: options.strokeWidth || 2,
 fill: '',
 strokeLineCap: 'round',
 strokeLineJoin: 'round',
 selectable: true,
 evented: true,
 lineType: 'arrow'
 };

 // Merge with provided options
 const finalOptions = Object.assign({}, defaultOptions, options, { path: pathString });

 this.callSuper('initialize', pathString, finalOptions);
 },

 _generatePath: function() {
 // Create cubic B√©zier curve for the arrow body
 const bodyPath = `M ${this.x1} ${this.y1} C ${this.cp1.x} ${this.cp1.y} ${this.cp2.x} ${this.cp2.y} ${this.x2} ${this.y2}`;

 // Calculate arrow head direction from cp2 to endpoint
 const angle = Math.atan2(this.y2 - this.cp2.y, this.x2 - this.cp2.x);

 // Calculate arrowhead points
 const arrowHead1X = this.x2 - this.headSize * Math.cos(angle - Math.PI / 6);
 const arrowHead1Y = this.y2 - this.headSize * Math.sin(angle - Math.PI / 6);
 const arrowHead2X = this.x2 - this.headSize * Math.cos(angle + Math.PI / 6);
 const arrowHead2Y = this.y2 - this.headSize * Math.sin(angle + Math.PI / 6);

 // Combine body and head
 const headPath = `M ${this.x2} ${this.y2} L ${arrowHead1X} ${arrowHead1Y} M ${this.x2} ${this.y2} L ${arrowHead2X} ${arrowHead2Y}`;

 return bodyPath + ' ' + headPath;
 },

 updatePath: function() {
 const pathString = this._generatePath();
 this.path = fabric.util.parsePath(pathString);
 this._setPath(pathString);
 this.dirty = true;
 },

 setEndpoints: function(x1, y1, x2, y2, constrainStraight) {
 this.x1 = x1;
 this.y1 = y1;
 this.x2 = x2;
 this.y2 = y2;

 if (constrainStraight) {
 // Keep control points on the straight line for Shift-constrained drawing
 this.cp1 = { x: x1 + (x2 - x1) * 0.33, y: y1 + (y2 - y1) * 0.33 };
 this.cp2 = { x: x1 + (x2 - x1) * 0.66, y: y1 + (y2 - y1) * 0.66 };
 } else if (!this.cp1 || !this.cp2) {
 // Initialize control points if they don't exist
 this.cp1 = { x: x1 + (x2 - x1) * 0.33, y: y1 + (y2 - y1) * 0.33 };
 this.cp2 = { x: x1 + (x2 - x1) * 0.66, y: y1 + (y2 - y1) * 0.66 };
 }
 // If control points exist and not constraining, keep them as-is for smooth editing

 this.updatePath();
 },

 setControlPoints: function(cp1, cp2) {
 this.cp1 = cp1;
 this.cp2 = cp2;
 this.updatePath();
 },

 toObject: function(propertiesToInclude) {
 return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
 lineType: 'arrow',
 x1: this.x1,
 y1: this.y1,
 x2: this.x2,
 y2: this.y2,
 cp1: this.cp1,
 cp2: this.cp2,
 headSize: this.headSize
 });
 }
 });

 // Static factory method
 fabric.Arrow.fromObject = function(object, callback) {
 const arrow = new fabric.Arrow(object);
 callback && callback(arrow);
 return arrow;
 };

 // Register in fabric's class registry
 fabric.Arrow.async = true;

 // Migration function to convert legacy arrows
 function migrateLegacyArrows() {
 console.log('üîÑ Starting legacy arrow migration...');
 const objects = fabricCanvas.getObjects('path');
 let migrated = 0;

 objects.forEach(obj => {
 // Check if it's a legacy arrow without control points
 if (obj.lineType === 'arrow' && !obj.cp1 && !obj.cp2 && obj.path) {
 try {
 // Extract start and end points from path
 const pathData = obj.path;
 if (pathData && pathData.length >= 2) {
 const x1 = pathData[0][1];
 const y1 = pathData[0][2];
 const x2 = pathData[1][1];
 const y2 = pathData[1][2];

 // Create new fabric.Arrow with same properties
 const newArrow = new fabric.Arrow({
 x1: x1,
 y1: y1,
 x2: x2,
 y2: y2,
 stroke: obj.stroke,
 strokeWidth: obj.strokeWidth,
 id: obj.id,
 left: obj.left,
 top: obj.top
 });

 // Replace old object with new arrow
 fabricCanvas.remove(obj);
 fabricCanvas.add(newArrow);
 migrated++;

 console.log(`‚úÖ Migrated legacy arrow ${obj.id}`);
 }
 } catch (error) {
 console.error(`‚ùå Failed to migrate arrow ${obj.id}:`, error);
 }
 }
 });

 if (migrated > 0) {
 fabricCanvas.renderAll();
 console.log(`üéØ Migration complete: ${migrated} legacy arrows converted`);
 } else {
 console.log('‚ú® No legacy arrows found to migrate');
 }
 }

 // Test function for new arrow system
 window.testNewArrows = function() {
 console.log('üß™ Testing new arrow system...');

 // Test 1: Create a basic arrow
 const testArrow = new fabric.Arrow({
 x1: 100, y1: 100,
 x2: 200, y2: 150,
 stroke: '#ff0000',
 strokeWidth: 3,
 id: 'test-arrow-1'
 });

 fabricCanvas.add(testArrow);
 console.log('‚úÖ Test 1: Basic arrow creation');

 // Test 2: Test serialization
 const serialized = testArrow.toObject();
 console.log('‚úÖ Test 2: Arrow serialization', serialized);

 // Test 3: Test deserialization
 const recreated = new fabric.Arrow(serialized);
 recreated.set({ left: 300, id: 'test-arrow-2' });
 fabricCanvas.add(recreated);
 console.log('‚úÖ Test 3: Arrow deserialization');

 // Test 4: Test control point modification
 testArrow.setControlPoints(
 { x: 120, y: 80 },
 { x: 180, y: 170 }
 );
 console.log('‚úÖ Test 4: Control point modification');

 fabricCanvas.renderAll();
 console.log('üéØ Arrow system tests complete!');
 };

 // Test function for text collaboration
 window.testTextCollaboration = function() {
 console.log('üß™ Testing text collaboration...');

 // Test 1: Create a text object
 const testText = new fabric.IText('Hello Collaboration!', {
 left: 150, top: 150,
 fill: '#ff0000',
 fontFamily: 'Inter',
 fontSize: 24,
 id: 'test-text-1'
 });

 fabricCanvas.add(testText);
 console.log('‚úÖ Test 1: Text object creation');

 // Test 2: Test serialization
 const serialized = testText.toObject();
 console.log('‚úÖ Test 2: Text serialization', serialized);

 // Test 3: Simulate text editing
 testText.enterEditing();
 testText.text = 'Modified text!';
 testText.exitEditing();
 console.log('‚úÖ Test 3: Text editing simulation');

 fabricCanvas.setActiveObject(testText);
 fabricCanvas.renderAll();
 console.log('üéØ Text collaboration tests complete!');
 };

 // Test function for text backspace behavior
 window.testTextBackspace = function() {
 console.log('üß™ Testing text backspace behavior...');

 // Create a test text object
 const testText = new fabric.IText('Test backspace behavior', {
 left: 200, top: 200,
 fill: '#0066cc',
 fontFamily: 'Inter',
 fontSize: 18,
 id: 'test-backspace-text'
 });

 fabricCanvas.add(testText);
 fabricCanvas.setActiveObject(testText);
 fabricCanvas.renderAll();

 console.log('‚úÖ Test text created and selected');
 console.log('üìù Instructions:');
 console.log('1. Single-click the text (should be selected but not editing)');
 console.log('2. Press backspace - should delete the entire text object');
 console.log('3. Create another text and double-click it (should enter editing mode)');
 console.log('4. Press backspace - should only delete characters, not the whole object');
 console.log('üéØ Text backspace behavior test ready!');
 };

 // Test function for UI improvements
 window.testUIImprovements = function() {
 console.log('üé® Testing UI improvements...');

 // Test tool indicator updates
 const tools = ['pen-tool', 'line-tool', 'arrow-tool', 'circle-tool', 'text-tool'];
 let index = 0;

 const cycleTools = () => {
 const button = document.getElementById(tools[index]);
 if (button) {
 button.click();
 console.log(`‚úÖ Switched to ${tools[index]}`);
 }
 index = (index + 1) % tools.length;
 };

 // Cycle through tools every 2 seconds
 const interval = setInterval(cycleTools, 2000);

 // Stop after 10 seconds
 setTimeout(() => {
 clearInterval(interval);
 console.log('üéØ UI improvement test complete!');
 }, 10000);

 console.log('üîÑ Cycling through tools to test indicator...');
 };

 // Test function for tool state management
 window.testToolStateManagement = function() {
 console.log('üß™ Testing tool state management...');

 // Function to check current tool states
 const checkStates = (toolName) => {
 console.log(`üìä ${toolName} - States:`, {
 currentTool: currentTool,
 isAddingText: isAddingText,
 isDrawingHighlight: isDrawingHighlight,
 isDrawingShape: isDrawingShape,
 canvasDrawingMode: fabricCanvas.isDrawingMode,
 canvasSelection: fabricCanvas.selection
 });
 };

 // Test sequence
 console.log('1. Testing text tool...');
 document.getElementById('text-tool').click();
 checkStates('Text Tool');

 setTimeout(() => {
 console.log('2. Switching to pen tool...');
 document.getElementById('pen-tool').click();
 checkStates('Pen Tool');
 }, 1000);

 setTimeout(() => {
 console.log('3. Switching to arrow tool...');
 document.getElementById('arrow-tool').click();
 checkStates('Arrow Tool');
 }, 2000);

 setTimeout(() => {
 console.log('4. Switching back to select tool...');
 document.getElementById('select-tool').click();
 checkStates('Select Tool');
 console.log('üéØ Tool state management test complete!');
 }, 3000);
 };

 // Simple test function to verify tool indicator fix
 window.testToolIndicatorFix = function() {
 console.log('üß™ Testing tool indicator fix...');

 // Test text tool selection
 console.log('1. Selecting text tool...');
 document.getElementById('text-tool').click();

 setTimeout(() => {
 console.log('2. Selecting pen tool...');
 document.getElementById('pen-tool').click();
 }, 1500);

 setTimeout(() => {
 console.log('3. Selecting arrow tool...');
 document.getElementById('arrow-tool').click();
 }, 3000);

 setTimeout(() => {
 console.log('4. Back to select tool...');
 document.getElementById('select-tool').click();
 console.log('üéØ Tool indicator fix test complete! Check the UI indicator.');
 }, 4500);
 };



 // --- Enhanced Line and Arrow Editing Functions ---
 function createControlPoints(lineObject) {
 clearControlPoints();

 if (!lineObject) return;

 // Handle new fabric.Arrow objects
 if (lineObject.type === 'arrow') {
 // Create control points for B√©zier curve
 const controlPoint1 = new fabric.Circle({
 left: lineObject.cp1.x,
 top: lineObject.cp1.y,
 radius: 6,
 fill: '#3b82f6',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isControlPoint: true,
 controlIndex: 0,
 parentLine: lineObject
 });

 const controlPoint2 = new fabric.Circle({
 left: lineObject.cp2.x,
 top: lineObject.cp2.y,
 radius: 6,
 fill: '#3b82f6',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isControlPoint: true,
 controlIndex: 1,
 parentLine: lineObject
 });

 // Create endpoint handles
 const endPoint1 = new fabric.Circle({
 left: lineObject.x1,
 top: lineObject.y1,
 radius: 5,
 fill: '#ef4444',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isEndPoint: true,
 endIndex: 0,
 parentLine: lineObject
 });

 const endPoint2 = new fabric.Circle({
 left: lineObject.x2,
 top: lineObject.y2,
 radius: 5,
 fill: '#ef4444',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isEndPoint: true,
 endIndex: 1,
 parentLine: lineObject
 });

 fabricCanvas.add(controlPoint1, controlPoint2, endPoint1, endPoint2);
 controlPointCircles = [controlPoint1, controlPoint2, endPoint1, endPoint2];

 return;
 }

 // Legacy handling for old line objects
 if (!lineObject.isAdvancedLine) return;

 let x1, y1, x2, y2;

 if (lineObject.type === 'line') {
 x1 = lineObject.x1;
 y1 = lineObject.y1;
 x2 = lineObject.x2;
 y2 = lineObject.y2;
 } else if (lineObject.type === 'path') {
 // For legacy arrows, extract start and end points from path
 const pathData = lineObject.path;
 if (pathData && pathData.length >= 2) {
 x1 = pathData[0][1];
 y1 = pathData[0][2];
 x2 = pathData[1][1];
 y2 = pathData[1][2];
 }
 }

 if (x1 !== undefined && y1 !== undefined && x2 !== undefined && y2 !== undefined) {
 // Create control points along the line
 const quarterX1 = x1 + (x2 - x1) * 0.33;
 const quarterY1 = y1 + (y2 - y1) * 0.33;
 const quarterX2 = x1 + (x2 - x1) * 0.66;
 const quarterY2 = y1 + (y2 - y1) * 0.66;

 // Create control point circles
 const controlPoint1 = new fabric.Circle({
 left: quarterX1,
 top: quarterY1,
 radius: 6,
 fill: '#3b82f6',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isControlPoint: true,
 controlIndex: 0,
 parentLine: lineObject
 });

 const controlPoint2 = new fabric.Circle({
 left: quarterX2,
 top: quarterY2,
 radius: 6,
 fill: '#3b82f6',
 stroke: '#ffffff',
 strokeWidth: 2,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 isControlPoint: true,
 controlIndex: 1,
 parentLine: lineObject
 });

 fabricCanvas.add(controlPoint1, controlPoint2);
 controlPointCircles = [controlPoint1, controlPoint2];

 // Store control points in the line object
 lineObject.controlPoints = [
 {x: quarterX1, y: quarterY1},
 {x: quarterX2, y: quarterY2}
 ];
 }
 }

 function clearControlPoints() {
 // Remove control points from the tracked array
 controlPointCircles.forEach(point => {
 fabricCanvas.remove(point);
 });
 controlPointCircles = [];

 // Also remove any lingering control points that might not be tracked
 const objectsToRemove = fabricCanvas.getObjects().filter(obj =>
 obj.isControlPoint || obj.isEndPoint
 );
 objectsToRemove.forEach(obj => {
 fabricCanvas.remove(obj);
 });

 // Force canvas re-render to ensure clean state
 fabricCanvas.renderAll();
 }

 function updateLineWithControlPoints(lineObject, controlPoints) {
 if (!lineObject || !controlPoints || controlPoints.length < 2) return;

 let x1, y1, x2, y2;

 if (lineObject.type === 'line') {
 x1 = lineObject.x1;
 y1 = lineObject.y1;
 x2 = lineObject.x2;
 y2 = lineObject.y2;
 } else if (lineObject.type === 'path') {
 const pathData = lineObject.path;
 if (pathData && pathData.length >= 2) {
 x1 = pathData[0][1];
 y1 = pathData[0][2];
 x2 = pathData[1][1];
 y2 = pathData[1][2];
 }
 }

 if (x1 !== undefined && y1 !== undefined && x2 !== undefined && y2 !== undefined) {
 // Create curved path using control points
 const cp1 = controlPoints[0];
 const cp2 = controlPoints[1];

 let pathString;
 if (lineObject.lineType === 'arrow') {
 // Create curved arrow
 const arrowHeadSize = Math.max(lineObject.strokeWidth * 2, 8);
 const angle = Math.atan2(y2 - cp2.y, x2 - cp2.x);
 const arrowHead1X = x2 - arrowHeadSize * Math.cos(angle - Math.PI / 6);
 const arrowHead1Y = y2 - arrowHeadSize * Math.sin(angle - Math.PI / 6);
 const arrowHead2X = x2 - arrowHeadSize * Math.cos(angle + Math.PI / 6);
 const arrowHead2Y = y2 - arrowHeadSize * Math.sin(angle + Math.PI / 6);

 pathString = `M ${x1} ${y1} C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${x2} ${y2} M ${x2} ${y2} L ${arrowHead1X} ${arrowHead1Y} M ${x2} ${y2} L ${arrowHead2X} ${arrowHead2Y}`;
 } else {
 // Create curved line
 pathString = `M ${x1} ${y1} C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${x2} ${y2}`;
 }

 // Convert line to path if it isn't already
 if (lineObject.type === 'line') {
 const newPath = new fabric.Path(pathString, {
 stroke: lineObject.stroke,
 strokeWidth: lineObject.strokeWidth,
 fill: '',
 strokeLineCap: 'round',
 strokeLineJoin: 'round',
 selectable: true,
 evented: true,
 id: lineObject.id,
 isAdvancedLine: true,
 lineType: lineObject.lineType,
 controlPoints: controlPoints
 });

 fabricCanvas.remove(lineObject);
 fabricCanvas.add(newPath);
 selectedLineForEditing = newPath;
 } else {
 // Update existing path
 lineObject.path = fabric.util.parsePath(pathString);
 lineObject._setPath(pathString);
 lineObject.controlPoints = controlPoints;
 }

 fabricCanvas.renderAll();
 }
 }



 // --- Fabric Mouse Events (Shapes and Highlights) ---
 fabricCanvas.on('mouse:down', (o) => {
 // In Pan Mode, block ALL tool interactions
 if (isPanModeActive) {
     console.log('üéØ Pan Mode active - blocking all tool interactions');
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 // TARGETED GESTURE BLOCKING - Only block during actual gestures when NOT in Pan Mode
 if (isGesturing && o.e.touches && o.e.touches.length >= 2) {
     console.log('üö´ Blocked mouse:down during two-finger gesture');
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 // Additional check for multi-touch on the original event
 if (o.e.touches && o.e.touches.length >= 2) {
     isGesturing = true;
     console.log('üö´ Multi-touch detected in mouse:down - blocking selection');
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 // Prevent default behavior when drawing tools are active
 if (isDrawingShape || isDrawingHighlight || isAddingText) {
 o.e.preventDefault();
 o.e.stopPropagation();
 }

 const pointer = fabricCanvas.getPointer(o.e);
 startPoint = pointer;

 // Handle text creation
 if (isAddingText) {
 const txt = new fabric.IText('Double-click to edit', {
 left: pointer.x,
 top: pointer.y,
 fill: colorPicker.value,
 fontFamily: 'Inter',
 fontSize: 20,
 selectable: true,
 evented: true,
 id: generateObjectId()
 });

 // Don't skip the object:added event - let it handle undo command creation
 fabricCanvas.add(txt).setActiveObject(txt);
 fabricCanvas.renderAll();

 // send once the user finishes the first edit
 txt.on('editing:exited', () => {
 // The undo command is already created by the object:added event
 // Just handle collaboration sync here

 // Send to collaboration if in room
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üìù Sending completed text to other users:', txt.id);
 sendCanvasOperation('object_added', {
 object: txt.toObject(),
 object_id: txt.id
 });
 }
 });

 // Reset text tool state and switch to select mode
 resetAllToolStates();
 currentTool = 'select';
 fabricCanvas.selection = true;
 setActiveToolButton(selectToolButton);
 return;
 }

 // Handle shape drawing
 if (isDrawingShape) {
 const strokeColor = colorPicker.value;
 const strokeWidth = parseInt(brushSizeSlider.value, 10);

 // Skip the automatic object:added event for this shape
 skipNextObjectAdded = true;

 if (currentTool === 'line') {
 currentDrawingShape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
 stroke: strokeColor,
 strokeWidth: strokeWidth,
 selectable: true,
 evented: true,
 id: generateObjectId(),
 isAdvancedLine: true,
 lineType: 'line'
 });
 } else if (currentTool === 'arrow') {
 // Create new fabric.Arrow instance
 currentDrawingShape = new fabric.Arrow({
 x1: startPoint.x,
 y1: startPoint.y,
 x2: startPoint.x,
 y2: startPoint.y,
 stroke: strokeColor,
 strokeWidth: strokeWidth,
 id: generateObjectId(),
 isAdvancedLine: true
 });
 } else if (currentTool === 'circle') {
 currentDrawingShape = new fabric.Circle({
 left: startPoint.x,
 top: startPoint.y,
 radius: 0,
 fill: 'transparent',
 stroke: strokeColor,
 strokeWidth: strokeWidth,
 selectable: true,
 evented: true,
 originX: 'center',
 originY: 'center',
 id: generateObjectId()
 });
 } else if (currentTool === 'rectangle') {
 currentDrawingShape = new fabric.Rect({
 left: startPoint.x,
 top: startPoint.y,
 width: 0,
 height: 0,
 fill: 'transparent',
 stroke: strokeColor,
 strokeWidth: strokeWidth,
 selectable: true,
 evented: true,
 id: generateObjectId()
 });
 }

 if (currentDrawingShape) {
 // Don't add to canvas yet - wait until mouse:up
 fabricCanvas.add(currentDrawingShape);
 fabricCanvas.renderAll();
 }
 return;
 }

 // Handle highlight drawing
 if (!isDrawingHighlight) return;
 let color = fabric.Color.fromHex(colorPicker.value).setAlpha(0.3).toRgba();
 let borderColor = fabric.Color.fromHex(colorPicker.value).setAlpha(0.7).toRgba();

 // Suppress the auto object:added broadcast for this shape;
 // we will send the finalised version on mouse:up
 skipNextObjectAdded = true;

 if (currentTool === 'highlighter-rect') {
 currentHighlightShape = new fabric.Rect({
 left: startPoint.x, top: startPoint.y, width: 0, height: 0,
 fill: color, stroke: borderColor, strokeWidth: 2,
 selectable: true, evented: true, isAIHighlight: true,
 id: generateObjectId()
 });

 // Ensure isAIHighlight is included in serialization
 currentHighlightShape.toObject = (function(toObjectSuper) {
 return function(propertiesToInclude) {
 return fabric.util.object.extend(toObjectSuper.call(this, propertiesToInclude), {
 isAIHighlight: this.isAIHighlight
 });
 };
 })(currentHighlightShape.toObject);

 } else if (currentTool === 'highlighter-circle') {
 currentHighlightShape = new fabric.Ellipse({
 left: startPoint.x, top: startPoint.y, rx: 0, ry: 0,
 fill: color, stroke: borderColor, strokeWidth: 2,
 selectable: true, evented: true, isAIHighlight: true,
 originX: 'left', originY: 'top',
 id: generateObjectId()
 });

 // Ensure isAIHighlight is included in serialization
 currentHighlightShape.toObject = (function(toObjectSuper) {
 return function(propertiesToInclude) {
 return fabric.util.object.extend(toObjectSuper.call(this, propertiesToInclude), {
 isAIHighlight: this.isAIHighlight
 });
 };
 })(currentHighlightShape.toObject);
 }
 if (currentHighlightShape) fabricCanvas.add(currentHighlightShape);
 });

 fabricCanvas.on('mouse:move', (o) => {
 // In Pan Mode, block ALL tool interactions
 if (isPanModeActive) {
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 // TARGETED GESTURE BLOCKING - Only block during actual two-finger gestures when NOT in Pan Mode
 if (isGesturing && o.e.touches && o.e.touches.length >= 2) {
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 // Additional multi-touch check
 if (o.e.touches && o.e.touches.length >= 2) {
     isGesturing = true;
     o.e.preventDefault();
     o.e.stopPropagation();
     o.e.stopImmediatePropagation();
     return false;
 }

 if (magnifierActive) { // Magnifier logic moved here to be inside canvas boundary
 const canvasRect = mainCanvasEl.getBoundingClientRect();
 // Use o.e (original event) for pageX/pageY relative to document
 // Use fabricCanvas.getPointer(o.e) for canvas-relative coordinates
 const pointer = fabricCanvas.getPointer(o.e); // x,y on unzoomed canvas

 magnifierPreview.style.left = (o.e.pageX - magnifierPreview.offsetWidth / 2) + 'px';
 magnifierPreview.style.top = (o.e.pageY - magnifierPreview.offsetHeight / 2) + 'px';

 magnifierPreview.style.backgroundImage = `url(${fabricCanvas.toDataURL()})`; // Use fabricCanvas.toDataURL for current state
 magnifierPreview.style.backgroundRepeat = 'no-repeat';
 // Adjust backgroundPosition based on canvas-relative coords and current canvas zoom
 const bgX = (pointer.x * currentZoom * magnifierZoomLevel) - (magnifierPreview.offsetWidth / 2);
 const bgY = (pointer.y * currentZoom * magnifierZoomLevel) - (magnifierPreview.offsetHeight / 2);
 magnifierPreview.style.backgroundPosition = `-${bgX}px -${bgY}px`;
 magnifierPreview.style.backgroundSize = `${fabricCanvas.width * magnifierZoomLevel}px ${fabricCanvas.height * magnifierZoomLevel}px`;
 magnifierPreview.style.display = 'block';
 }

 // Handle shape drawing
 if (isDrawingShape && currentDrawingShape && startPoint) {
 const pointer = fabricCanvas.getPointer(o.e);

 if (currentTool === 'line') {
 currentDrawingShape.set({
 x2: pointer.x,
 y2: pointer.y
 });
 } else if (currentTool === 'arrow') {
 // Update arrow endpoints with Shift constraint support
 let endX = pointer.x;
 let endY = pointer.y;

 // Constrain to straight line if Shift is held
 if (o.e.shiftKey) {
 const dx = endX - startPoint.x;
 const dy = endY - startPoint.y;
 const angle = Math.atan2(dy, dx);
 const length = Math.sqrt(dx * dx + dy * dy);

 // Snap to nearest 45-degree angle
 const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
 endX = startPoint.x + length * Math.cos(snapAngle);
 endY = startPoint.y + length * Math.sin(snapAngle);
 }

 currentDrawingShape.setEndpoints(startPoint.x, startPoint.y, endX, endY, o.e.shiftKey);
 } else if (currentTool === 'circle') {
 const radius = Math.sqrt(Math.pow(pointer.x - startPoint.x, 2) + Math.pow(pointer.y - startPoint.y, 2)) / 2;
 currentDrawingShape.set({
 radius: radius
 });
 } else if (currentTool === 'rectangle') {
 currentDrawingShape.set({
 width: Math.abs(pointer.x - startPoint.x),
 height: Math.abs(pointer.y - startPoint.y),
 left: Math.min(pointer.x, startPoint.x),
 top: Math.min(pointer.y, startPoint.y)
 });
 }
 fabricCanvas.renderAll();
 return;
 }

 // Handle highlight drawing
 if (!isDrawingHighlight || !currentHighlightShape || !startPoint) return;
 const pointer = fabricCanvas.getPointer(o.e);
 if (currentTool === 'highlighter-rect') {
 currentHighlightShape.set({
 width: Math.abs(pointer.x - startPoint.x),
 height: Math.abs(pointer.y - startPoint.y),
 left: Math.min(pointer.x, startPoint.x),
 top: Math.min(pointer.y, startPoint.y),
 });
 } else if (currentTool === 'highlighter-circle') {
 currentHighlightShape.set({
 rx: Math.abs(pointer.x - startPoint.x) / 2,
 ry: Math.abs(pointer.y - startPoint.y) / 2,
 left: Math.min(pointer.x, startPoint.x),
 top: Math.min(pointer.y, startPoint.y),
 });
 if (currentHighlightShape.rx < 0) currentHighlightShape.rx *= -1;
 if (currentHighlightShape.ry < 0) currentHighlightShape.ry *= -1;
 }
 fabricCanvas.renderAll();
 });

 fabricCanvas.on('mouse:up', (o) => {
 // Block all events during gestures
 if (isGesturing) {
     if (o && o.e) {
         o.e.preventDefault();
         o.e.stopPropagation();
     }
     return false;
 }

 // Handle shape drawing completion
 if (isDrawingShape) {
 isDrawingShape = false;
 if (currentDrawingShape) {
 currentDrawingShape.setCoords();
 fabricCanvas.setActiveObject(currentDrawingShape);

            // Create command for undo/redo support (use CommandHistory API)
            if (!isExecutingCommand && commandHistory) {
                const cmd = new AddObjectCommand(currentDrawingShape, `Draw ${currentDrawingShape.type}`);
                commandHistory.executeCommand(cmd);
            }

 // Send the completed shape to other users (for collaboration)
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üé® Sending completed shape to other users:', currentDrawingShape.type, currentDrawingShape.id);
 sendCanvasOperation('object_added', {
 object: currentDrawingShape.toObject(),
 object_id: currentDrawingShape.id
 });
 }
 }
 currentDrawingShape = null;
 startPoint = null;

            // Auto-switch to Select tool for immediate manipulation
            fabricCanvas.selection = true;
            fabricCanvas.getObjects().forEach(obj => { obj.selectable = true; obj.evented = true; });
            currentTool = 'select';
            setActiveToolButton(selectToolButton);

 return;
 }

 // Handle highlight drawing completion
 if (isDrawingHighlight) {
 isDrawingHighlight = false;
 if(currentHighlightShape) {
 currentHighlightShape.setCoords();
 fabricCanvas.setActiveObject(currentHighlightShape);

            // Create command for undo/redo support (use CommandHistory API)
            if (!isExecutingCommand && commandHistory) {
                const cmd = new AddObjectCommand(currentHighlightShape, `Draw ${currentHighlightShape.type} Highlight`);
                commandHistory.executeCommand(cmd);
            }

 // Send the finished highlight to other users (for collaboration)
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üé® Sending completed highlight to other users:', currentHighlightShape.type, currentHighlightShape.id);
 sendCanvasOperation('object_added', {
 object: currentHighlightShape.toObject(),
 object_id: currentHighlightShape.id
 });
 }
 }
 currentHighlightShape = null;
 startPoint = null;

            // Auto-switch to Select tool for immediate manipulation
            fabricCanvas.selection = true;
            fabricCanvas.getObjects().forEach(obj => { obj.selectable = true; obj.evented = true; });
            currentTool = 'select';
            setActiveToolButton(selectToolButton);
 }
 });

 // Hide magnifier when mouse leaves canvas area
 canvasParent.addEventListener('mouseleave', () => { if (magnifierActive) magnifierPreview.style.display = 'none'; });
 // canvasParent.addEventListener('mouseenter', () => { if (magnifierActive) magnifierPreview.style.display = 'block'; });

 // Prevent object selection during drawing modes, gestures, and Pan Mode
 fabricCanvas.on('selection:created', (e) => {
 // Block selection in Pan Mode
 if (isPanModeActive) {
 console.log('üéØ Pan Mode active - preventing object selection');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 if (isDrawingShape || isDrawingHighlight || isAddingText || fabricCanvas.isDrawingMode) {
 console.log('üö´ Preventing object selection during drawing mode');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 // Only block selection during actual two-finger gestures AND when NOT in select mode
 if (isGesturing && touchStartPoint && currentTool !== 'select') {
 console.log('üö´ Preventing object selection during two-finger gesture');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 // Allow selection in select mode even during gestures (for single touch)
 if (currentTool === 'select' && isGesturing) {
 console.log('‚úÖ Allowing selection in select mode despite gesture flag');
 }
 });

 fabricCanvas.on('selection:updated', (e) => {
 // Block selection in Pan Mode
 if (isPanModeActive) {
 console.log('üéØ Pan Mode active - preventing object selection update');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 if (isDrawingShape || isDrawingHighlight || isAddingText || fabricCanvas.isDrawingMode) {
 console.log('üö´ Preventing object selection update during drawing mode');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 // Only block selection during actual two-finger gestures AND when NOT in select mode
 if (isGesturing && touchStartPoint && currentTool !== 'select') {
 console.log('üö´ Preventing object selection update during two-finger gesture');
 fabricCanvas.discardActiveObject();
 fabricCanvas.renderAll();
 return;
 }

 // Allow selection updates in select mode even during gestures (for single touch)
 if (currentTool === 'select' && isGesturing) {
 console.log('‚úÖ Allowing selection update in select mode despite gesture flag');
 }
 }); // Handled by mouse:move on canvas

 // --- Image Handling Functions ---
 function handleImagePaste(file) {
 console.log('üìã handleImagePaste called with file:', file.name, file.type, file.size, 'bytes');
 const reader = new FileReader();

 reader.onload = function(event) {
 const imageDataUrl = event.target.result;
 console.log('üì∑ Image loaded from clipboard, creating fabric image...');

 // Create fabric image from the data URL
 fabric.Image.fromURL(imageDataUrl, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create fabric image from URL');
 addChatMessage('System', 'Failed to create image. Please try again.');
 return;
 }

 // Generate unique ID for the image
 img.id = generateObjectId();

 console.log('üì∑ Original image dimensions:', img.width, 'x', img.height);

 // Set initial properties
 const maxWidth = 400;
 const maxHeight = 400;

 // Scale image if it's too large
 if (img.width > maxWidth || img.height > maxHeight) {
 const scaleX = maxWidth / img.width;
 const scaleY = maxHeight / img.height;
 const scale = Math.min(scaleX, scaleY);

 img.scale(scale);
 console.log('üìè Image scaled by factor:', scale);
 }

 // Position image at cursor position, fallback to center if no cursor position is available
 let imageLeft, imageTop;
 if (lastMousePosition.x !== undefined && lastMousePosition.y !== undefined &&
     (lastMousePosition.x !== 0 || lastMousePosition.y !== 0)) {
 	// Use cursor position, offset by half the image size so cursor is at center of image
 	imageLeft = lastMousePosition.x - (img.getScaledWidth() / 2);
 	imageTop = lastMousePosition.y - (img.getScaledHeight() / 2);
 	console.log(`üìç Pasted image positioned at cursor location: (${lastMousePosition.x}, ${lastMousePosition.y})`);
 } else {
 	// Fallback to center if no cursor position is available
 	imageLeft = (fabricCanvas.width / 2) - (img.getScaledWidth() / 2);
 	imageTop = (fabricCanvas.height / 2) - (img.getScaledHeight() / 2);
 	console.log('üìç Pasted image positioned at canvas center (fallback)');
 }

 img.set({
 left: imageLeft,
 top: imageTop,
 selectable: true,
 evented: true,
 visible: true,
 opacity: 1
 });

 console.log('üìç Final image position:', imageLeft, imageTop);

 // Skip the automatic object:added event for this image since we're handling sync manually
 skipNextObjectAdded = true;

 // Function to ensure image is rendered properly
 function ensureImageRendered() {
 console.log('üîÑ Ensuring image is rendered...');

 // Check if image element is loaded
 const imgElement = img.getElement();
 if (imgElement && !imgElement.complete) {
 console.log('‚è≥ Image element not fully loaded, waiting...');
 imgElement.onload = function() {
 console.log('‚úÖ Image element loaded, rendering...');
 fabricCanvas.renderAll();
 };
 } else {
 console.log('‚úÖ Image element ready, rendering immediately...');
 fabricCanvas.renderAll();
 }

 // Force additional renders as fallback
 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Fallback render 1 completed');
 }, 50);

 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Fallback render 2 completed');
 }, 200);
 }

      // Add image to canvas
      fabricCanvas.add(img);
      fabricCanvas.setActiveObject(img);
      
      // Ensure proper rendering
      ensureImageRendered();

 console.log('‚úÖ Image added to canvas:', img.id, 'final size:', img.getScaledWidth(), 'x', img.getScaledHeight());
 console.log('üéØ Canvas objects count:', fabricCanvas.getObjects().length);

 // Send to other users if in a room
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üöÄ Sending pasted image to other users');
 sendCanvasOperation('object_added', {
 object: img.toObject(),
 object_id: img.id
 });
 }

      // After adding an image, switch to Select tool for manipulation
      try {
        currentTool = 'select';
        setActiveToolButton(selectToolButton);
        fabricCanvas.selection = true;
      } catch (_) {}

      // Removed noisy success message - image appearance is self-evident

 }, function(img, isError) {
 // Error callback
 if (isError) {
 console.error('‚ùå Error loading image:', isError);
 addChatMessage('AI', 'Failed to load pasted image. Please try again.');
 }
 }, {
 // Options for fabric.Image.fromURL
 crossOrigin: 'anonymous'
 });
 };

 reader.onerror = function(error) {
 console.error('‚ùå Error reading pasted image:', error);
 addChatMessage('AI', 'Failed to read pasted image. Please try again.');
 };

 // Read the file as data URL
 reader.readAsDataURL(file);
 }

 // Handle image upload from file input
 function handleImageUpload(file) {
 const reader = new FileReader();

 reader.onload = function(event) {
 const imageDataUrl = event.target.result;
 console.log(`üì∑ Image loaded from file upload: ${file.name}, creating fabric image...`);

 // Create fabric image from the data URL
 fabric.Image.fromURL(imageDataUrl, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create fabric image from uploaded file');
 return;
 }

 // Generate unique ID for the image
 pastedImageCounter++;
 const imageId = generateObjectId();
 img.id = imageId;

 console.log('üñºÔ∏è Uploaded image created:', img.width, 'x', img.height);

 // Calculate scaling to fit within reasonable bounds
 const maxWidth = fabricCanvas.width * 0.4; // 40% of canvas width
 const maxHeight = fabricCanvas.height * 0.4; // 40% of canvas height

 let scaleX = 1;
 let scaleY = 1;

 if (img.width > maxWidth) {
 scaleX = maxWidth / img.width;
 }
 if (img.height > maxHeight) {
 scaleY = maxHeight / img.height;
 }

 // Use the smaller scale to maintain aspect ratio
 const scale = Math.min(scaleX, scaleY);

 if (scale < 1) {
 img.scale(scale);
 console.log('üìè Scaled uploaded image by factor:', scale);
 }

 // Position the image at the cursor position (or center if no cursor position available)
 let positionX, positionY;

 if (lastMousePosition.x !== undefined && lastMousePosition.y !== undefined) {
 // Use cursor position, offset by half the image size so cursor is at center of image
 positionX = lastMousePosition.x - (img.getScaledWidth() / 2);
 positionY = lastMousePosition.y - (img.getScaledHeight() / 2);
 console.log(`üìç Positioning image at cursor location: (${lastMousePosition.x}, ${lastMousePosition.y})`);
 } else {
 // Fallback to center if no cursor position is available
 positionX = (fabricCanvas.width / 2) - (img.getScaledWidth() / 2);
 positionY = (fabricCanvas.height / 2) - (img.getScaledHeight() / 2);
 console.log('üìç No cursor position available, positioning image at canvas center');
 }

 img.set({
 left: positionX,
 top: positionY,
 selectable: true,
 evented: true
 });

      // Add to canvas
      fabricCanvas.add(img);
      fabricCanvas.setActiveObject(img);
      fabricCanvas.renderAll();

 console.log('‚úÖ Uploaded image added to canvas:', img.id, 'final size:', img.getScaledWidth(), 'x', img.getScaledHeight());
 console.log('üéØ Canvas objects count:', fabricCanvas.getObjects().length);

      // After upload, switch to Select tool for manipulation
      try {
        currentTool = 'select';
        setActiveToolButton(selectToolButton);
        fabricCanvas.selection = true;
      } catch (_) {}

      // Send to other users if in a room
      if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üöÄ Sending uploaded image to other users');
 sendCanvasOperation('object_added', {
 object: img.toObject(),
 object_id: img.id
 });
 }

 }, function(img, isError) {
 // Error callback
 if (isError) {
 console.error('‚ùå Error loading uploaded image:', isError);
 }
 }, {
 // Options for fabric.Image.fromURL
 crossOrigin: 'anonymous'
 });
 };

 reader.onerror = function(error) {
 console.error('‚ùå Error reading uploaded image:', error);
 };

 // Read the file as data URL
 reader.readAsDataURL(file);
 }

 // --- Image Debugging Functions ---
 function debugCanvasImages() {
 console.log('üîç Canvas Image Debug Information:');
 console.log('================================');

 const allObjects = fabricCanvas.getObjects();
 const images = allObjects.filter(obj => obj.type === 'image');

 console.log('üìä Total objects on canvas:', allObjects.length);
 console.log('üñºÔ∏è Total images on canvas:', images.length);

 if (images.length > 0) {
 images.forEach((img, index) => {
 console.log(`üñºÔ∏è Image ${index + 1}:`, {
 id: img.id,
 visible: img.visible,
 opacity: img.opacity,
 left: img.left,
 top: img.top,
 width: img.width,
 height: img.height,
 scaleX: img.scaleX,
 scaleY: img.scaleY,
 angle: img.angle,
 selectable: img.selectable,
 evented: img.evented,
 srcLength: img.src?.length || 0
 });
 });
 } else {
 console.log('‚ùå No images found on canvas');
 }

 // Check canvas rendering
 console.log('üé® Canvas info:', {
 width: fabricCanvas.width,
 height: fabricCanvas.height,
 backgroundColor: fabricCanvas.backgroundColor,
 selection: fabricCanvas.selection
 });

 return {
 totalObjects: allObjects.length,
 totalImages: images.length,
 images: images.map(img => ({
 id: img.id,
 visible: img.visible,
 position: { left: img.left, top: img.top },
 size: { width: img.width, height: img.height },
 scale: { x: img.scaleX, y: img.scaleY }
 }))
 };
 }

 // Add debug function to global scope for console access
 window.debugCanvasImages = debugCanvasImages;

 // Comprehensive diagnostic function
 function runImageDiagnostics() {
 console.log('üî¨ RUNNING COMPREHENSIVE IMAGE DIAGNOSTICS');
 console.log('==========================================');

 const results = {
 canvasExists: !!fabricCanvas,
 chatInputExists: !!chatInput,
 pasteHandlerExists: false,
 fabricVersion: typeof fabric !== 'undefined' ? fabric.version : 'not loaded',
 currentObjects: fabricCanvas ? fabricCanvas.getObjects().length : 0,
 currentImages: fabricCanvas ? fabricCanvas.getObjects().filter(obj => obj.type === 'image').length : 0
 };

 // Test 1: Canvas basic functionality
 console.log('üß™ Test 1: Canvas Basic Functionality');
 console.log('Canvas exists:', results.canvasExists);
 console.log('Canvas size:', fabricCanvas?.width, 'x', fabricCanvas?.height);
 console.log('Canvas selection enabled:', fabricCanvas?.selection);

 // Test 2: DOM elements
 console.log('üß™ Test 2: DOM Elements');
 console.log('chatInput exists:', results.chatInputExists);
 console.log('chatInput element:', chatInput);
 console.log('Active element:', document.activeElement?.tagName, document.activeElement?.id);

 // Test 3: Event listeners
 console.log('üß™ Test 3: Event Listeners');
 const pasteEvents = getEventListeners ? getEventListeners(document).paste : 'Cannot check (Chrome DevTools only)';
 console.log('Paste event listeners:', pasteEvents);

 // Test 4: Fabric.js functionality
 console.log('üß™ Test 4: Fabric.js Functionality');
 console.log('Fabric version:', results.fabricVersion);
 console.log('fabric.Image available:', typeof fabric?.Image);
 console.log('fabric.util.enlivenObjects available:', typeof fabric?.util?.enlivenObjects);

 // Test 5: Current canvas state
 console.log('üß™ Test 5: Canvas State');
 console.log('Total objects:', results.currentObjects);
 console.log('Total images:', results.currentImages);

 if (fabricCanvas) {
 const objects = fabricCanvas.getObjects();
 objects.forEach((obj, index) => {
 console.log(`Object ${index}:`, obj.type, obj.id, 'visible:', obj.visible);
 });
 }

 // Test 6: Test simple image creation
 console.log('üß™ Test 6: Simple Image Creation Test');
 const testDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';

 fabric.Image.fromURL(testDataUrl, function(img) {
 console.log('‚úÖ fabric.Image.fromURL test: SUCCESS');
 console.log('Image created:', !!img);
 if (img) {
 console.log('Image dimensions:', img.width, 'x', img.height);
 }
 }, function(img, isError) {
 console.log('‚ùå fabric.Image.fromURL test: FAILED');
 console.log('Error:', isError);
 });

 console.log('==========================================');
 console.log('üìä DIAGNOSTIC RESULTS SUMMARY:');
 console.log(JSON.stringify(results, null, 2));

 return results;
 }

 // Add to global scope
 window.runImageDiagnostics = runImageDiagnostics;

 // Simplified paste test function
 function testImagePasteDirectly() {
 console.log('üß™ TESTING IMAGE PASTE DIRECTLY');
 console.log('===============================');

 // Create a test image data URL
 const canvas = document.createElement('canvas');
 canvas.width = 200;
 canvas.height = 150;
 const ctx = canvas.getContext('2d');

 // Create a gradient background
 const gradient = ctx.createLinearGradient(0, 0, 200, 150);
 gradient.addColorStop(0, '#ff6b6b');
 gradient.addColorStop(1, '#4ecdc4');
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 200, 150);

 // Add text
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 24px Arial';
 ctx.textAlign = 'center';
 ctx.fillText('PASTE TEST', 100, 80);
 ctx.font = '14px Arial';
 ctx.fillText(new Date().toLocaleTimeString(), 100, 110);

 const imageDataUrl = canvas.toDataURL();
 console.log('üì∑ Test image created, data URL length:', imageDataUrl.length);

 // Test the exact same logic as handleImagePaste
 fabric.Image.fromURL(imageDataUrl, function(img) {
 console.log('üì∑ fabric.Image.fromURL callback triggered');

 if (!img) {
 console.error('‚ùå Failed to create fabric image from URL');
 return;
 }

 console.log('‚úÖ Fabric image created successfully');
 console.log('üìè Original dimensions:', img.width, 'x', img.height);

 // Generate unique ID
 img.id = `test_paste_${Date.now()}`;
 console.log('üÜî Generated ID:', img.id);

 // Set properties exactly like in handleImagePaste
 const maxWidth = 400;
 const maxHeight = 400;

 if (img.width > maxWidth || img.height > maxHeight) {
 const scaleX = maxWidth / img.width;
 const scaleY = maxHeight / img.height;
 const scale = Math.min(scaleX, scaleY);
 img.scale(scale);
 console.log('üìè Image scaled by factor:', scale);
 }

 // Position at center
 const canvasCenter = fabricCanvas.getCenter();
 console.log('üìç Canvas center:', canvasCenter);

 img.set({
 left: canvasCenter.left,
 top: canvasCenter.top,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 visible: true,
 opacity: 1
 });

 console.log('üéØ Image properties set:', {
 left: img.left,
 top: img.top,
 visible: img.visible,
 opacity: img.opacity,
 selectable: img.selectable
 });

 // Skip automatic event
 skipNextObjectAdded = true;
 console.log('‚è≠Ô∏è skipNextObjectAdded set to true');

 // Add to canvas
 console.log('‚ûï Adding image to canvas...');
 fabricCanvas.add(img);
 fabricCanvas.setActiveObject(img);
 fabricCanvas.renderAll();

 console.log('‚úÖ Image added to canvas');
 console.log('üéØ Canvas objects count:', fabricCanvas.getObjects().length);
 console.log('üñºÔ∏è Canvas images count:', fabricCanvas.getObjects().filter(obj => obj.type === 'image').length);

 // Verify the image is actually there
 const addedImage = fabricCanvas.getObjects().find(obj => obj.id === img.id);
 console.log('üîç Image verification:', !!addedImage);

 if (addedImage) {
 console.log('‚úÖ SUCCESS: Image is on canvas and should be visible');
 } else {
 console.log('‚ùå FAILURE: Image not found on canvas');
 }

 }, function(img, isError) {
 console.log('‚ùå fabric.Image.fromURL error callback triggered');
 console.log('Error details:', isError);
 });

 console.log('üöÄ Test function completed, waiting for async callbacks...');
 }

 // Add to global scope
 window.testImagePasteDirectly = testImagePasteDirectly;

 // Test function for image synchronization
 function testImageSync() {
 console.log('üß™ Testing image synchronization...');

 // Create a test image
 const canvas = document.createElement('canvas');
 canvas.width = 150;
 canvas.height = 100;
 const ctx = canvas.getContext('2d');

 // Create a gradient background
 const gradient = ctx.createLinearGradient(0, 0, 150, 100);
 gradient.addColorStop(0, '#ff6b6b');
 gradient.addColorStop(1, '#4ecdc4');
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 150, 100);

 // Add text
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 16px Arial';
 ctx.textAlign = 'center';
 ctx.fillText('SYNC TEST', 75, 40);
 ctx.font = '12px Arial';
 ctx.fillText(new Date().toLocaleTimeString(), 75, 65);

 const testImageDataUrl = canvas.toDataURL();
 console.log('üì∑ Test sync image created, data URL length:', testImageDataUrl.length);

 // Simulate the exact same process as handleImagePaste
 fabric.Image.fromURL(testImageDataUrl, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create test sync image');
 return;
 }

 img.id = generateObjectId();
 img.set({
 left: 300,
 top: 300,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 visible: true,
 opacity: 1
 });

 console.log('üìç Test sync image positioned at:', img.left, img.top);

 skipNextObjectAdded = true;
 fabricCanvas.add(img);
 fabricCanvas.setActiveObject(img);
 fabricCanvas.renderAll();

 console.log('‚úÖ Test sync image added to canvas:', img.id);

 // Test WebSocket synchronization if in a room
 if (currentRoomId && !isProcessingRemoteOperation) {
 console.log('üöÄ Testing WebSocket sync for image');
 const imageObject = img.toObject();
 console.log('üì¶ Image object to sync:', imageObject);

 sendCanvasOperation('object_added', {
 object: imageObject,
 object_id: img.id
 });

 addChatMessage('System', `Test sync image sent via WebSocket: ${img.id}`);
 } else {
 console.log('‚ö†Ô∏è Not in a room - WebSocket sync not tested');
 addChatMessage('System', `Test sync image added locally (not in room): ${img.id}`);
 }

 }, function(img, isError) {
 console.error('‚ùå Error creating test sync image:', isError);
 });
 }

 // Add to global scope
 window.testImageSync = testImageSync;

 // Enhanced debugging function for image rendering issues
 function debugImageRendering() {
 console.log('üîç === IMAGE RENDERING DEBUG ===');

 const allObjects = fabricCanvas.getObjects();
 const images = allObjects.filter(obj => obj.type === 'image');

 console.log('üìä Canvas Stats:');
 console.log('- Total objects:', allObjects.length);
 console.log('- Total images:', images.length);
 console.log('- Canvas size:', fabricCanvas.width, 'x', fabricCanvas.height);
 console.log('- Canvas zoom:', fabricCanvas.getZoom());
 console.log('- Canvas background:', fabricCanvas.backgroundColor);

 if (images.length > 0) {
 console.log('üñºÔ∏è Image Details:');
 images.forEach((img, index) => {
 console.log(`Image ${index + 1}:`, {
 id: img.id,
 visible: img.visible,
 opacity: img.opacity,
 left: img.left,
 top: img.top,
 width: img.width,
 height: img.height,
 scaleX: img.scaleX,
 scaleY: img.scaleY,
 angle: img.angle,
 originX: img.originX,
 originY: img.originY,
 selectable: img.selectable,
 evented: img.evented,
 srcLength: img.src?.length || 0,
 element: img.getElement(),
 isLoaded: img.getElement()?.complete || false
 });

 // Check if image element is properly loaded
 const imgElement = img.getElement();
 if (imgElement) {
 console.log(`Image ${index + 1} element:`, {
 complete: imgElement.complete,
 naturalWidth: imgElement.naturalWidth,
 naturalHeight: imgElement.naturalHeight,
 src: imgElement.src?.substring(0, 50) + '...'
 });
 }
 });
 } else {
 console.log('‚ùå No images found on canvas');
 }

 // Force a render and check again
 console.log('üîÑ Forcing render...');
 fabricCanvas.renderAll();

 setTimeout(() => {
 console.log('üîÑ Post-render check...');
 const postRenderImages = fabricCanvas.getObjects().filter(obj => obj.type === 'image');
 console.log('üìä Post-render image count:', postRenderImages.length);
 }, 100);

 console.log('üîç === DEBUG COMPLETE ===');
 return {
 totalObjects: allObjects.length,
 totalImages: images.length,
 images: images.map(img => ({
 id: img.id,
 visible: img.visible,
 opacity: img.opacity,
 isLoaded: img.getElement()?.complete || false
 }))
 };
 }

 // Add to global scope
 window.debugImageRendering = debugImageRendering;

 // Quick test function for immediate image visibility
 function testImageVisibility() {
 console.log('üß™ Testing immediate image visibility...');

 // Create a simple test image
 const canvas = document.createElement('canvas');
 canvas.width = 200;
 canvas.height = 150;
 const ctx = canvas.getContext('2d');

 // Create a colorful test pattern
 const gradient = ctx.createRadialGradient(100, 75, 0, 100, 75, 100);
 gradient.addColorStop(0, '#ff0080');
 gradient.addColorStop(0.5, '#00ff80');
 gradient.addColorStop(1, '#8000ff');
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 200, 150);

 // Add text
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 20px Arial';
 ctx.textAlign = 'center';
 ctx.strokeStyle = '#000000';
 ctx.lineWidth = 2;
 ctx.strokeText('VISIBILITY TEST', 100, 80);
 ctx.fillText('VISIBILITY TEST', 100, 80);
 ctx.font = '14px Arial';
 ctx.strokeText(new Date().toLocaleTimeString(), 100, 110);
 ctx.fillText(new Date().toLocaleTimeString(), 100, 110);

 const testImageDataUrl = canvas.toDataURL();
 console.log('üì∑ Visibility test image created, data URL length:', testImageDataUrl.length);

 // Use the same process as handleImagePaste
 fabric.Image.fromURL(testImageDataUrl, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create visibility test image');
 return;
 }

 img.id = `visibility_test_${Date.now()}`;
 img.set({
 left: 400,
 top: 200,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 visible: true,
 opacity: 1
 });

 console.log('üìç Visibility test image positioned at:', img.left, img.top);

 skipNextObjectAdded = true;
 fabricCanvas.add(img);
 fabricCanvas.setActiveObject(img);

 // Check if image element is loaded and force render
 const imgElement = img.getElement();
 console.log('üîç Image element state:', {
 exists: !!imgElement,
 complete: imgElement?.complete,
 naturalWidth: imgElement?.naturalWidth,
 naturalHeight: imgElement?.naturalHeight
 });

 // Force immediate render
 fabricCanvas.renderAll();
 console.log('üîÑ Immediate render called');

 // Check visibility after render
 setTimeout(() => {
 const addedImg = fabricCanvas.getObjects().find(obj => obj.id === img.id);
 console.log('üîç Image visibility check:', {
 found: !!addedImg,
 visible: addedImg?.visible,
 opacity: addedImg?.opacity,
 onCanvas: fabricCanvas.getObjects().includes(addedImg)
 });

 if (addedImg && addedImg.visible) {
 addChatMessage('System', `‚úÖ Visibility test PASSED - Image should be visible: ${img.id}`);
 } else {
 addChatMessage('System', `‚ùå Visibility test FAILED - Image not visible: ${img.id}`);
 }
 }, 100);

 console.log('‚úÖ Visibility test image added:', img.id);

 }, function(img, isError) {
 console.error('‚ùå Error creating visibility test image:', isError);
 });
 }

 // Add to global scope
 window.testImageVisibility = testImageVisibility;

 // Test image function for debugging
 function addTestImage() {
 console.log('üß™ Adding test image for debugging...');

 // Create a simple test image (red square)
 const canvas = document.createElement('canvas');
 canvas.width = 100;
 canvas.height = 100;
 const ctx = canvas.getContext('2d');
 ctx.fillStyle = '#ff0000';
 ctx.fillRect(0, 0, 100, 100);
 ctx.fillStyle = '#ffffff';
 ctx.font = '20px Arial';
 ctx.textAlign = 'center';
 ctx.fillText('TEST', 50, 55);

 const testImageDataUrl = canvas.toDataURL();

 fabric.Image.fromURL(testImageDataUrl, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create test image');
 addChatMessage('System', 'Failed to create test image');
 return;
 }

 img.id = generateObjectId();
 img.set({
 left: 200,
 top: 200,
 originX: 'center',
 originY: 'center',
 selectable: true,
 evented: true,
 visible: true,
 opacity: 1
 });

 skipNextObjectAdded = true;
 fabricCanvas.add(img);
 fabricCanvas.setActiveObject(img);
 fabricCanvas.renderAll();

 console.log('‚úÖ Test image added:', img.id);
 addChatMessage('System', `Test image added: ${img.id}`);

 if (currentRoomId && !isProcessingRemoteOperation) {
 sendCanvasOperation('object_added', {
 object: img.toObject(),
 object_id: img.id
 });
 }
 }, function(img, isError) {
 if (isError) {
 console.error('‚ùå Error creating test image:', isError);
 addChatMessage('System', 'Error creating test image');
 }
 });
 }

 // --- Chat Scroll Management ---
 let isUserScrollingAI = false;
 let isUserScrollingGroup = false;
 let aiScrollTimeout = null;
 let groupScrollTimeout = null;

 function isNearBottom(container, threshold = 100) {
 return container.scrollTop + container.clientHeight >= container.scrollHeight - threshold;
 }

 function shouldAutoScroll(container, isUserScrolling) {
 return !isUserScrolling || isNearBottom(container);
 }

 function smoothScrollToBottom(container, force = false) {
 if (force || shouldAutoScroll(container, container === chatHistory ? isUserScrollingAI : isUserScrollingGroup)) {
 container.scrollTo({
 top: container.scrollHeight,
 behavior: 'smooth'
 });
 }
 }

 function updateScrollIndicator(container) {
 const hasMoreContent = !isNearBottom(container, 50);
 if (hasMoreContent) {
 container.classList.add('has-more-content');
 } else {
 container.classList.remove('has-more-content');
 }
 }

 function setupScrollListeners() {
 // AI Chat scroll listener
 if (chatHistory) {
 chatHistory.addEventListener('scroll', () => {
 isUserScrollingAI = true;
 updateScrollIndicator(chatHistory);
 clearTimeout(aiScrollTimeout);
 aiScrollTimeout = setTimeout(() => {
 isUserScrollingAI = false;
 }, 1000);
 });
 }

 // Group messaging scroll listener
 if (groupMessages) {
 groupMessages.addEventListener('scroll', () => {
 isUserScrollingGroup = true;
 updateScrollIndicator(groupMessages);
 clearTimeout(groupScrollTimeout);
 groupScrollTimeout = setTimeout(() => {
 isUserScrollingGroup = false;
 }, 1000);
 });
 }

 // Setup resize observer for responsive behavior
 if (window.ResizeObserver) {
 const resizeObserver = new ResizeObserver(entries => {
 for (let entry of entries) {
 const container = entry.target;
 if (container === chatHistory || container === groupMessages) {
 // Update scroll indicators after resize
 setTimeout(() => {
 updateScrollIndicator(container);
 // Auto-scroll if user was at bottom before resize
 if (isNearBottom(container, 150)) {
 smoothScrollToBottom(container, true);
 }
 }, 100);
 }
 }
 });

 if (chatHistory) resizeObserver.observe(chatHistory);
 if (groupMessages) resizeObserver.observe(groupMessages);
 }
 }

 // --- Chat Functions ---
 function showTypingIndicator() {
 const existingIndicator = document.getElementById('typing-indicator');
 if (existingIndicator) return;

 const typingDiv = document.createElement('div');
 typingDiv.id = 'typing-indicator';
 typingDiv.className = 'ai-message self-start mr-auto max-w-[95%]';
 typingDiv.innerHTML = `
 <strong>AI: </strong>
 <span class="typing-indicator">
 <div class="typing-dot"></div>
 <div class="typing-dot"></div>
 <div class="typing-dot"></div>
 </span>
 `;
 chatHistory.appendChild(typingDiv);

 setTimeout(() => {
 smoothScrollToBottom(chatHistory);
 }, 50);
 }

 function hideTypingIndicator() {
 const indicator = document.getElementById('typing-indicator');
 if (indicator) {
 indicator.remove();
 }
 }

 // PDF Viewer AI Functions
 function capturePdfPageScreenshot() {
 try {
 // Get the current visible PDF page
 const pdfContainer = document.getElementById('pdf-container');
 const viewerArea = document.getElementById('pdf-viewer-area');
 if (!pdfContainer || !currentPdfDoc || !viewerArea) {
 addChatMessage('System', '‚ùå No PDF loaded or visible');
 return null;
 }

 // Find all rendered pages and pick the one most visible in the viewport
 const pageElements = Array.from(pdfContainer.querySelectorAll('.pdf-page'));
 if (pageElements.length === 0) {
 addChatMessage('System', '‚ùå No PDF pages rendered');
 return null;
 }

 const viewerRect = viewerArea.getBoundingClientRect();
 let bestIndex = Math.max(0, currentPdfPage - 1);
 let bestVisibility = 0;

 pageElements.forEach((el, idx) => {
 const rect = el.getBoundingClientRect();
 const overlapX = Math.max(0, Math.min(rect.right, viewerRect.right) - Math.max(rect.left, viewerRect.left));
 const overlapY = Math.max(0, Math.min(rect.bottom, viewerRect.bottom) - Math.max(rect.top, viewerRect.top));
 const visibleArea = overlapX * overlapY;
 const totalArea = Math.max(1, rect.width * rect.height);
 const visibility = visibleArea / totalArea;

 if (visibility > bestVisibility) {
 bestVisibility = visibility;
 bestIndex = idx;
 }
 });

 currentPdfPage = bestIndex + 1;
 if (pdfPageInput) pdfPageInput.value = currentPdfPage;
 updateNavigationButtons();

 // Create a canvas to capture only the active page
 const currentPageElement = pageElements[bestIndex];
 const pageCanvas = currentPageElement.querySelector('canvas');
 if (!pageCanvas) {
 addChatMessage('System', '‚ùå Could not find PDF page canvas');
 return null;
 }

 // Downscale very large pages so we only send one lightweight snapshot to AI
 const MAX_DIMENSION = 1600; // keep payload small enough for the AI API
 const largestSide = Math.max(pageCanvas.width, pageCanvas.height) || 1;
 const scale = Math.min(1, MAX_DIMENSION / largestSide);
 const targetWidth = Math.max(1, Math.round(pageCanvas.width * scale));
 const targetHeight = Math.max(1, Math.round(pageCanvas.height * scale));

 const canvas = document.createElement('canvas');
 canvas.width = targetWidth;
 canvas.height = targetHeight;
 const ctx = canvas.getContext('2d');
 ctx.drawImage(pageCanvas, 0, 0, targetWidth, targetHeight);

 // Use JPEG to further reduce payload size without hurting readability
 const dataURL = canvas.toDataURL('image/jpeg', 0.9);
 const approxKb = Math.round((dataURL.length * 3) / 4 / 1024);
 console.log('üì∏ PDF page screenshot captured', {
 page: currentPdfPage,
 dimensions: `${targetWidth}x${targetHeight}`,
 approxKb
 });

 return dataURL;
 } catch (error) {
 console.error('Error capturing PDF screenshot:', error);
 addChatMessage('System', `‚ùå Screenshot error: ${error.message}`);
 return null;
 }
 }

function sendPdfPageToAI() {
    try {
        // Always clear old snapshots so we only queue one PDF image
        pendingImageForChat = null;
        pendingImageMetadata = null;

        const screenshot = capturePdfPageScreenshot();
        if (!screenshot) {
            return;
        }

        // Add the image to AI chat
        addChatMessage('User', `üìÑ PDF Page ${currentPdfPage}`, false, screenshot);

        // Store as pending image so the next prompt automatically includes it
        pendingImageForChat = screenshot;
        pendingImageMetadata = { type: 'pdf', page: currentPdfPage };
        console.log('üíæ Stored PDF page image for AI chat', pendingImageMetadata);

        // Provide guidance similar to the Ask AI canvas workflow
        addChatMessage('AI', `PDF page ${currentPdfPage} captured! Type your question below and press Send so I can help.`);

        // Switch to AI chat tab to show the sent image
        switchTab('ai-chat');
        chatInput.focus();

    } catch (error) {
        console.error('Error sending PDF to AI:', error);
        addChatMessage('AI', `Sorry, I couldn't capture that PDF page: ${error.message}`);
    }
}

 function addChatMessage(sender, message, isHtml = false, imageData = null, replyTo = null) {
 // Filter system messages - only allow join/leave events and network diagnostics
 if (sender.toLowerCase() === 'system') {
 const allowedSystemMessages = [
 'joined the room',
 'left the room',
 'joined the chat',
 'left the chat',
 'try these solutions',
 'running network diagnostic',
 'network diagnostic',
 'cleared sent pdf images',
 'recommendations:',
 'move closer to your phone',
 'switch to wifi',
 'use a vpn',
 'change dns',
 'restart your mobile hotspot',
 'network connectivity issue',
 'diagnostic failed'
 ];

 const isAllowedSystemMessage = allowedSystemMessages.some(allowed =>
 message.toLowerCase().includes(allowed)
 );

 if (!isAllowedSystemMessage) {
 // Skip this system message - don't display it
 console.log('üö´ Filtered system message:', message);
 return;
 }
 }

 const msgDiv = document.createElement('div');

 // Generate unique message ID
 const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
 const messageTimestamp = Date.now();
 msgDiv.setAttribute('data-message-id', messageId);

 let senderPrefix = '';
 if (sender.toLowerCase() === 'user') {
 msgDiv.className = 'user-message self-start mr-auto max-w-[95%] message-item';
 senderPrefix = 'You: ';
 // Store user messages in persistent history (including image data)
 const historyEntry = { sender: 'user', message: message, timestamp: messageTimestamp, id: messageId };
 if (imageData) historyEntry.imageData = imageData;
 if (replyTo) historyEntry.replyTo = replyTo;
 chatHistoryStorage.push(historyEntry);
 } else if (sender.toLowerCase() === 'ai') {
 msgDiv.className = 'ai-message self-start mr-auto max-w-[95%] message-item';
 senderPrefix = 'AI: ';
 // Store AI messages in persistent history
 const historyEntry = { sender: 'ai', message: message, timestamp: messageTimestamp, id: messageId };
 if (replyTo) historyEntry.replyTo = replyTo;
 chatHistoryStorage.push(historyEntry);
 } else { // System
 msgDiv.className = 'system-message-ai text-center w-full message-item';
 senderPrefix = 'System: ';
 // Don't store system messages in persistent history for AI context
 }

 const senderStrong = document.createElement('strong');
 senderStrong.textContent = senderPrefix;

 // Add reply context if this is a reply
 if (replyTo) {
 const replyContext = document.createElement('div');
 replyContext.className = 'reply-context';
 replyContext.style.cssText = 'cursor: pointer; background: #22c55e !important; color: white !important; padding: 10px !important; margin: 5px 0 !important; border-radius: 5px !important;';
 replyContext.title = 'Click to go to original message';
 replyContext.setAttribute('data-reply-to-id', replyTo.id);

 const replyHeader = document.createElement('div');
 replyHeader.className = 'reply-context-header';
 replyHeader.style.cssText = 'color: white !important; font-weight: bold !important;';
 replyHeader.textContent = `~ ${replyTo.sender === 'user' ? 'You' : replyTo.sender}`;

 const replyContent = document.createElement('div');
 replyContent.className = 'reply-context-content';
 replyContent.style.cssText = 'color: #f0f0f0 !important;';
 const messageText = replyTo.message || '';
 const cleanMessage = messageText.replace(/<[^>]*>/g, '').substring(0, 100);
 replyContent.textContent = cleanMessage + (messageText.length > 100 ? '...' : '');

 // Add click handler to scroll to original message
 replyContext.addEventListener('click', () => {
 const replyToId = replyContext.getAttribute('data-reply-to-id');
 if (replyToId) {
 scrollToMessage(replyToId);
 }
 });

 replyContext.appendChild(replyHeader);
 replyContext.appendChild(replyContent);
 msgDiv.appendChild(replyContext);
 }

 // Always add sender prefix first
 if(senderPrefix) msgDiv.appendChild(senderStrong);

 // Add image preview if imageData is provided (before the text)
 if (imageData) {
 const imageContainer = document.createElement('div');
 imageContainer.className = 'image-preview-container mb-3 p-3 bg-slate-50 dark:bg-slate-800 rounded-xl border border-slate-200 dark:border-slate-600 shadow-sm';

 const img = document.createElement('img');
 img.src = imageData;
 img.alt = 'Attached image';
 img.className = 'w-full max-h-64 rounded-lg border border-slate-200 dark:border-slate-600 cursor-pointer hover:opacity-90 transition-opacity block object-contain';
 img.onclick = () => openImageModal(imageData, 'Attached image');

 imageContainer.appendChild(img);
 msgDiv.appendChild(imageContainer);
 }

 // Add text message content (after the image)
 const messageContentDiv = document.createElement('div');
 messageContentDiv.className = 'message-text-content';

 if (isHtml) {
 messageContentDiv.innerHTML = message;
 } else {
 // Apply Tailwind classes to pre/code if not using HTML for message content
 const codeBlockRegex = /(```python\n[\s\S]*?```|```[\s\S]*?```)/g;
 const parts = message.split(codeBlockRegex);
 parts.forEach(part => {
 if (codeBlockRegex.test(part)) {
 const pre = document.createElement('pre');
 pre.className = "bg-slate-800 dark:bg-black text-slate-100 dark:text-slate-200 p-3 my-2 rounded-md overflow-x-auto text-xs";
 const code = document.createElement('code');
 code.textContent = part.replace(/^```python\n|^```|```$/g, '');
 pre.appendChild(code);
 messageContentDiv.appendChild(pre);
 } else {
 messageContentDiv.appendChild(document.createTextNode(part));
 }
 });
 }
 msgDiv.appendChild(messageContentDiv);

 // Add action buttons for user and AI messages
 if (sender.toLowerCase() === 'user' || sender.toLowerCase() === 'ai') {
 const actionButtonsContainer = document.createElement('div');
 actionButtonsContainer.className = 'message-action-buttons';

 // Reply button for both user and AI messages
 const replyButton = document.createElement('button');
 replyButton.className = 'message-reply-button';
 replyButton.title = 'Reply to this message';
 replyButton.innerHTML = `
 <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/>
 </svg>
 `;

 replyButton.addEventListener('click', () => {
 setAiChatReply({
 id: messageId,
 sender: sender.toLowerCase(),
 message: message,
 senderPrefix: senderPrefix
 });
 });

 actionButtonsContainer.appendChild(replyButton);

 // Read-aloud button only for AI messages
 if (sender.toLowerCase() === 'ai') {
 const readAloudButton = document.createElement('button');
 readAloudButton.className = 'message-read-aloud-button';
 readAloudButton.title = 'Read message aloud';
 readAloudButton.innerHTML = `
 <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M9 12a1 1 0 01-1-1V8a1 1 0 011-1h1l3.5-2.5A1 1 0 0115 5.5v13a1 1 0 01-1.5.9L10 17H9a1 1 0 01-1-1v-3z"/>
 </svg>
 `;

 readAloudButton.addEventListener('click', () => {
 readMessageAloud(message, messageId);
 });

 actionButtonsContainer.appendChild(readAloudButton);
 }

 msgDiv.appendChild(actionButtonsContainer);
 }

 chatHistory.appendChild(msgDiv);

 if ( (sender.toLowerCase() === 'ai' || sender.toLowerCase() === 'user') &&
 !isHtml && typeof MathJax !== 'undefined' && MathJax.typesetPromise &&
 (message.includes('$') || message.includes('\\') || message.includes('^') || message.includes('_'))) {
 MathJax.typesetPromise([messageContentDiv]).catch((err) => console.error('MathJax typesetting error:', err));
 }

 // Intelligent auto-scroll
 setTimeout(() => {
 smoothScrollToBottom(chatHistory);
 }, 50);

 // Auto-save when new chat messages are added (only when not in a room)
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom && (sender.toLowerCase() === 'user' || sender.toLowerCase() === 'ai')) {
 setTimeout(() => saveAppState(), 100);
 }

 maybeBroadcastAiChatMessage({
     messageId,
     sender,
     message,
     isHtml,
     imageData,
     replyTo,
     timestamp: messageTimestamp
 });

 return messageId;
 }

function userIsHost() {
    return currentUserId && currentRoomHostId && currentUserId === currentRoomHostId;
}

function shouldBroadcastAiChatMessage(sender) {
 return hostBroadcastState.enabled &&
 currentRoomId &&
 userIsHost() &&
 !isApplyingBroadcastedChat &&
 (sender.toLowerCase() === 'user' || sender.toLowerCase() === 'ai');
}

function maybeBroadcastAiChatMessage(payload) {
    if (!shouldBroadcastAiChatMessage(payload.sender)) {
        return;
    }

    broadcastAiChatMessage({
        message_id: payload.messageId,
        sender: payload.sender,
        message: payload.message,
        isHtml: payload.isHtml,
        imageData: payload.imageData || null,
        replyTo: payload.replyTo ? {
            id: payload.replyTo.id,
            sender: payload.replyTo.sender,
            message: payload.replyTo.message
        } : null,
        timestamp: payload.timestamp
    });
}

function broadcastAiChatMessage(messagePayload) {
    const sentViaRtc = sendHostBroadcastAiMessageWebRTC(messagePayload);
    const sentViaSocket = sendHostBroadcastAiMessage(messagePayload);

    if (!sentViaRtc && !sentViaSocket) {
        console.warn('‚ö†Ô∏è Failed to broadcast AI chat - no available transport');
    }
}

function sendHostBroadcastAiMessage(payload) {
    if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
        console.warn('‚ö†Ô∏è Cannot broadcast AI chat - not connected to collaboration server');
        return false;
    }

    try {
        collaborationSocket.send(JSON.stringify({
            type: 'host_broadcast_ai_message',
            message: payload
        }));
        return true;
    } catch (error) {
        console.error('‚ùå Failed to broadcast AI chat via WebSocket:', error);
        return false;
    }
}

function sendHostBroadcastAiMessageWebRTC(payload) {
    if (!dataChannels || dataChannels.size === 0) {
        return false;
    }

    let sent = false;
    dataChannels.forEach((channel, userId) => {
        if (channel?.readyState === 'open') {
            try {
                channel.send(JSON.stringify({
                    type: 'host_broadcast_ai_message',
                    host_id: currentUserId,
                    message: payload,
                    transport: 'webrtc'
                }));
                sent = true;
                console.log(`üì° Broadcasted AI chat via WebRTC to ${userId}`);
            } catch (error) {
                console.error(`‚ùå Failed to send AI chat via WebRTC to ${userId}:`, error);
            }
        }
    });

    return sent;
}

function shouldBroadcastPdfState(action) {
const hasPdfContext = currentPdfDoc || action === 'close';
return hostBroadcastState.enabled &&
currentRoomId &&
userIsHost() &&
!isApplyingBroadcastedPdf &&
hasPdfContext;
}

function maybeBroadcastPdfState(action, payload = {}) {
if (!shouldBroadcastPdfState(action)) {
return;
}

 const message = {
 action,
 data: {
 ...payload,
 timestamp: Date.now()
 }
 };

 if (action === 'load') {
 hostBroadcastState.pdf = payload;
 }

 sendHostBroadcastPdf(message);
 }

function sendHostBroadcastPdf(payload) {
if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
console.warn('‚ö†Ô∏è Cannot broadcast PDF - not connected to collaboration server');
return;
}

collaborationSocket.send(JSON.stringify({
type: 'host_broadcast_pdf',
data: payload
}));
}

 function handleHostBroadcastStateUpdate(data) {
 hostBroadcastState.enabled = !!data.enabled;
 hostBroadcastState.hostId = data.host_id || hostBroadcastState.hostId;
 if (!hostBroadcastState.enabled) {
 hostBroadcastState.pdf = null;
 }

 updateHostBroadcastUi();

 if (hostBroadcastState.enabled && data.pdf && currentUserId !== data.host_id) {
 loadPdfFromBroadcastData(data.pdf);
 }
 }

function handleIncomingBroadcastAiMessage(data) {
    if (!data || !data.message) {
        return;
    }

    if (data.host_id === currentUserId) {
        return;
    }

    const incomingMessageId = data.message.message_id || data.message.messageId || data.message.id;
    if (incomingMessageId) {
        if (receivedBroadcastAiMessageIds.has(incomingMessageId)) {
            console.log('‚è≠Ô∏è Duplicate broadcast AI message ignored:', incomingMessageId);
            return;
        }

        receivedBroadcastAiMessageIds.add(incomingMessageId);

        // Keep the dedup set from growing indefinitely
        if (receivedBroadcastAiMessageIds.size > 200) {
            const oldest = receivedBroadcastAiMessageIds.values().next().value;
            receivedBroadcastAiMessageIds.delete(oldest);
        }
    }

    isApplyingBroadcastedChat = true;
    addChatMessage(
        data.message.sender,
        data.message.message,
 data.message.isHtml,
 data.message.imageData || null,
 data.message.replyTo || null
 );
 isApplyingBroadcastedChat = false;
 }

 function handleIncomingBroadcastPdf(data) {
 if (!data) {
 return;
 }

 if (data.host_id === currentUserId) {
 return;
 }

 const action = data.action;
 const payload = data.data || {};

 switch (action) {
 case 'load':
 hostBroadcastState.pdf = payload;
 loadPdfFromBroadcastData(payload).catch(error => {
 console.error('‚ùå Broadcast PDF load failed:', error);
 });
 break;
 case 'page_change':
 if (!payload.current_page || !currentPdfDoc) {
 return;
 }
 isApplyingBroadcastedPdf = true;
 navigateToPage(payload.current_page);
 isApplyingBroadcastedPdf = false;
 break;
 case 'close':
 if (currentPdfDoc) {
 isApplyingBroadcastedPdf = true;
 closePdf();
 isApplyingBroadcastedPdf = false;
 }
 hostBroadcastState.pdf = null;
 break;
 default:
 console.warn('Unknown broadcast PDF action:', action);
 }
 }

 // Reply functionality for AI Chat
 let currentAiChatReply = null;

 function setAiChatReply(messageData) {
 currentAiChatReply = messageData;
 const replyContainer = document.getElementById('ai-chat-reply-container');
 const replyPreview = document.getElementById('ai-chat-reply-preview');

 if (replyContainer && replyPreview) {
 const senderName = messageData.sender === 'user' ? 'You' : 'AI';
 const cleanMessage = messageData.message.replace(/<[^>]*>/g, '').substring(0, 100);
 const displayMessage = cleanMessage + (messageData.message.length > 100 ? '...' : '');

 replyPreview.textContent = `${senderName}: ${displayMessage}`;
 replyContainer.classList.remove('hidden');

 // Focus on the chat input
 const chatInput = document.getElementById('chat-input');
 if (chatInput) chatInput.focus();
 }
 }

 function clearAiChatReply() {
 currentAiChatReply = null;
 const replyContainer = document.getElementById('ai-chat-reply-container');
 if (replyContainer) {
 replyContainer.classList.add('hidden');
 }
 }

 // Event listeners for AI chat reply
 document.getElementById('ai-chat-reply-close').addEventListener('click', clearAiChatReply);

 // Reply functionality for Group Messages
 let currentGroupReply = null;

 function setGroupReply(messageData) {
 currentGroupReply = messageData;
 const replyContainer = document.getElementById('group-reply-container');
 const replyPreview = document.getElementById('group-reply-preview');

 if (replyContainer && replyPreview) {
 const cleanMessage = messageData.content.replace(/<[^>]*>/g, '').substring(0, 100);
 const displayMessage = cleanMessage + (messageData.content.length > 100 ? '...' : '');

 replyPreview.textContent = `${messageData.sender_name}: ${displayMessage}`;
 replyContainer.classList.remove('hidden');

 // Focus on the group message input
 const groupInput = document.getElementById('group-message-input');
 if (groupInput) groupInput.focus();
 }
 }

 function clearGroupReply() {
 currentGroupReply = null;
 const replyContainer = document.getElementById('group-reply-container');
 if (replyContainer) {
 replyContainer.classList.add('hidden');
 }
 }

 // Edit message functionality
 function editGroupMessage(messageId, messageData) {
 // Security check: Only allow editing own messages
 if (messageData.sender_name !== currentDisplayName) {
 console.warn('Unauthorized edit attempt blocked');
 return;
 }

 const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
 if (!messageElement) return;

 const messageContent = messageElement.querySelector('.message-content');
 if (!messageContent) return;

 // Store original content
 const originalContent = messageData.content;

 // Create edit input
 const editInput = document.createElement('textarea');
 editInput.className = 'w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 resize-none';
 editInput.value = originalContent;
 editInput.rows = 3;

 // Create edit controls
 const editControls = document.createElement('div');
 editControls.className = 'flex justify-end space-x-2 mt-2';

 const cancelBtn = document.createElement('button');
 cancelBtn.className = 'px-3 py-1 text-sm bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 rounded hover:bg-slate-300 dark:hover:bg-slate-600';
 cancelBtn.textContent = 'Cancel';

 const saveBtn = document.createElement('button');
 saveBtn.className = 'px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600';
 saveBtn.textContent = 'Save';

 editControls.appendChild(cancelBtn);
 editControls.appendChild(saveBtn);

 // Replace content with edit interface
 const originalHTML = messageContent.innerHTML;
 messageContent.innerHTML = '';
 messageContent.appendChild(editInput);
 messageContent.appendChild(editControls);

 editInput.focus();
 editInput.select();

 // Cancel edit
 cancelBtn.addEventListener('click', () => {
 messageContent.innerHTML = originalHTML;
 });

 // Save edit
 saveBtn.addEventListener('click', () => {
 const newContent = editInput.value.trim();
 if (newContent && newContent !== originalContent) {
 // Send edit to server
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 groupMessageSocket.send(JSON.stringify({
 type: 'edit_message',
 message_id: messageId,
 new_content: newContent,
 room_id: currentGroupRoomId
 }));
 }
 }
 // Restore original content temporarily (will be updated when server confirms)
 messageContent.innerHTML = originalHTML;
 });

 // Save on Enter, cancel on Escape
 editInput.addEventListener('keydown', (e) => {
 if (e.key === 'Enter' && !e.shiftKey) {
 e.preventDefault();
 saveBtn.click();
 } else if (e.key === 'Escape') {
 cancelBtn.click();
 }
 });
 }

 // Delete message functionality
 function deleteGroupMessage(messageId, messageData) {
 // Security check: Only allow deleting own messages
 if (messageData.sender_name !== currentDisplayName) {
 console.warn('Unauthorized delete attempt blocked');
 return;
 }

 if (confirm('Are you sure you want to delete this message?')) {
 // Send delete to server
 if (groupMessageSocket && groupMessageSocket.readyState === WebSocket.OPEN) {
 groupMessageSocket.send(JSON.stringify({
 type: 'delete_message',
 message_id: messageId,
 room_id: currentGroupRoomId
 }));
 }
 }
 }

 // Event listeners for group reply
 document.getElementById('group-reply-close').addEventListener('click', clearGroupReply);

 // Message navigation and highlighting
 function scrollToMessage(messageId) {
 // Try to find the message in group messages first (most common case)
 let messageElement = document.querySelector(`#group-messages [data-message-id="${messageId}"]`);
 let container = document.getElementById('group-messages');

 // If not found in group messages, try AI chat
 if (!messageElement) {
 messageElement = document.querySelector(`#chat-history [data-message-id="${messageId}"]`);
 container = document.getElementById('chat-history');
 }

 // If still not found, try a broader search
 if (!messageElement) {
 messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
 }

 if (messageElement) {
 // Scroll to the message
 messageElement.scrollIntoView({
 behavior: 'smooth',
 block: 'center'
 });

 // Highlight the message temporarily
 highlightMessage(messageElement);

 // Switch to the correct tab if needed
 if (container && container.id === 'group-messages') {
 // Switch to collaboration tab
 const collabTab = document.querySelector('[data-tab="collaboration"]');
 if (collabTab) collabTab.click();
 } else if (container && container.id === 'chat-history') {
 // Switch to AI chat tab
 const aiTab = document.querySelector('[data-tab="ai-chat"]');
 if (aiTab) aiTab.click();
 }
 }
 }

 function highlightMessage(messageElement) {
 // Remove any existing highlights
 document.querySelectorAll('.message-highlighted').forEach(el => {
 el.classList.remove('message-highlighted');
 });

 // Add highlight class
 messageElement.classList.add('message-highlighted');

 // Remove highlight after 2 seconds with smooth transition
 setTimeout(() => {
 messageElement.classList.remove('message-highlighted');
 }, 2000);
 }

 sendButton.addEventListener('click', sendUserMessage);
 chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendUserMessage(); }});

 // PDF Viewer AI Event Listeners
 if (pdfSendToAiBtn) {
 pdfSendToAiBtn.addEventListener('click', sendPdfPageToAI);
 }

 if (pdfVoiceAiBtn) {
 pdfVoiceAiBtn.addEventListener('click', () => {
 // Start voice AI with PDF context
 if (voiceAssistant) {
 voiceAssistant.startListening(true); // true indicates PDF context
 } else {
 addChatMessage('System', '‚ùå Voice assistant not available');
 }
 });
 }

// Add event listener for the new "Send to AI" button in chat interface
const sendToAiChatButton = document.getElementById('send-to-ai-chat-button');
sendToAiChatButton.addEventListener('click', () => {
    // Use the same functionality as the toolbar "Ask AI" button
    console.log('üé® Starting canvas capture for AI from chat interface...');

    const originalBackgroundColor = fabricCanvas.backgroundColor;
    // Ensure a non-transparent background for the screenshot
    if (fabricCanvas.backgroundColor === 'transparent' || !fabricCanvas.backgroundColor) {
        fabricCanvas.backgroundColor = document.documentElement.classList.contains('dark') ? '#0f172a' : '#FFFFFF';
    }
    fabricCanvas.renderAll(); // Render with temporary background if changed
    const dataURL = fabricCanvas.toDataURL({ format: 'png', quality: 0.9 });

    console.log('üì∏ Canvas captured, data URL length:', dataURL.length);
    console.log('üì∏ Data URL preview:', dataURL.substring(0, 100) + '...');

    // Restore original background if it was temporarily changed
    if (originalBackgroundColor !== fabricCanvas.backgroundColor) {
        fabricCanvas.backgroundColor = originalBackgroundColor;
        fabricCanvas.renderAll();
    }

    // Store the image for sending to AI
    pendingImageForChat = dataURL;
    pendingImageMetadata = { type: 'canvas' };
    console.log('üíæ Image stored for AI chat');

    // Add the image to chat history
    addChatMessage('User', '[üì∏ Canvas screenshot captured]', false, dataURL);

    // Focus on the chat input for the user to type their question
    chatInput.focus();
});



 function sendUserMessage() {
 const message = chatInput.value.trim();
 if (!message && !pendingImageForChat && !aiChatAttachedImage) {
 // Just return silently - no need for noisy system message
 return;
 }

 let messageForAI = message;
 let imageToSend = null;

 // Handle canvas screenshot (from Ask AI button)
 if (pendingImageForChat) {
   if (!message) {
     if (pendingImageMetadata?.type === 'pdf') {
       const pageLabel = pendingImageMetadata.page ? ` ${pendingImageMetadata.page}` : '';
       messageForAI = `Analyze the attached PDF page${pageLabel} and explain its contents in detail. Break down any code, diagrams, or math that appears and answer the user's request.`;
     } else {
       messageForAI = "Analyze this image and solve any mathematical problems shown STEP BY STEP with actual calculations. Show your work clearly with numbered steps and provide the final numerical answer. Use LaTeX formatting for math.";
     }
   }
   // User message with image is already added by askAiCanvasButton
   if (message) addChatMessage('User', message, false, null, currentAiChatReply);
   imageToSend = pendingImageForChat;
 }
 // Handle pasted image (from AI chat input)
 else if (aiChatAttachedImage) {
 if (!message) messageForAI = "Analyze this image and describe what you see. Use LaTeX formatting for any math.";
 // Add user message with image preview
 const displayMessage = message || "What's in this image?";
 addChatMessage('User', displayMessage, false, aiChatAttachedImage, currentAiChatReply);
 imageToSend = aiChatAttachedImage;
 }
 // Handle text-only message
 else {
 if (message) addChatMessage('User', message, false, null, currentAiChatReply);
 }

 // Add reply context to AI prompt if replying
 if (currentAiChatReply) {
 const replyContext = `[Replying to ${currentAiChatReply.sender === 'user' ? 'user' : 'AI'} message: "${currentAiChatReply.message.replace(/<[^>]*>/g, '').substring(0, 200)}"] `;
 messageForAI = replyContext + messageForAI;
 }

 let promptToBackend = messageForAI;
 if (!promptToBackend.toLowerCase().includes("latex")) {
 promptToBackend += " (Format ALL math, symbols, and equations using LaTeX: $inline$ or $$display$$)";
 }

 // Clear inputs and attached images
 chatInput.value = '';
 pendingImageForChat = null;
 pendingImageMetadata = null;
 hideAiChatImagePreview(); // Clear the pasted image preview
 clearAiChatReply(); // Clear reply context

 // Send to AI with the stored image
 sendToGemini(imageToSend, promptToBackend);
 }

// Use current domain for API calls
const GEMINI_BACKEND_URL = window.location.origin;

// Generous timeouts so slow connections (mobile hotspots, rural Wi-Fi, etc.) can finish their work
const AI_REQUEST_TIMEOUT_MS = 180000; // 3 minutes for regular chat requests
const VOICE_AI_REQUEST_TIMEOUT_MS = 240000; // 4 minutes for voice assistant round trips
const VOICE_AI_SLOW_NETWORK_WARNING_MS = 15000; // Warn the user if a voice request drags past 15s

function fetchWithTimeout(url, options = {}, timeout = AI_REQUEST_TIMEOUT_MS) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error(`Request timed out after ${Math.round(timeout / 1000)} seconds`));
        }, timeout);

        fetch(url, options)
            .then((response) => {
                clearTimeout(timer);
                resolve(response);
            })
            .catch((error) => {
                clearTimeout(timer);
                reject(error);
            });
    });
}

// Network diagnostic function for mobile hotspot troubleshooting
async function runNetworkDiagnostic() {
    try {
        addChatMessage('System', 'üîç Running network diagnostic...');

        const response = await fetch(`${GEMINI_BACKEND_URL}/api/network-diagnostic`);
        const diagnostic = await response.json();

        let diagnosticMessage = 'üìä Network Diagnostic Results:\n';
        diagnosticMessage += `‚Ä¢ Internet connectivity: ${diagnostic.internet_connectivity ? '‚úÖ' : '‚ùå'}\n`;
        diagnosticMessage += `‚Ä¢ Google API accessible: ${diagnostic.google_api_accessible ? '‚úÖ' : '‚ùå'}\n`;
        diagnosticMessage += `‚Ä¢ DNS resolution: ${diagnostic.dns_resolution ? '‚úÖ' : '‚ùå'}\n`;

        if (diagnostic.recommendations && diagnostic.recommendations.length > 0) {
            diagnosticMessage += '\nüí° Recommendations:\n';
            diagnostic.recommendations.forEach((rec, index) => {
                diagnosticMessage += `${index + 1}. ${rec}\n`;
            });
        }

        addChatMessage('System', diagnosticMessage);

    } catch (error) {
        console.error('Network diagnostic failed:', error);
        addChatMessage('System', '‚ùå Network diagnostic failed. This confirms connectivity issues.');
    }
}
// Replace your existing sendToGemini function with this modified version
async function sendToGemini(imageDataURL, promptText) {
    const now = Date.now();
    if (now - lastAiRequestAt < 2500) {
        addChatMessage('System', '‚è≥ Please wait a couple seconds before sending another AI request.');
        return;
    }

    // Quick online check to prevent wasteful calls when offline
    if (!navigator.onLine) {
        addChatMessage('AI', 'You appear to be offline. Check your connection and try again.');
        return;
    }

    lastAiRequestAt = now;

    showTypingIndicator();
    try {
        // Check message limit before sending
        if (window.aiSettings && !window.aiSettings.incrementMessageCount()) {
            hideTypingIndicator();
            return; // Message limit reached, modal will be shown
        }

        // Get recent chat history for context (last 15 messages for better context)
        const chatContext = getChatHistory(15);

        // Enhanced prompt for better math problem solving
        let effectivePrompt = promptText || "Analyze the provided content. Format all math using LaTeX.";

        // Add math-specific instructions if the prompt contains mathematical content
        const hasMathContent = /[+\-*/=‚à´‚àë‚àö^_{}()[\]\\]|integral|derivative|equation|solve|calculate|compute|find|answer/.test(effectivePrompt.toLowerCase());

        if (hasMathContent) {
            const mathInstructions = `

IMPORTANT MATH SOLVING INSTRUCTIONS:
- If this is a math problem, SOLVE IT STEP BY STEP with actual calculations
- Show your work clearly with numbered steps
- Provide the final numerical answer
- Use LaTeX formatting: $inline$ for inline math, $$display$$ for equations
- Don't just explain concepts - actually compute the solution
- For integrals, derivatives, equations: show the complete solution process
- For word problems: set up equations and solve them numerically

`;
            effectivePrompt = mathInstructions + effectivePrompt;
        }

        // Add chat history as context if available and not empty
        if (chatContext && chatContext.trim().length > 0) {
            effectivePrompt = `Previous conversation context:\n${chatContext}\n\nCurrent message: ${effectivePrompt}`;
            console.log('üìö Adding conversation context:', chatContext.length, 'characters');
        } else {
            console.log('üìù No previous context available');
        }

        const payload = {
            message: effectivePrompt
        };

        // Add custom API key and model if available
        if (window.aiSettings) {
            const customApiKey = window.aiSettings.getApiKey();
            const selectedModel = window.aiSettings.getSelectedModel();

            if (customApiKey) {
                payload.customApiKey = customApiKey;
                console.log('üîë Using custom API key');
            }

            payload.model = selectedModel;
            console.log('ü§ñ Using model:', selectedModel);
        }

        if (imageDataURL) {
            console.log('Sending image with prompt to AI...');
            const parts = imageDataURL.split(',');
            if (parts.length === 2) {
                payload.image_data = parts[1];
                console.log('Image data prepared, size:', parts[1].length, 'characters');
            } else {
                console.error("Invalid Data URL format:", imageDataURL);
                addChatMessage('AI', 'Error: Could not properly prepare image data for AI.');
                return;
            }
        } else {
            console.log('Sending text-only prompt to AI...');
        }

        console.log('üåê Sending request to:', `${GEMINI_BACKEND_URL}/api/chat`);

        const response = await fetchWithTimeout(`${GEMINI_BACKEND_URL}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        }, AI_REQUEST_TIMEOUT_MS);

        // Hide typing indicator
        hideTypingIndicator();

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        addChatMessage('AI', data.response || "No response from AI.");

    } catch (error) {
        hideTypingIndicator();
        console.error('Error interacting with Gemini:', error);

        // Check for mobile hotspot specific issues and provide helpful guidance
        const errorMessage = error.message || '';
        if (errorMessage.includes('DNS resolution failed') ||
            errorMessage.includes('generativelanguage.googleapis.com') ||
            errorMessage.includes('Timeout') ||
            errorMessage.includes('503') ||
            errorMessage.includes('502')) {

            // Show mobile hotspot specific error message
            addChatMessage('AI', `üîß Network connectivity issue detected. This commonly happens with mobile hotspots.`);
            addChatMessage('System', `üí° Try these solutions:\n1. Move closer to your phone\n2. Switch to WiFi if available\n3. Use a VPN\n4. Change DNS settings to 8.8.8.8\n5. Restart your mobile hotspot`);

            // Run network diagnostic
            runNetworkDiagnostic();
        } else if (errorMessage.toLowerCase().includes('limit') ||
                   errorMessage.toLowerCase().includes('quota') ||
                   errorMessage.includes('429')) {
            addChatMessage('AI', '‚ö†Ô∏è The AI service reported a limit/quota issue. Wait a bit, reduce attachment size, or add your own API key in AI Settings.');
        } else {
            addChatMessage('AI', `Sorry, an error occurred: ${errorMessage}`);
        }
    }
}

// Add this new function to extract chat history
function getChatHistory(maxMessages = 15) {
    const messages = [];

    // Use persistent storage for better context preservation
    const recentMessages = chatHistoryStorage
        .slice(-maxMessages) // Get last maxMessages
        .filter(msg => msg.sender === 'user' || msg.sender === 'ai'); // Only user and AI messages

    recentMessages.forEach(msg => {
        if (msg.sender === 'user') {
            // Clean up the message text (remove HTML if present)
            const cleanMessage = msg.message.replace(/<[^>]*>/g, '').trim();
            if (cleanMessage && !cleanMessage.includes('Canvas captured')) {
                messages.push(`Human: ${cleanMessage}`);
            }
        } else if (msg.sender === 'ai') {
            // Clean up the message text (remove HTML if present)
            const cleanMessage = msg.message.replace(/<[^>]*>/g, '').trim();
            if (cleanMessage && !cleanMessage.includes('Canvas captured')) {
                messages.push(`Assistant: ${cleanMessage}`);
            }
        }
    });

    // Keep chat history storage from growing too large (max 100 messages)
    if (chatHistoryStorage.length > 100) {
        chatHistoryStorage = chatHistoryStorage.slice(-100);
    }

    return messages.join('\n');
}

// Debug function to test chat history
function debugChatHistory() {
    console.log('=== Chat History Debug ===');
    console.log('Storage length:', chatHistoryStorage.length);
    console.log('Recent messages:', getChatHistory(5));
    console.log('Full storage:', chatHistoryStorage);
    addChatMessage('AI', `Debug: ${chatHistoryStorage.length} messages in history. Recent context: ${getChatHistory(5).length} characters.`);
}

// Add debug shortcut (Ctrl+Shift+H)
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'H') {
        e.preventDefault();
        debugChatHistory();
    }
});

 // Python execution removed - not supported in current backend

 // --- Comprehensive State Management ---
 function saveAppState() {
 // Only save comprehensive state when NOT in a collaboration room
 const isInRoom = currentRoomId && isConnected;

 const appState = {
 // Room session data
 roomSession: currentRoomId ? {
 roomId: currentRoomId,
 userId: currentUserId,
 userName: localStorage.getItem('userName') || 'Anonymous',
 timestamp: Date.now()
 } : null,

 // Canvas state (only save when not in room)
 canvasState: fabricCanvas && !isInRoom ? {
 objects: fabricCanvas.getObjects().map(obj => obj.toObject()),
 background: fabricCanvas.backgroundColor,
 zoom: fabricCanvas.getZoom(),
 viewportTransform: fabricCanvas.viewportTransform,
 width: fabricCanvas.width,
 height: fabricCanvas.height
 } : null,

 // AI Chat History (only save when not in room)
 aiChatHistory: !isInRoom ? chatHistoryStorage.map(msg => ({
 ...msg,
 imageData: msg.imageData ? msg.imageData : null
 })) : null,

 // Jupyter Notebook (always save when available)
 jupyterNotebook: cells.length > 0 ? {
 cells: cells.map(cell => ({
 id: cell.id,
 type: 'code',
 code: cell.codeInput ? cell.codeInput.value : '',
 output: cell.outputContent ? cell.outputContent.innerHTML : ''
 })),
 cellCounter: cellCounter
 } : null,

 // PDF Data (always save when available)
 pdfData: currentPdfData ? {
 name: currentPdfName,
 data: currentPdfData,
 currentPage: currentPdfPage,
 totalPages: totalPdfPages,
 zoom: pdfZoomLevel
 } : null,

 // Datasets (always save when available)
 datasets: Array.from(importedDatasets.entries()).map(([varName, dataset]) => ({
 varName: varName,
 filename: dataset.filename,
 variable: dataset.variable,
 info: dataset.info
 })),

 // UI state
 uiState: {
 darkMode: document.documentElement.classList.contains('dark'),
 toolbarCollapsed: localStorage.getItem('toolbarCollapsed') === 'true',
 aiSidebarVisible: localStorage.getItem('aiSidebarVisible') !== 'false',
 aiSidebarWidth: localStorage.getItem('aiSidebarWidth') || '384',
 notificationsEnabled: localStorage.getItem('groupNotificationsEnabled') !== 'false',
 activeTab: activeTab
 },

 // Voice settings
 voiceSettings: JSON.parse(localStorage.getItem('voiceAssistantSettings') || '{}'),

 timestamp: Date.now(),
 isInRoom: isInRoom
 };

 try {
 localStorage.setItem('appState', JSON.stringify(appState));
 // Auto-save indicator removed per user request
 } catch (error) {
 if (error.name === 'QuotaExceededError') {
 console.warn('‚ö†Ô∏è localStorage quota exceeded. Clearing old data and retrying...');

 // Clear old app state and try to save a minimal version
 localStorage.removeItem('appState');

 // Save only essential data without large objects
 const minimalState = {
 roomSession: appState.roomSession,
 uiState: appState.uiState,
 voiceSettings: appState.voiceSettings,
 timestamp: Date.now(),
 isInRoom: appState.isInRoom
 };

 try {
 localStorage.setItem('appState', JSON.stringify(minimalState));
 console.log('‚úÖ Saved minimal app state after quota exceeded');
 } catch (retryError) {
 console.error('‚ùå Failed to save even minimal state:', retryError);
 }
 } else {
 console.error('‚ùå Error saving app state:', error);
 }
 }
 }

 function loadAppState() {
 try {
 const appStateData = localStorage.getItem('appState');
 if (appStateData) {
 const appState = JSON.parse(appStateData);
 // Check if state is not too old (24 hours)
 const maxAge = 24 * 60 * 60 * 1000;
 if (Date.now() - appState.timestamp < maxAge) {
 console.log('üìÇ App state loaded:', appState);
 return appState;
 } else {
 console.log('‚è∞ App state expired, clearing');
 clearAppState();
 }
 }
 } catch (error) {
 console.error('‚ùå Error loading app state:', error);
 clearAppState();
 }
 return null;
 }

 function clearAppState() {
 localStorage.removeItem('appState');
 console.log('üóëÔ∏è App state cleared');
 }

 function restoreAppState() {
 console.log('üîÑ Restoring app state...');
 const appState = loadAppState();

 if (!appState) {
 console.log('‚ùå No app state to restore');
 return;
 }

 console.log('üìã App state found:', {
 hasCanvasState: !!appState.canvasState,
 hasChatHistory: !!appState.aiChatHistory,
 hasJupyterNotebook: !!appState.jupyterNotebook,
 hasPdfData: !!appState.pdfData,
 hasDatasets: !!appState.datasets,
 isInRoom: appState.isInRoom,
 timestamp: appState.timestamp
 });

 // Restore UI state
 if (appState.uiState) {
 const ui = appState.uiState;

 // Dark mode
 if (ui.darkMode !== undefined) {
 const isDarkMode = document.documentElement.classList.contains('dark');
 if (ui.darkMode !== isDarkMode) {
 if (ui.darkMode) {
 document.documentElement.classList.add('dark');
 } else {
 document.documentElement.classList.remove('dark');
 }
 // Skip canvas background update - preserve user's chosen pattern
 fabricCanvas.renderAll();
 }
 }

 // Toolbar state
 if (ui.toolbarCollapsed !== undefined) {
 isToolbarContentCollapsed = ui.toolbarCollapsed;
 updateToolbarView();
 }

 // AI sidebar
 if (ui.aiSidebarVisible !== undefined && !ui.aiSidebarVisible) {
 isChatSidebarVisible = true;
 toggleAISidebar();
 }

 if (ui.aiSidebarWidth) {
 aiChatSidebar.style.width = ui.aiSidebarWidth + 'px';
 }

 // Active tab
 if (ui.activeTab) {
 console.log('üîÑ Switching to active tab:', ui.activeTab);
 if (typeof switchTab === 'function') {
 switchTab(ui.activeTab);
 } else {
 console.warn('‚ö†Ô∏è switchTab function not available');
 }
 }

 // Notifications
 if (ui.notificationsEnabled !== undefined) {
 notificationsEnabled = ui.notificationsEnabled;
 // Note: updateMuteButtonState function not available in this context
 }
 }

 // Check if we're in a room for canvas and chat restoration
 const isInRoom = currentRoomId && isConnected;

 if (appState.canvasState || appState.aiChatHistory || appState.jupyterNotebook || appState.pdfData) {
 showRestoreIndicator();
 }

 // Restore canvas state (only when not in a room)
 if (appState.canvasState && !isInRoom) {
 console.log('üé® Restoring canvas state...');
 const canvasState = appState.canvasState;

 // Set background
 if (canvasState.background) {
 fabricCanvas.backgroundColor = canvasState.background;
 }

 // Set canvas dimensions
 if (canvasState.width && canvasState.height) {
 fabricCanvas.setDimensions({
 width: canvasState.width,
 height: canvasState.height
 });

 // Reapply pattern after canvas dimensions change
 setTimeout(() => {
 if (currentCanvasPattern) {
 console.log('üîÑ Reapplying pattern after canvas dimensions restore');
 reapplyCanvasPatternOnResize();
 }
 }, 100);
 }

 // Restore objects
 if (canvasState.objects && canvasState.objects.length > 0) {
 fabricCanvas.clear();
 fabricCanvas.backgroundColor = canvasState.background || '#ffffff';

 canvasState.objects.forEach(objData => {
 fabric.util.enlivenObjects([objData], (objects) => {
 objects.forEach(obj => {
 fabricCanvas.add(obj);
 });
 fabricCanvas.renderAll();
 });
 });
 }

 // Restore zoom and viewport
 if (canvasState.zoom) {
 fabricCanvas.setZoom(canvasState.zoom);
 }
 if (canvasState.viewportTransform) {
 fabricCanvas.setViewportTransform(canvasState.viewportTransform);
 }

 console.log('‚úÖ Canvas state restored:', canvasState.objects?.length || 0, 'objects');
 }

 // Restore AI Chat History (only when not in a room)
 if (appState.aiChatHistory && !isInRoom) {
 console.log('üí¨ Restoring AI chat history...');
 try {
 chatHistoryStorage = appState.aiChatHistory;
 const chatHistory = document.getElementById('chat-history');
 if (chatHistory) {
 chatHistory.innerHTML = '';
 appState.aiChatHistory.forEach((msg, index) => {
 try {
 restoreChatMessage(msg.sender, msg.message, false, msg.imageData, msg.replyTo, msg.id);
 } catch (error) {
 console.error('Error restoring chat message:', error, msg);
 }
 });
 console.log('‚úÖ AI chat history restored:', appState.aiChatHistory.length, 'messages');

 // Re-process MathJax for all restored chat content
 setTimeout(() => {
 reprocessMathJax(chatHistory);
 }, 100); // Small delay to ensure DOM is updated
 } else {
 console.warn('‚ö†Ô∏è chat-history element not found');
 }
 } catch (error) {
 console.error('‚ùå Error restoring AI chat history:', error);
 }
 }

 // Restore Jupyter Notebook (always restore when available)
 if (appState.jupyterNotebook) {
 console.log('üìì Restoring Jupyter notebook...', {
 cellCount: appState.jupyterNotebook.cells?.length,
 cellCounter: appState.jupyterNotebook.cellCounter,
 hasCells: !!appState.jupyterNotebook.cells
 });

 // Function to restore Jupyter cells
 function restoreJupyterCells() {
 try {
 // Check if required functions exist
 if (typeof clearAllCells === 'function') {
 console.log('üîÑ Clearing existing cells...');
 clearAllCells();
 } else {
 console.warn('‚ö†Ô∏è clearAllCells function not available');
 }

 cellCounter = appState.jupyterNotebook.cellCounter || 0;
 console.log('üîÑ Set cellCounter to:', cellCounter);

 if (appState.jupyterNotebook.cells && appState.jupyterNotebook.cells.length > 0) {
 appState.jupyterNotebook.cells.forEach((cellData, index) => {
 try {
 console.log(`üîÑ Restoring cell ${index + 1}:`, {
 hasCode: !!cellData.code,
 codeLength: cellData.code?.length,
 hasOutput: !!cellData.output
 });

 if (typeof createCell === 'function') {
 const cell = createCell(cellData.code || '');
 if (cell.outputContent && cellData.output) {
 cell.outputContent.innerHTML = cellData.output;
 cell.output.classList.remove('hidden');
 }
 const cellsContainer = document.getElementById('cells-container');
 if (cellsContainer) {
 cellsContainer.appendChild(cell);
 console.log(`‚úÖ Cell ${index + 1} restored successfully`);
 } else {
 console.warn('‚ö†Ô∏è cells-container element not found');
 }
 } else {
 console.error('‚ùå createCell function not available');
 }
 } catch (cellError) {
 console.error('‚ùå Error restoring cell:', cellError, cellData);
 }
 });
 console.log('‚úÖ Jupyter notebook restored:', appState.jupyterNotebook.cells.length, 'cells');

 // Don't automatically switch to Jupyter tab after restoration
 } else {
 console.log('üìì No cells to restore');
 }
 } catch (error) {
 console.error('‚ùå Error restoring Jupyter notebook:', error);
 }
 }

 // Restore cells without switching tabs
 restoreJupyterCells();
 } else {
 console.log('üìì Jupyter notebook restoration skipped:', {
 hasJupyterNotebook: !!appState.jupyterNotebook
 });
 }

 // Restore PDF (always restore when available)
 if (appState.pdfData) {
 console.log('üìÑ Restoring PDF...', {
 hasData: !!appState.pdfData.data,
 name: appState.pdfData.name,
 currentPage: appState.pdfData.currentPage,
 totalPages: appState.pdfData.totalPages,
 dataLength: appState.pdfData.data?.length
 });
 try {
 // Ensure PDF viewer tab is active to initialize DOM elements
 if (typeof switchTab === 'function') {
 switchTab('pdf-viewer');
 console.log('üîÑ Switched to PDF viewer tab for restoration');
 }
 currentPdfData = appState.pdfData.data;
 currentPdfName = appState.pdfData.name;
 currentPdfPage = appState.pdfData.currentPage || 1;
 totalPdfPages = appState.pdfData.totalPages || 1;
 if (appState.pdfData.zoom) {
 pdfZoomLevel = appState.pdfData.zoom;
 }

 // Decode base64 PDF data
 console.log('üîÑ Decoding PDF data...');
 const binaryString = atob(currentPdfData);
 const uint8Array = new Uint8Array(binaryString.length);
 for (let i = 0; i < binaryString.length; i++) {
 uint8Array[i] = binaryString.charCodeAt(i);
 }
 console.log('‚úÖ PDF data decoded, size:', uint8Array.length);

 // Check if loadPdfFromData function exists
 if (typeof loadPdfFromData === 'function') {
 // Load the PDF with a delay to ensure DOM is ready
 setTimeout(() => {
 console.log('üîÑ Loading PDF from data...');
 loadPdfFromData(uint8Array, currentPdfName).then(() => {
 console.log('‚úÖ PDF loaded successfully, switching to PDF viewer');
 // Ensure we're on the PDF viewer tab after loading
 setTimeout(() => {
 if (typeof switchTab === 'function') {
 switchTab('pdf-viewer');
 }
 }, 500);
 }).catch((error) => {
 console.error('‚ùå Error loading PDF:', error);
 });
 }, 1000); // Increased delay
 } else {
 console.error('‚ùå loadPdfFromData function not available');
 }

 console.log('‚úÖ PDF restoration initiated:', currentPdfName);
 } catch (pdfError) {
 console.error('‚ùå Error restoring PDF:', pdfError);
 }
 } else {
 console.log('üìÑ PDF restoration skipped:', {
 hasPdfData: !!appState.pdfData
 });
 }

 // Restore datasets (always restore when available)
 if (appState.datasets && appState.datasets.length > 0) {
 console.log('üìä Restoring datasets...');
 try {
 if (typeof importedDatasets !== 'undefined') {
 importedDatasets.clear();
 appState.datasets.forEach(dataset => {
 importedDatasets.set(dataset.varName, {
 filename: dataset.filename,
 variable: dataset.variable,
 info: dataset.info
 });
 });
 if (typeof updateDatasetList === 'function') {
 updateDatasetList();
 }
 if (typeof updateDatasetButton === 'function') {
 updateDatasetButton();
 }
 console.log('‚úÖ Datasets restored:', appState.datasets.length);
 } else {
 console.warn('‚ö†Ô∏è importedDatasets not available');
 }
 } catch (error) {
 console.error('‚ùå Error restoring datasets:', error);
 }
 }

 // After all restoration is complete, switch to the appropriate tab
 setTimeout(() => {
 if (appState.pdfData) {
 console.log('üîÑ Switching to PDF viewer tab after restoration');
 if (typeof switchTab === 'function') {
 switchTab('pdf-viewer');
 }
 } else if (appState.uiState?.activeTab && appState.uiState.activeTab !== 'jupyter') {
 console.log('üîÑ Switching to saved active tab:', appState.uiState.activeTab);
 if (typeof switchTab === 'function') {
 switchTab(appState.uiState.activeTab);
 }
 } else {
 // Default to AI chat tab
 console.log('üîÑ Defaulting to AI chat tab');
 if (typeof switchTab === 'function') {
 switchTab('ai-chat');
 }
 }
 }, 2000); // Wait for all restoration to complete

 console.log('‚úÖ App state restored successfully');
 }

 // Test function for auto-save functionality
 window.testAutoSave = function() {
 console.log('üß™ Testing auto-save functionality...');

 // Check if we're in a room
 const isInRoom = currentRoomId && isConnected;
 console.log('üìç Current status:', {
 isInRoom: isInRoom,
 currentRoomId: currentRoomId,
 isConnected: isConnected
 });

 if (isInRoom) {
 console.log('‚ö†Ô∏è Auto-save is disabled while in a collaboration room');
 return;
 }

 // Check current state before saving
 console.log('üìä Current application state:', {
 canvasObjects: fabricCanvas?.getObjects()?.length || 0,
 chatMessages: chatHistoryStorage?.length || 0,
 jupyterCells: cells?.length || 0,
 currentPdfName: currentPdfName,
 currentPdfData: currentPdfData ? 'Present' : 'None',
 datasets: importedDatasets?.size || 0
 });

 // Trigger a manual save
 saveAppState();

 // Check what was saved
 const saved = loadAppState();
 console.log('üíæ Saved data detailed:', {
 hasCanvasState: !!saved?.canvasState,
 canvasObjectCount: saved?.canvasState?.objects?.length || 0,
 hasChatHistory: !!saved?.aiChatHistory,
 chatMessageCount: saved?.aiChatHistory?.length || 0,
 hasJupyterNotebook: !!saved?.jupyterNotebook,
 jupyterCellCount: saved?.jupyterNotebook?.cells?.length || 0,
 jupyterCellCounter: saved?.jupyterNotebook?.cellCounter,
 hasPdfData: !!saved?.pdfData,
 pdfName: saved?.pdfData?.name,
 pdfDataSize: saved?.pdfData?.data?.length || 0,
 hasDatasets: !!saved?.datasets,
 datasetCount: saved?.datasets?.length || 0,
 timestamp: saved?.timestamp,
 activeTab: saved?.uiState?.activeTab
 });

 console.log('‚úÖ Auto-save test complete! Check console for details.');
 };

 // Test function for PDF and Jupyter restoration
 window.testRestoration = function() {
 console.log('üß™ Testing PDF and Jupyter restoration...');

 const saved = loadAppState();
 if (!saved) {
 console.log('‚ùå No saved state found');
 return;
 }

 console.log('üìã Saved state analysis:', {
 hasPdfData: !!saved.pdfData,
 pdfName: saved.pdfData?.name,
 pdfDataLength: saved.pdfData?.data?.length,
 hasJupyterNotebook: !!saved.jupyterNotebook,
 jupyterCellCount: saved.jupyterNotebook?.cells?.length,
 activeTab: saved.uiState?.activeTab
 });

 // Check if required functions exist
 console.log('üîß Function availability:', {
 loadPdfFromData: typeof loadPdfFromData,
 createCell: typeof createCell,
 clearAllCells: typeof clearAllCells,
 switchTab: typeof switchTab
 });

 // Check if required DOM elements exist
 console.log('üèóÔ∏è DOM elements:', {
 cellsContainer: !!document.getElementById('cells-container'),
 pdfContainer: !!document.getElementById('pdf-container'),
 chatHistory: !!document.getElementById('chat-history')
 });

 console.log('‚úÖ Restoration test complete! Check console for details.');
 };

 // Manual restoration trigger for testing
 window.manualRestore = function() {
 console.log('üîÑ Manually triggering restoration...');
 try {
 restoreAppState();
 console.log('‚úÖ Manual restoration completed');
 } catch (error) {
 console.error('‚ùå Manual restoration failed:', error);
 }
 };

 // Clear saved state for testing
 window.clearSavedState = function() {
 localStorage.removeItem('appState');
 console.log('üóëÔ∏è Saved state cleared');
 };

 // Force save current state
 window.forceSave = function() {
 console.log('üíæ Force saving current state...');
 saveAppState();
 console.log('‚úÖ State saved');
 };

 // Create test content for testing auto-save
 window.createTestContent = function() {
 console.log('üß™ Creating test content...');

 // Add a test chat message
 if (typeof addChatMessage === 'function') {
 addChatMessage('user', 'Test message for auto-save');
 console.log('‚úÖ Test chat message added');
 }

 // Create a test Jupyter cell
 if (typeof createCell === 'function' && typeof switchTab === 'function') {
 switchTab('jupyter');
 setTimeout(() => {
 const testCell = createCell('print("Hello from auto-save test!")');
 const cellsContainer = document.getElementById('cells-container');
 if (cellsContainer && testCell) {
 cellsContainer.appendChild(testCell);
 console.log('‚úÖ Test Jupyter cell added');
 }
 }, 500);
 }

 // Add a test canvas object
 if (fabricCanvas) {
 const rect = new fabric.Rect({
 left: 100,
 top: 100,
 width: 100,
 height: 100,
 fill: 'red',
 id: 'test-rect-' + Date.now()
 });
 fabricCanvas.add(rect);
 console.log('‚úÖ Test canvas rectangle added');
 }

 console.log('üéØ Test content created! Wait 3 seconds for auto-save, then refresh to test restoration.');
 };

 // Test specifically PDF and Jupyter restoration
 window.testPdfJupyterRestore = function() {
 console.log('üß™ Testing PDF and Jupyter restoration specifically...');

 const saved = loadAppState();
 if (!saved) {
 console.log('‚ùå No saved state found');
 return;
 }

 console.log('üìä Current state check:', {
 currentTab: activeTab,
 pdfViewerVisible: !document.getElementById('pdf-viewer-content')?.classList.contains('hidden'),
 jupyterVisible: !document.getElementById('jupyter-content')?.classList.contains('hidden'),
 cellsContainerExists: !!document.getElementById('cells-container'),
 cellsInContainer: document.getElementById('cells-container')?.children.length || 0,
 pdfContainerExists: !!document.getElementById('pdf-container'),
 currentPdfName: currentPdfName,
 currentPdfData: currentPdfData ? 'Present' : 'None'
 });

 if (saved.pdfData) {
 console.log('üìÑ PDF data in saved state:', {
 name: saved.pdfData.name,
 hasData: !!saved.pdfData.data,
 dataLength: saved.pdfData.data?.length,
 currentPage: saved.pdfData.currentPage,
 totalPages: saved.pdfData.totalPages
 });

 console.log('üîÑ Switching to PDF viewer to check...');
 if (typeof switchTab === 'function') {
 switchTab('pdf-viewer');
 }
 }

 if (saved.jupyterNotebook) {
 console.log('üìì Jupyter data in saved state:', {
 cellCount: saved.jupyterNotebook.cells?.length,
 cellCounter: saved.jupyterNotebook.cellCounter,
 firstCellCode: saved.jupyterNotebook.cells?.[0]?.code?.substring(0, 50)
 });

 setTimeout(() => {
 console.log('üîÑ Switching to Jupyter to check...');
 if (typeof switchTab === 'function') {
 switchTab('jupyter');
 }

 setTimeout(() => {
 const cellsContainer = document.getElementById('cells-container');
 console.log('üìä Jupyter container check:', {
 containerExists: !!cellsContainer,
 cellsInDOM: cellsContainer?.children.length || 0,
 cellsArray: cells?.length || 0
 });
 }, 500);
 }, 1000);
 }
 };

 // Auto-save indicator disabled per user request
 function showAutoSaveIndicator() {
 // Function disabled - no visual indicator shown
 return;
 }

 // Restore indicator
 function showRestoreIndicator() {
 // Create indicator if it doesn't exist
 let indicator = document.getElementById('restore-indicator');
 if (!indicator) {
 indicator = document.createElement('div');
 indicator.id = 'restore-indicator';
 indicator.style.cssText = `
 position: fixed;
 top: 20px;
 left: 50%;
 transform: translateX(-50%);
 background: #3b82f6;
 color: white;
 padding: 12px 24px;
 border-radius: 25px;
 font-size: 14px;
 font-weight: 500;
 z-index: 10000;
 opacity: 0;
 transition: opacity 0.3s ease;
 pointer-events: none;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 `;
 indicator.innerHTML = `
 <div class="restore-indicator-content">
 <div class="restore-spinner"></div>
 <span class="restore-status-text">Restoring your work</span>
 </div>
 `;
 document.body.appendChild(indicator);

 // Inject styles for the spinner once
 if (!document.getElementById('restore-indicator-style')) {
 const style = document.createElement('style');
 style.id = 'restore-indicator-style';
 style.textContent = `
 @keyframes restoreSpin {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
 }
 #restore-indicator .restore-indicator-content {
 display: flex;
 align-items: center;
 gap: 10px;
 letter-spacing: 0.02em;
 }
 #restore-indicator .restore-spinner {
 width: 14px;
 height: 14px;
 border-radius: 50%;
 border: 2px solid rgba(255, 255, 255, 0.35);
 border-top-color: #ffffff;
 animation: restoreSpin 0.8s linear infinite;
 }
 `;
 document.head.appendChild(style);
 }
 } else {
 const statusText = indicator.querySelector('.restore-status-text');
 if (statusText) {
 statusText.textContent = 'Restoring your work';
 }
 }

 // Show indicator
 indicator.style.opacity = '1';
 indicator.style.background = '#3b82f6';

 // Hide after animation completes
 setTimeout(() => {
 indicator.style.opacity = '0';
 }, 2500);
 }

 function saveRoomSession(roomId, userId, userName, isHost = false) {
 const sessionData = {
 roomId: roomId,
 userId: userId,
 userName: userName,
 isHost: isHost, // Track if this user was the host
 timestamp: Date.now()
 };
 localStorage.setItem('roomSession', JSON.stringify(sessionData));
 console.log('üíæ Room session saved:', { roomId, userId, userName, isHost });

 // Also save to comprehensive app state
 saveAppState();

 // Verify it was saved
 const verification = localStorage.getItem('roomSession');
 console.log('üîç Verification - stored data:', verification);
 }

 function loadRoomSession() {
 try {
 const sessionData = localStorage.getItem('roomSession');
 if (sessionData) {
 const parsed = JSON.parse(sessionData);
 // Check if session is not too old (24 hours)
 const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
 if (Date.now() - parsed.timestamp < maxAge) {
 console.log('üìÇ Room session loaded:', parsed);
 return parsed;
 } else {
 console.log('‚è∞ Room session expired, clearing');
 clearRoomSession();
 }
 }
 } catch (error) {
 console.error('‚ùå Error loading room session:', error);
 clearRoomSession();
 }
 return null;
 }

 function clearRoomSession() {
 localStorage.removeItem('roomSession');
 console.log('üóëÔ∏è Room session cleared');
 }

 function manualClearRoomSession() {
 clearRoomSession();
 wasKicked = false; // Also reset kicked status
 addChatMessage('System', 'Room session cleared. You will not automatically rejoin on page refresh.');
 }

 // Function to manually reset kicked status (for testing or manual reset)
 function resetKickedStatus() {
 wasKicked = false;
 console.log('üîÑ Kicked status reset - auto-rejoin re-enabled');
 addChatMessage('System', 'Kicked status reset. Auto-rejoin is now enabled.');
 }

 // Test function for auto-rejoin (can be called from browser console)
 window.testAutoRejoin = function() {
 console.log('=== AUTO-REJOIN DEBUG TEST ===');
 console.log('Current state:');
 console.log('- currentUserId:', currentUserId);
 console.log('- currentRoomId:', currentRoomId);
 console.log('- isAutoRejoining:', isAutoRejoining);
 console.log('- isConnected:', isConnected);

 const session = loadRoomSession();
 if (session) {
 console.log('‚úÖ Saved session found:', session);
 const ageHours = Math.round((Date.now() - session.timestamp) / (1000 * 60 * 60) * 100) / 100;
 console.log('- Session age:', ageHours, 'hours');
 addChatMessage('System', `Saved session found: Room ${session.roomId}, User: ${session.userName} (${ageHours}h old)`);
 } else {
 console.log('‚ùå No saved session found');
 addChatMessage('System', 'No saved room session found');
 }

 // Check localStorage directly
 const rawData = localStorage.getItem('roomSession');
 console.log('Raw localStorage data:', rawData);
 console.log('=== END DEBUG TEST ===');
 };

 // Manual trigger for auto-rejoin (for testing)
 window.triggerAutoRejoin = function() {
 console.log('üîÑ Manually triggering auto-rejoin...');
 const savedSession = loadRoomSession();
 if (savedSession && savedSession.roomId && collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 console.log('üì§ Sending manual rejoin request for room:', savedSession.roomId, savedSession.isHost ? '(with host restoration)' : '');
 isAutoRejoining = true;
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: savedSession.roomId,
 was_host: savedSession.isHost || false
 }));
 } else {
 console.log('‚ùå Cannot trigger auto-rejoin:', {
 hasSession: !!savedSession,
 roomId: savedSession?.roomId,
 socketOpen: collaborationSocket?.readyState === WebSocket.OPEN
 });
 }
 };

 // Debug function to check state when joining room
 window.debugRoomJoin = function() {
 console.log('=== ROOM JOIN DEBUG ===');
 console.log('Variables state:');
 console.log('- currentUserId:', currentUserId);
 console.log('- currentRoomId:', currentRoomId);
 console.log('- isAutoRejoining:', isAutoRejoining);
 console.log('- userName from localStorage:', localStorage.getItem('userName'));

 if (currentUserId && currentRoomId) {
 console.log('‚úÖ Ready to save session');
 const userName = localStorage.getItem('userName') || 'Anonymous';
 console.log('Would save:', { roomId: currentRoomId, userId: currentUserId, userName });
 } else {
 console.log('‚ùå Missing required data for session save');
 }
 console.log('=== END DEBUG ===');
 };

 // Make session management functions available globally for debugging
 window.saveRoomSession = saveRoomSession;
 window.loadRoomSession = loadRoomSession;
 window.clearRoomSession = manualClearRoomSession;
 window.saveAppState = saveAppState;
 window.loadAppState = loadAppState;
 window.restoreAppState = restoreAppState;
 window.clearAppState = clearAppState;

 // Manual localStorage cleanup function
 window.clearLocalStorage = function() {
 console.log('üßπ Clearing localStorage to fix quota issues...');
 try {
 localStorage.removeItem('appState');
 localStorage.removeItem('roomSession');
 console.log('‚úÖ localStorage cleared successfully');
 console.log('‚ÑπÔ∏è You may need to refresh the page for full effect');
 } catch (error) {
 console.error('‚ùå Error clearing localStorage:', error);
 }
 };

 // Debug function to check localStorage usage
 window.checkStorageUsage = function() {
 let total = 0;
 for (let key in localStorage) {
 if (localStorage.hasOwnProperty(key)) {
 total += localStorage[key].length;
 }
 }
 console.log('üìä localStorage usage:', {
 totalChars: total,
 totalKB: Math.round(total / 1024),
 totalMB: Math.round(total / 1024 / 1024),
 keys: Object.keys(localStorage)
 });
 return total;
 };

 // --- Collaboration Functions ---
 function updateConnectionStatus(connected, roomId = null) {
 isConnected = connected;
 currentRoomId = roomId;

 // Save room session when successfully connected to a room
 if (connected && roomId && currentUserId && !isAutoRejoining) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 const isHost = currentUserId === currentRoomHostId;
 saveRoomSession(roomId, currentUserId, userName, isHost);
 }

 // Only clear room session when explicitly disconnecting from room (not on initial connection)
 // We don't want to clear the session just because we're connecting without a room yet
 // The session should only be cleared when manually leaving a room

 if (connected) {
 connectionIndicator.className = 'w-2 h-2 rounded-full bg-green-500';

 // Show different status text based on auto-rejoin state
 if (isAutoRejoining) {
 connectionText.textContent = 'Rejoining...';
 } else {
 connectionText.textContent = roomId ? 'Connected' : 'Online';
 }

 if (roomId) {
 roomInfo.textContent = `Room: ${roomId}`;
 roomInfo.classList.remove('hidden');
 activeUsers.classList.remove('hidden');
 leaveRoomBtn.classList.remove('hidden');
 startVideoCallBtn.classList.remove('hidden');
 createRoomBtn.classList.add('hidden');
 joinRoomBtn.classList.add('hidden');
 } else {
 roomInfo.classList.add('hidden');
 activeUsers.classList.add('hidden');
 leaveRoomBtn.classList.add('hidden');
 startVideoCallBtn.classList.add('hidden');
 createRoomBtn.classList.remove('hidden');
 joinRoomBtn.classList.remove('hidden');
 }
 } else {
 connectionIndicator.className = 'w-2 h-2 rounded-full bg-red-500';
 connectionText.textContent = 'Offline';
 roomInfo.classList.add('hidden');
 activeUsers.classList.add('hidden');
 leaveRoomBtn.classList.add('hidden');
 createRoomBtn.classList.remove('hidden');
 joinRoomBtn.classList.remove('hidden');
 }
 }
updateHostBroadcastUi();

 function resetHostBroadcastState(resetHostId = false) {
 hostBroadcastState.enabled = false;
 hostBroadcastState.pdf = null;
 if (resetHostId) {
 hostBroadcastState.hostId = null;
 }
 updateHostBroadcastUi();
 }

 function updateHostBroadcastUi() {
 if (!hostBroadcastToggleBtn) {
 return;
 }

 if (!currentRoomId) {
 hostBroadcastToggleBtn.classList.add('hidden');
 return;
 }

 hostBroadcastToggleBtn.classList.remove('hidden');
 const isHost = userIsHost();

 hostBroadcastToggleBtn.disabled = !isHost;
 hostBroadcastToggleBtn.classList.toggle('opacity-60', !isHost);
 hostBroadcastToggleBtn.classList.toggle('cursor-not-allowed', !isHost);
 hostBroadcastToggleBtn.classList.remove('broadcast-on', 'broadcast-off');
 hostBroadcastToggleBtn.classList.add(hostBroadcastState.enabled ? 'broadcast-on' : 'broadcast-off');

 const labelText = hostBroadcastState.enabled ? 'Broadcast ON' : 'Broadcast OFF';
 if (hostBroadcastLabel) {
 hostBroadcastLabel.textContent = labelText;
 }

 if (hostBroadcastIndicator) {
 const indicatorBase = 'broadcast-state-indicator inline-flex items-center justify-center';
 hostBroadcastIndicator.className = `${indicatorBase} ${hostBroadcastState.enabled ? 'bg-emerald-300 animate-pulse' : 'bg-slate-400'}`;
 }

 if (hostBroadcastIcon) {
 const iconBase = 'w-5 h-5 transition-transform duration-300';
 hostBroadcastIcon.className = `${iconBase} ${hostBroadcastState.enabled ? 'text-white scale-105' : 'text-slate-600'}`;
 }

 hostBroadcastToggleBtn.setAttribute('aria-pressed', hostBroadcastState.enabled ? 'true' : 'false');
 hostBroadcastToggleBtn.setAttribute('data-state', hostBroadcastState.enabled ? 'on' : 'off');
 hostBroadcastToggleBtn.title = isHost
 ? 'Broadcast host AI + PDF'
 : 'Only the host can change this setting';
 }

 function sendHostBroadcastControl(enabled) {
 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 console.warn('‚ö†Ô∏è Cannot update broadcast state - not connected to collaboration server');
 return;
 }

 collaborationSocket.send(JSON.stringify({
 type: 'host_broadcast_control',
 enabled
 }));
 }

 function handleHostBroadcastToggle() {
 if (!currentRoomId) {
 console.warn('‚ö†Ô∏è Cannot toggle broadcast outside of a room');
 return;
 }

 const isHost = typeof isCurrentUserHost === 'function' ? isCurrentUserHost() : currentUserId === currentRoomHostId;
 if (!isHost) {
 alert('Only the active room host can toggle broadcast mode.');
 return;
 }

 const nextState = !hostBroadcastState.enabled;
 hostBroadcastState.enabled = nextState;
 hostBroadcastState.hostId = currentUserId;
 if (!nextState) {
 hostBroadcastState.pdf = null;
 }
 updateHostBroadcastUi();
 sendHostBroadcastControl(nextState);
 if (nextState && currentPdfDoc && currentPdfData && currentPdfName) {
 maybeBroadcastPdfState('load', {
 pdf_name: currentPdfName,
 pdf_data: currentPdfData,
 current_page: currentPdfPage,
 total_pages: totalPdfPages
 });
 }
 }

 function getCollaborationSocketCandidates() {
 const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
 const host = window.location.host;
 const hostname = window.location.hostname;
 const candidates = [];

 // Prefer same-origin endpoint so corporate firewalls (e.g., FortiGate) allow it on port 443.
 if (host) {
 candidates.push(`${protocol}//${host}/ws`);
 }

 // Fallback to legacy dedicated port for local development/file:// usage.
 if (hostname) {
 candidates.push(`${protocol}//${hostname}:8765`);
 } else if (!host) {
 candidates.push(`${protocol}//localhost:8765`);
 }

 return [...new Set(candidates)];
 }

 function connectToCollaborationServer(forceReconnect = false) {
 if (!forceReconnect && collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 return;
 }

 if (!collaborationSocketCandidates.length) {
 collaborationSocketCandidates = getCollaborationSocketCandidates();
 collaborationSocketCandidateIndex = 0;
 }

 const wsUrl = collaborationSocketCandidates[collaborationSocketCandidateIndex];
 if (!wsUrl) {
 console.error('‚ùå No collaboration WebSocket endpoints available');
 return;
 }

 let hasConnectedThisAttempt = false;

 try {
 console.log('Connecting to WebSocket at:', wsUrl);
 collaborationSocket = new WebSocket(wsUrl);

 collaborationSocket.onopen = () => {
 hasConnectedThisAttempt = true;
 console.log('Connected to collaboration server');
 updateConnectionStatus(true);

 // Get or ask for user name
 let userName = localStorage.getItem('userName');
 if (!userName || userName === 'Anonymous') {
 userName = prompt('Welcome! Please enter your display name:') || 'Anonymous';
 localStorage.setItem('userName', userName);
 }

 console.log('Registering user with name:', userName);
 collaborationSocket.send(JSON.stringify({
 type: 'register',
 name: userName
 }));
 };

 collaborationSocket.onmessage = (event) => {
 try {
 const data = JSON.parse(event.data);
 handleCollaborationMessage(data);
 } catch (error) {
 console.error('Error parsing collaboration message:', error);
 }
 };

 collaborationSocket.onclose = () => {
 console.log('Disconnected from collaboration server');
 updateConnectionStatus(false);
 currentUserId = null;
 currentRoomId = null;
 currentRoomHostId = null;
 resetHostBroadcastState(true);
 roomUsers.clear();
 clearUserCursors();
 updateUserCount();

 // Reset auto-rejoin flag on disconnect
 isAutoRejoining = false;

 // Reset kicked flag only on manual disconnect (not on kick-induced disconnect)
 // The wasKicked flag should persist through reconnections to prevent auto-rejoin

 // Stop video call if active when disconnecting from collaboration server
 if (videoCallManager.isActive) {
 console.log('Stopping video call due to collaboration server disconnect');
 videoCallManager.leaveCall();
 }

 // Disconnect from group messaging when collaboration disconnects
 leaveGroupMessagingRoom();

 if (!hasConnectedThisAttempt && collaborationSocketCandidateIndex < collaborationSocketCandidates.length - 1) {
 collaborationSocketCandidateIndex += 1;
 const fallbackUrl = collaborationSocketCandidates[collaborationSocketCandidateIndex];
 console.warn('Primary collaboration WebSocket blocked. Falling back to:', fallbackUrl);
 setTimeout(() => connectToCollaborationServer(true), 1000);
 return;
 }

 // Attempt to reconnect after 3 seconds using the last working endpoint
 setTimeout(connectToCollaborationServer, 3000);
 };

 collaborationSocket.onerror = (error) => {
 console.error('Collaboration WebSocket error:', error);
 if (!hasConnectedThisAttempt && collaborationSocket && collaborationSocket.readyState !== WebSocket.CLOSED) {
 try {
 collaborationSocket.close();
 } catch (closeError) {
 console.error('Error closing failed collaboration socket:', closeError);
 }
 }
 };

 } catch (error) {
 console.error('Failed to connect to collaboration server:', error);
 updateConnectionStatus(false);
 }
 }

 // Add proper cleanup when user closes browser/tab
 window.addEventListener('beforeunload', () => {
 // Save app state before leaving
 saveAppState();

 // If user is in a video call, notify others they're leaving the call
 if (videoCallManager.isActive) {
 videoCallManager.notifyVideoCallEvent('participant_left', { userId: currentUserId });
 }

 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 // Send leave room message before closing
 if (currentRoomId) {
 collaborationSocket.send(JSON.stringify({
 type: 'leave_room'
 }));
 }
 // Close the websocket connection
 collaborationSocket.close();
 }
 });

 // Add visibility change handler for when user switches tabs
 document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 // User switched away from tab - could implement heartbeat pause here
 console.log('User switched away from tab');
 } else {
 // User returned to tab - could implement heartbeat resume here
 console.log('User returned to tab');
 }
 });

 function handleCollaborationMessage(data) {
 switch (data.type) {
 case 'registered':
 currentUserId = data.user_id;
 console.log('Registered with user ID:', currentUserId);
 console.log('User registered with name:', localStorage.getItem('userName') || 'Anonymous');

 // Check for saved room session and auto-rejoin (only if not kicked)
 const savedSession = loadRoomSession();

 if (savedSession && savedSession.roomId && !isAutoRejoining && !wasKicked) {
 isAutoRejoining = true;

 // Update stored user name if it has changed
 const currentUserName = localStorage.getItem('userName') || 'Anonymous';
 if (currentUserName !== savedSession.userName) {
 saveRoomSession(savedSession.roomId, currentUserId, currentUserName, savedSession.isHost);
 }

 console.log('üîÑ Auto-rejoining room:', savedSession.roomId, savedSession.isHost ? '(as room creator)' : '');
 addChatMessage('System', `Attempting to rejoin room: ${savedSession.roomId}${savedSession.isHost ? ' (you are the room creator)' : ''}`);

 // Attempt to rejoin the room (with host restoration if needed)
 setTimeout(() => {
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: savedSession.roomId,
 was_host: savedSession.isHost || false  // Send host status for server-side restoration
 }));
 }, 500); // Small delay to ensure registration is complete
 } else if (wasKicked) {
 console.log('üö´ Auto-rejoin blocked - user was kicked from previous session');
 addChatMessage('System', 'Auto-rejoin disabled - you were kicked from the previous room');
 } else {
 console.log('No saved room session found or already auto-rejoining');
 }
 break;

 case 'room_created':
 if (data.success) {
 updateConnectionStatus(true, data.room_id);

 // Reset kicked flag since user manually created a new room
 wasKicked = false;

 // Set current user as host since they created the room
 currentRoomHostId = currentUserId;
 updateHostBroadcastUi();

 // Set room creator info (but don't activate override yet)
 roomCreatorId = currentUserId;

 // Save room session for room creator (they are the host)
 if (currentUserId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(data.room_id, currentUserId, userName, true); // true = is host (room creator)
 console.log('üíæ Saved room creator session - you are the permanent room owner');
 addChatMessage('System', '‚úÖ You are the room creator and host. Your host status will be restored on refresh.');
 }

 // Removed noisy system message - room creation is shown in UI
 // Copy room ID to clipboard
 navigator.clipboard.writeText(data.room_id).then(() => {
 // Removed noisy system message - clipboard action is self-evident
 });

 // Add the room creator to roomUsers
 if (currentUserId) {
 const currentUserName = localStorage.getItem('userName') || 'Anonymous';
 roomUsers.set(currentUserId, { id: currentUserId, name: currentUserName });
 console.log('Added room creator to roomUsers:', currentUserId, currentUserName);
 updateUserCount();
 }

 // Automatically connect to group messaging
 const userName = localStorage.getItem('userName') || 'Anonymous';
 joinGroupMessagingRoom(data.room_id, userName);
 // Removed noisy system message - group messaging is automatic
 }
 break;

 case 'room_joined':
 if (data.success) {
 updateConnectionStatus(true, data.room_id);

 // Notify status indicator of room join
 if (typeof videoCallStatusIndicator !== 'undefined') {
 videoCallStatusIndicator.onRoomJoined();
 }

 // Request current video call status from other users
 setTimeout(() => {
 requestVideoCallStatus();
 }, 1000); // Small delay to ensure room join is complete

 // Check for existing video call participants in room join response
 if (data.video_call_participants && data.video_call_participants.length > 0) {
 console.log('üìπ Room join: Found existing video call with participants:', data.video_call_participants);

 // Update video call status indicator with existing participants
 if (typeof videoCallStatusIndicator !== 'undefined') {
 // Reset and add all participants
 videoCallStatusIndicator.reset();

 data.video_call_participants.forEach(participant => {
 videoCallStatusIndicator.addParticipant(participant.user_id, participant.user_name);
 });

 // Update status to show ongoing call
 videoCallStatusIndicator.updateStatus(false, true, 0);

 console.log('üìπ Room join: Updated video call status for existing call with', data.video_call_participants.length, 'participants');
 }
 }

 // Check if host information is provided in the response
 if (data.room && data.room.host_id) {
 currentRoomHostId = data.room.host_id;
 console.log('üè† Host ID set from room data:', data.room.host_id);
 updateHostBroadcastUi();
 } else if (data.host_id) {
 currentRoomHostId = data.host_id;
 console.log('üè† Host ID set from response:', data.host_id);
 updateHostBroadcastUi();
 }

 if (data.room && typeof data.room.broadcast_enabled !== 'undefined') {
 handleHostBroadcastStateUpdate({
 enabled: data.room.broadcast_enabled,
 host_id: data.room.host_id,
 pdf: data.room.broadcast_pdf
 });
 } else {
 resetHostBroadcastState();
 }

 // Reset kicked flag for successful room joins (manual or auto-rejoin)
 wasKicked = false;

 // REAL HOST RESTORATION - Check if this user should be the host
 const savedSession = loadRoomSession();
 if (isAutoRejoining && savedSession && savedSession.isHost && currentUserId) {
 console.log('üîÑ Auto-rejoin detected - attempting REAL host restoration...');
 console.log('- Saved session isHost:', savedSession.isHost);
 console.log('- Current host ID:', currentRoomHostId);
 console.log('- Current user ID:', currentUserId);

 // Wait for room state to stabilize, then attempt real restoration
 setTimeout(() => {
 if (currentUserId !== currentRoomHostId) {
 console.log('‚ö†Ô∏è Host privileges not restored by server - attempting real restoration...');
 addChatMessage('System', 'Attempting to restore host privileges on server...');

 // Try real host restoration
 realHostRestore();
 } else {
 console.log('‚úÖ Host privileges automatically restored by server');
 addChatMessage('System', '‚úÖ Host privileges automatically restored');
 }
 }, 3000); // Wait longer for room state to stabilize
 }

 // Save session for both manual joins and auto-rejoins to ensure host status is current
 if (currentUserId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 const isHost = currentUserId === currentRoomHostId;

 // For auto-rejoins, preserve the original isHost status if user was room creator
 if (isAutoRejoining) {
 const savedSession = loadRoomSession();
 const wasRoomCreator = savedSession && savedSession.isHost;
 // If user was room creator, maintain that status regardless of current host
 const finalIsHost = wasRoomCreator || isHost;
 saveRoomSession(data.room_id, currentUserId, userName, finalIsHost);
 console.log('üíæ Updated session after auto-rejoin - isHost:', finalIsHost, '(was room creator:', wasRoomCreator, ')');
 } else {
 saveRoomSession(data.room_id, currentUserId, userName, isHost);
 }
 }

 // Handle auto-rejoin completion
 if (isAutoRejoining) {
 console.log('‚úÖ Auto-rejoin successful for room:', data.room_id);
 addChatMessage('System', `Automatically rejoined room: ${data.room_id}`);
 isAutoRejoining = false;
 } else {
 // Removed noisy system message for manual joins - room joining is shown in UI
 }

 // Update room users so everyone can see each other's cursors
 if (data.users) {
 console.log('Updating room users:', data.users);
 updateRoomUsers(data.users);
 }

 // Automatically connect to group messaging
 const userName = localStorage.getItem('userName') || 'Anonymous';
 joinGroupMessagingRoom(data.room_id, userName);
 // Removed noisy system message - group messaging is automatic
 } else {
 if (isAutoRejoining) {
 console.log('‚ùå Auto-rejoin failed for room');
 addChatMessage('System', 'Failed to automatically rejoin previous room. The room may no longer exist.');
 clearRoomSession(); // Clear invalid session
 isAutoRejoining = false;
 } else {
 addChatMessage('AI', 'Failed to join room. Please check the room ID and try again.');
 }
 }
 break;

 case 'room_left':
 updateConnectionStatus(true, null); // Connected but not in a room
 resetHostBroadcastState(true);
 // Removed noisy system message - room leaving is shown in UI
 roomUsers.clear();
 clearUserCursors();
 currentRoomId = null;
 currentRoomHostId = null;

 // Clear room session when manually leaving room (not during auto-rejoin)
 if (!isAutoRejoining) {
 clearRoomSession();
 console.log('üóëÔ∏è Room session cleared after manual room leave');
 }

 // Stop video call if active when leaving room
 if (videoCallManager.isActive) {
 console.log('Stopping video call after leaving room');
 videoCallManager.leaveCall();
 }

 // Notify status indicator of room leave
 if (typeof videoCallNotification !== 'undefined') {
 videoCallStatusIndicator.onRoomLeft();
 }

 // Automatically leave group messaging
 leaveGroupMessagingRoom();
 // Removed noisy system message - group messaging disconnect is automatic
 break;

 case 'canvas_state':
 loadCanvasState(data.state);
 updateRoomUsers(data.users);
 updateConnectionStatus(true, data.room.id);
 // Set the host ID from room data
 if (data.room && data.room.host_id) {
 currentRoomHostId = data.room.host_id;
 updateHostBroadcastUi();
 }

 if (data.room && typeof data.room.broadcast_enabled !== 'undefined') {
 handleHostBroadcastStateUpdate({
 enabled: data.room.broadcast_enabled,
 host_id: data.room.host_id,
 pdf: data.room.broadcast_pdf
 });
 }

 // Check for existing video call participants
 if (data.video_call_participants && data.video_call_participants.length > 0) {
 console.log('üìπ Found existing video call with participants:', data.video_call_participants);

 // Update video call status indicator with existing participants
 if (typeof videoCallStatusIndicator !== 'undefined') {
 // Reset and add all participants
 videoCallStatusIndicator.reset();

 data.video_call_participants.forEach(participant => {
 videoCallStatusIndicator.addParticipant(participant.user_id, participant.user_name);
 });

 // Update status to show ongoing call
 videoCallStatusIndicator.updateStatus(false, true, 0);

 console.log('üìπ Updated video call status for existing call with', data.video_call_participants.length, 'participants');
 }
 }
 break;

 case 'canvas_event':
 handleRemoteCanvasEvent(data.event, data.user_id);
 break;

 case 'user_joined':
 // Join messages only show in group chat, not in AI chat
 updateRoomUsers([data.user]);
 break;

 case 'user_left':
 const leftUser = roomUsers.get(data.user_id);
 if (leftUser) {
 // Leave messages only show in group chat, not in AI chat
 // Clean up kicked users tracking
 if (recentlyKickedUsers.has(data.user_id)) {
 recentlyKickedUsers.delete(data.user_id);
 console.log(`Cleaned up kicked user tracking: ${leftUser.name}`);
 }

 roomUsers.delete(data.user_id);
 removeUserCursor(data.user_id);
 updateUserCount();
 }
 break;



 case 'cursor_move':
 updateUserCursor(data.user_id, data.x, data.y);
 break;

 case 'name_updated':
 if (data.success) {
 console.log('Name updated successfully to:', data.new_name);
 } else {
 console.warn('Failed to update name');
 }
 break;

 case 'user_name_updated':
 // Update the user in our local cache
 const updatedUser = roomUsers.get(data.user_id);
 if (updatedUser) {
 updatedUser.name = data.new_name;
 roomUsers.set(data.user_id, updatedUser);

 // Update cursor display if it exists
 const cursor = document.getElementById(`cursor-${data.user_id}`);
 if (cursor) {
 const nameSpan = cursor.querySelector('span');
 if (nameSpan) {
 nameSpan.textContent = data.new_name;
 }
 }

 addChatMessage('System', `${data.old_name} changed their name to ${data.new_name}`);
 }
 break;

 case 'video_call_event':
 handleVideoCallEvent(data);
 break;

 case 'video_call_ended':
 // Handle video call end (including when user is kicked)
 if (data.user_id) {
 console.log(`User ${data.user_id} disconnected from video call${data.reason ? ` (${data.reason})` : ''}`);

 // Immediately clean up the user from video call if we're in an active call
 if (videoCallManager.isActive && data.user_id !== currentUserId) {
 videoCallManager.handleUserLeft(data.user_id);

 // Add a system message for kicked users
 if (data.reason === 'kicked') {
 const kickedUser = roomUsers.get(data.user_id);
 const userName = kickedUser ? kickedUser.name : 'User';
 addChatMessage('System', `${userName} was removed from the video call (kicked)`);
 }
 }
 }
 break;

 case 'kick_result':
 if (data.success) {
 addChatMessage('System', 'User kicked successfully');
 } else {
 addChatMessage('System', 'Failed to kick user');
 }
 break;

 case 'kicked':
 // Current user was kicked from the room
 addChatMessage('System', `You were kicked from the room by ${data.kicked_by}`);

 // Set kicked flag to prevent auto-rejoin
 wasKicked = true;

 // Clear room session to prevent auto-rejoin
 clearRoomSession();
 console.log('üö´ Room session cleared due to kick - auto-rejoin disabled');

 // Show kick notification popup
 showKickNotification(data.kicked_by, data.room_id);

 // Force leave the room
 updateConnectionStatus(true, null);
 roomUsers.clear();
 clearUserCursors();
 currentRoomId = null;
 currentRoomHostId = null;
 break;

 case 'user_kicked':
 // Another user was kicked from the room
 const kickedUser = roomUsers.get(data.user_id);
 if (kickedUser) {
 addChatMessage('System', `${data.user_name} was kicked from the room by ${data.kicked_by}`);

 // Add to recently kicked users to prevent "left room" message
 recentlyKickedUsers.add(data.user_id);

 // Clean up kicked user from video call if active
 if (videoCallManager.isActive && data.user_id !== currentUserId) {
 videoCallManager.handleUserLeft(data.user_id);
 console.log(`Cleaned up kicked user ${data.user_id} from video call`);
 }

 roomUsers.delete(data.user_id);
 removeUserCursor(data.user_id);
 updateUserCount();
 }
 break;

 case 'host_mute_command':
 // Host is muting/unmuting this user's video or audio
 const muteType = data.mute_type; // 'video' or 'audio'
 const action = data.action; // 'mute' or 'unmute'
 const hostName = data.host_name;

 console.log(`Host ${hostName} is ${action}ing your ${muteType}`);
 addChatMessage('System', `Host ${hostName} ${action}d your ${muteType}`);

 // Apply the mute command if video call is active
 if (videoCallManager.isActive && localStream) {
 if (muteType === 'video') {
 const videoTrack = localStream.getVideoTracks()[0];
 if (videoTrack) {
 const shouldEnable = action === 'unmute';
 videoTrack.enabled = shouldEnable;

 // Update global video state variable
 window.videoEnabled = shouldEnable;

 // Update video button state
 const toggleVideoBtn = document.getElementById('toggle-video-btn');
 if (toggleVideoBtn) {
 toggleVideoBtn.className = shouldEnable
 ? 'p-1 rounded bg-blue-500 text-white hover:bg-blue-600'
 : 'p-1 rounded bg-red-500 text-white hover:bg-red-600';
 toggleVideoBtn.title = shouldEnable ? 'Turn Off Video' : 'Turn On Video';
 }

 console.log(`Video ${action}d by host - track enabled: ${videoTrack.enabled}, internal state: ${shouldEnable}`);
 }
 } else if (muteType === 'audio') {
 const audioTrack = localStream.getAudioTracks()[0];
 if (audioTrack) {
 const shouldEnable = action === 'unmute';
 audioTrack.enabled = shouldEnable;

 // Update global audio state variable
 window.audioEnabled = shouldEnable;

 // Update audio button state
 const toggleAudioBtn = document.getElementById('toggle-audio-btn');
 if (toggleAudioBtn) {
 toggleAudioBtn.className = shouldEnable
 ? 'p-1 rounded bg-green-500 text-white hover:bg-green-600'
 : 'p-1 rounded bg-red-500 text-white hover:bg-red-600';
 toggleAudioBtn.title = shouldEnable ? 'Mute Audio' : 'Unmute Audio';
 }

 console.log(`Audio ${action}d by host - track enabled: ${audioTrack.enabled}, internal state: ${shouldEnable}`);
 }
 }
 } else {
 console.log('Video call not active or no local stream available');
 }
 break;

 case 'transfer_host_result':
 if (data.success) {
 addChatMessage('System', `Host privileges successfully transferred to ${data.new_host_name}`);
 console.log('Host transfer successful:', data.new_host_name);
 } else {
 addChatMessage('System', `Failed to transfer host: ${data.message}`);
 console.error('Host transfer failed:', data.message);
 }
 break;

 case 'host_transferred':
 // Update the current room host ID
 currentRoomHostId = data.new_host_id;
 console.log(`Host transferred from ${data.old_host_name} to ${data.new_host_name} (${data.new_host_id})`);

 // Add system message about the host transfer
 if (data.reason === 'auto_rejoin_restoration') {
 addChatMessage('System', `Host privileges restored to ${data.new_host_name} (auto-rejoin)`);
 } else {
 addChatMessage('System', `${data.old_host_name} transferred host privileges to ${data.new_host_name}`);
 }

 // Update room session to reflect new host status
 // Important: Only update isHost if we're not the room owner
 // Room owners should always maintain their owner status even if they transfer host temporarily
 if (currentUserId && currentRoomId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 const savedSession = loadRoomSession();

 // If we're the room owner, keep owner status regardless of current host
 // If we're not the room owner, update based on current host status
 const isRoomOwner = savedSession?.isHost && savedSession?.userId === currentUserId;
 const isHost = isRoomOwner || (currentUserId === data.new_host_id);

 saveRoomSession(currentRoomId, currentUserId, userName, isHost);
 console.log(`üíæ Updated room session - isHost: ${isHost} (room owner: ${isRoomOwner})`);
 }

 // Update the users tooltip to reflect the new host
 updateUsersTooltip();
 hostBroadcastState.hostId = data.new_host_id;
 if (currentUserId !== data.new_host_id) {
 hostBroadcastState.enabled = false;
 hostBroadcastState.pdf = null;
 }
 updateHostBroadcastUi();
 break;

 case 'host_broadcast_state':
 handleHostBroadcastStateUpdate(data);
 break;

 case 'host_broadcast_ai_message':
 handleIncomingBroadcastAiMessage(data);
 break;

 case 'host_broadcast_pdf':
 handleIncomingBroadcastPdf(data);
 break;

 case 'host_restoration_result':
 if (data.success) {
 currentRoomHostId = currentUserId;
 addChatMessage('System', 'Host privileges restored successfully');
 console.log('‚úÖ Host restoration successful');

 // Update room session
 if (currentUserId && currentRoomId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);
 }
 } else {
 console.log('‚ùå Host restoration failed:', data.message);
 addChatMessage('System', `Failed to restore host privileges: ${data.message || 'Unknown error'}`);
 }
 break;

 case 'claim_host_result':
 if (data.success) {
 currentRoomHostId = currentUserId;
 addChatMessage('System', 'Successfully claimed host privileges');
 console.log('‚úÖ Host claim successful');

 // Update room session
 if (currentUserId && currentRoomId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);
 }
 } else {
 console.log('‚ùå Host claim failed:', data.message);
 addChatMessage('System', `Failed to claim host privileges: ${data.message || 'Unknown error'}`);
 }
 break;

 case 'host_transfer_request':
 // Someone is requesting host transfer to them
 const requesterName = data.from_user_name || 'Unknown';
 const isCurrentHost = currentUserId === currentRoomHostId;

 if (isCurrentHost) {
 console.log(`üì® Host transfer request from ${requesterName}`);

 // Show a confirmation dialog
 const shouldTransfer = confirm(`${requesterName} is requesting host privileges. They were previously the host of this room. Transfer host privileges to them?`);

 if (shouldTransfer) {
 transferHost(data.from_user_id, data.from_user_name, true); // Skip confirmation since we already confirmed
 addChatMessage('System', `Transferring host privileges to ${requesterName} as requested`);
 } else {
 addChatMessage('System', `Declined host transfer request from ${requesterName}`);
 }
 }
 break;

 case 'room_owner_registered':
 if (data.success) {
 console.log('‚úÖ Successfully registered as room owner');
 addChatMessage('System', 'You are now the permanent owner of this room');
 } else {
 console.log('‚ùå Failed to register as room owner:', data.message);
 }
 break;

 case 'room_owner_restored':
 if (data.success) {
 currentRoomHostId = currentUserId;
 console.log('‚úÖ Room owner privileges restored by server');
 addChatMessage('System', '‚úÖ Room owner privileges restored by server');

 // Update room session
 if (currentUserId && currentRoomId) {
 const userName = localStorage.getItem('userName') || 'Anonymous';
 saveRoomSession(currentRoomId, currentUserId, userName, true);
 }
 } else {
 console.log('‚ùå Room owner restoration failed:', data.message);
 addChatMessage('System', `Room owner restoration failed: ${data.message || 'Unknown error'}`);
 }
 break;

 case 'owner_rejoined':
 // Notification that the room owner has rejoined
 if (data.owner_id !== currentUserId) {
 const ownerName = data.owner_name || 'Room Owner';
 console.log(`üëë Room owner ${ownerName} has rejoined and reclaimed host privileges`);
 addChatMessage('System', `üëë Room owner ${ownerName} has rejoined and reclaimed host privileges`);
 currentRoomHostId = data.owner_id;

 // Update users tooltip
 updateUsersTooltip();
 }
 break;
 }
 }

 // Request current video call status from other users in the room
 function requestVideoCallStatus() {
 if (!currentRoomId || !collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 return;
 }

 console.log('üìπ Requesting current video call status from room participants');

 collaborationSocket.send(JSON.stringify({
 type: 'video_call_event',
 room_id: currentRoomId,
 event_type: 'status_request',
 data: {},
 user_id: currentUserId
 }));
 }

 // Handle video call events from other users
 function handleVideoCallEvent(data) {
 const eventType = data.event_type;
 const eventData = data.data;
 const userId = data.user_id;

 console.log('Video call event received:', eventType, 'from user:', userId);

 switch (eventType) {
 case 'call_started':
 if (userId !== currentUserId) {
 addChatMessage('System', `Video call started by ${getUserName(userId)}`);

 // Update status indicator to show remote call is active
 if (typeof videoCallStatusIndicator !== 'undefined') {
 const userName = getUserName(userId);
 videoCallStatusIndicator.addParticipant(userId, userName);
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, true, videoCallManager.participants.size);
 }

 // Show notification to join the call
 showVideoCallNotification('Video call started', 'Click to join the video call', () => {
 if (currentRoomId) {
 videoCallManager.startCall(currentRoomId);
 }
 });

 // If we're already in a video call, initiate connection with this user
 if (videoCallManager.isActive) {
 console.log('We are already in call, initiating connection with:', userId);
 videoCallManager.handleUserJoined(userId);
 }
 }
 break;

 case 'call_ended':
 if (userId !== currentUserId) {
 addChatMessage('System', `Video call ended by ${getUserName(userId)}`);

 // Update status indicator to show no remote call
 if (typeof videoCallStatusIndicator !== 'undefined') {
 videoCallStatusIndicator.removeParticipant(userId);
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, false, videoCallManager.participants.size);
 }

 // Clean up connection with this user
 if (videoCallManager.isActive) {
 videoCallManager.handleUserLeft(userId);
 }
 }
 break;

 case 'participant_joined':
 if (userId !== currentUserId) {
 // Update participant count for status indicator
 if (typeof videoCallStatusIndicator !== 'undefined') {
 const userName = getUserName(userId);
 videoCallStatusIndicator.addParticipant(userId, userName);
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, videoCallStatusIndicator.remoteCallActive,
 videoCallManager.participants.size);
 }

 if (videoCallManager.isActive) {
 console.log('Remote participant joined video call, initiating connection:', userId);
 // Initiate connection with the new participant
 videoCallManager.handleUserJoined(userId);
 }
 }
 break;

 case 'participant_left':
 if (userId !== currentUserId) {
 console.log('Remote participant left video call:', eventData);

 // Update participant count for status indicator
 if (typeof videoCallStatusIndicator !== 'undefined') {
 videoCallStatusIndicator.removeParticipant(userId);
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, videoCallStatusIndicator.remoteCallActive,
 videoCallManager.participants.size);
 }

 videoCallManager.handleUserLeft(userId);
 }
 break;

 case 'status_request':
 // Someone is asking for current video call status
 if (userId !== currentUserId && videoCallManager.isActive) {
 console.log('üìπ Received video call status request from:', userId, '- responding with current status');

 // Send our current video call status
 collaborationSocket.send(JSON.stringify({
 type: 'video_call_event',
 room_id: currentRoomId,
 event_type: 'status_response',
 data: {
 is_in_call: true,
 user_name: localStorage.getItem('userName') || 'Anonymous'
 },
 user_id: currentUserId
 }));
 }
 break;

 case 'status_response':
 // Someone responded with their video call status
 if (userId !== currentUserId && eventData.is_in_call) {
 console.log('üìπ Received video call status response from:', userId, eventData);

 // Add this user to our video call participants list
 if (typeof videoCallStatusIndicator !== 'undefined') {
 const userName = eventData.user_name || getUserName(userId);
 videoCallStatusIndicator.addParticipant(userId, userName);
 videoCallStatusIndicator.updateStatus(videoCallManager.isActive, videoCallStatusIndicator.remoteCallActive,
 videoCallManager.participants.size);

 console.log('üìπ Added participant from status response:', userName);
 }
 }
 break;

 default:
 console.log('Unknown video call event:', eventType, eventData);
 }
 }

 // Helper function to get user name
 function getUserName(userId) {
 const user = roomUsers.get(userId);
 return user ? user.name : 'Unknown User';
 }

 // Show video call notification
 function showVideoCallNotification(title, message, onClick) {
 // Check if browser supports notifications
 if ('Notification' in window) {
 if (Notification.permission === 'granted') {
 const notification = new Notification(title, {
 body: message,
 icon: '/favicon.ico',
 tag: 'video-call'
 });

 notification.onclick = () => {
 window.focus();
 if (onClick) onClick();
 notification.close();
 };

 setTimeout(() => notification.close(), 5000);
 } else if (Notification.permission !== 'denied') {
 Notification.requestPermission().then(permission => {
 if (permission === 'granted') {
 showVideoCallNotification(title, message, onClick);
 }
 });
 }
 }

 // Fallback: show in-app notification
 addChatMessage('System', `${title}: ${message}`);
 }

 function updateRoomUsers(users) {
 console.log('updateRoomUsers called with:', users);
 users.forEach(user => {
 console.log('Adding user to roomUsers:', user.id, user.name);
 roomUsers.set(user.id, user);
 });
 console.log('Total users in room:', roomUsers.size);
 updateUserCount();
 }

 function updateUserCount() {
 userCount.textContent = roomUsers.size;
 updateUsersTooltip();
 }

 function kickUser(targetUserId, targetUserName) {
 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 // Use override-aware host check
 if (!isCurrentUserHost()) {
 addChatMessage('System', 'Only the room host can kick users');
 return;
 }

 // Confirm kick action
 if (!confirm(`Are you sure you want to kick ${targetUserName} from the room?`)) {
 return;
 }

 console.log(`üì§ Sending kick request for ${targetUserName}...`);

 // Send kick request to server
 collaborationSocket.send(JSON.stringify({
 type: 'kick_user',
 target_user_id: targetUserId
 }));
 }

 function transferHost(targetUserId, targetUserName, skipConfirmation = false) {
 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 // Check if user is host (including client-side override)
 if (!isCurrentUserHost()) {
 addChatMessage('System', 'Only the room host can transfer host privileges');
 return;
 }

 // Skip confirmation for auto-restoration
 if (!skipConfirmation) {
 // Confirm host transfer action
 if (!confirm(`Are you sure you want to make ${targetUserName} the new host? You will lose your host privileges.`)) {
 return;
 }
 }

 console.log(`üì§ Transferring host privileges to: ${targetUserName} (${targetUserId})`);

 // Send transfer host request
 collaborationSocket.send(JSON.stringify({
 type: 'transfer_host',
 target_user_id: targetUserId
 }));

 if (!skipConfirmation) {
 addChatMessage('System', `Transferring host privileges to ${targetUserName}...`);
 }
 }

 // Function to mute a user's video (host only)
 function hostMuteUserVideo(targetUserId, targetUserName) {
 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 // Use override-aware host check
 if (!isCurrentUserHost()) {
 addChatMessage('System', 'Only the room host can mute users');
 return;
 }

 console.log(`üì§ Sending mute video request for ${targetUserName}...`);

 // Send mute video request to server
 collaborationSocket.send(JSON.stringify({
 type: 'host_mute_user',
 target_user_id: targetUserId,
 mute_type: 'video',
 action: 'mute'
 }));

 addChatMessage('System', `You muted ${targetUserName}'s video`);
 }

 // Function to mute a user's audio (host only)
 function hostMuteUserAudio(targetUserId, targetUserName) {
 if (!collaborationSocket || collaborationSocket.readyState !== WebSocket.OPEN) {
 addChatMessage('System', 'Not connected to collaboration server');
 return;
 }

 // Use override-aware host check
 if (!isCurrentUserHost()) {
 addChatMessage('System', 'Only the room host can mute users');
 return;
 }

 console.log(`üì§ Sending mute audio request for ${targetUserName}...`);

 // Send mute audio request to server
 collaborationSocket.send(JSON.stringify({
 type: 'host_mute_user',
 target_user_id: targetUserId,
 mute_type: 'audio',
 action: 'mute'
 }));

 addChatMessage('System', `You muted ${targetUserName}'s audio`);
 }

 function updateUsersTooltip() {
 const usersList = document.getElementById('users-list');
 if (!usersList) return;

 // Clear existing users
 usersList.innerHTML = '';

 // Add each user to the tooltip
 roomUsers.forEach((user, userId) => {
 const userItem = document.createElement('div');
 userItem.className = 'flex items-center justify-between text-sm text-slate-600 dark:text-slate-400 py-2 px-1 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors';

 // Left side: indicator and name
 const userInfo = document.createElement('div');
 userInfo.className = 'flex items-center space-x-3';

 // Add online indicator
 const indicator = document.createElement('div');
 indicator.className = 'w-3 h-3 rounded-full bg-green-500 flex-shrink-0 shadow-sm';

 // Add user name
 const userName = document.createElement('span');
 userName.className = 'truncate font-medium';

 // Build name with labels
 let nameText = user.name || 'Anonymous';
 if (userId === currentUserId) {
 nameText += ' (You)';
 }

 // Check for host status (including client-side override)
 const isUserHost = (hostOverrideActive && clientSideHostOverride === userId) || (userId === currentRoomHostId);
 if (isUserHost) {
 nameText += ' üëë Host';
 if (hostOverrideActive && clientSideHostOverride === userId) {
 nameText += ' (Override)';
 }
 }
 userName.textContent = nameText;

 // Style current user and host differently
 if (userId === currentUserId) {
 userName.className += ' text-indigo-600 dark:text-indigo-400 font-semibold';
 } else if (isUserHost) {
 userName.className += ' text-amber-600 dark:text-amber-400 font-semibold';
 }

 userInfo.appendChild(indicator);
 userInfo.appendChild(userName);
 userItem.appendChild(userInfo);

 // Right side: host controls (only show if current user is host and target is not host)
 const currentUserIsHost = isCurrentUserHost();
 if (currentUserIsHost && !isUserHost && userId !== currentUserId) {
 const controlsContainer = document.createElement('div');
 controlsContainer.className = 'flex items-center space-x-1 ml-3';

 // Mute video button
 const muteVideoButton = document.createElement('button');
 muteVideoButton.className = 'p-2 rounded-lg hover:bg-orange-100 dark:hover:bg-orange-900/40 text-orange-500 dark:text-orange-400 transition-all duration-200 hover:scale-110 hover:shadow-md';
 muteVideoButton.title = `Mute ${user.name}'s video`;
 muteVideoButton.innerHTML = `
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
 </svg>
 `;
 muteVideoButton.onclick = (e) => {
 e.stopPropagation();
 hostMuteUserVideo(userId, user.name);
 };

 // Mute audio button
 const muteAudioButton = document.createElement('button');
 muteAudioButton.className = 'p-2 rounded-lg hover:bg-yellow-100 dark:hover:bg-yellow-900/40 text-yellow-500 dark:text-yellow-400 transition-all duration-200 hover:scale-110 hover:shadow-md';
 muteAudioButton.title = `Mute ${user.name}'s audio`;
 muteAudioButton.innerHTML = `
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" clip-rule="evenodd"></path>
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"></path>
 </svg>
 `;
 muteAudioButton.onclick = (e) => {
 e.stopPropagation();
 hostMuteUserAudio(userId, user.name);
 };

 // Make Host button
 const makeHostButton = document.createElement('button');
 makeHostButton.className = 'p-2 rounded-lg hover:bg-purple-100 dark:hover:bg-purple-900/40 text-purple-500 dark:text-purple-400 transition-all duration-200 hover:scale-110 hover:shadow-md';
 makeHostButton.title = `Make ${user.name} the host`;
 makeHostButton.innerHTML = `
 <svg class="w-4 h-4" fill="currentColor" stroke="none" viewBox="0 0 24 24">
 <path d="M5 16L3 21l5.25-1.5L12 21l3.75-1.5L21 21l-2-5H5zm2.5-5c0-2.5 2-4.5 4.5-4.5s4.5 2 4.5 4.5H7.5zM12 2L9.5 7h5L12 2z"></path>
 </svg>
 `;
 makeHostButton.onclick = (e) => {
 e.stopPropagation();
 transferHost(userId, user.name);
 };

 // Kick button
 const kickButton = document.createElement('button');
 kickButton.className = 'p-2 rounded-lg hover:bg-red-100 dark:hover:bg-red-900/40 text-red-500 dark:text-red-400 transition-all duration-200 hover:scale-110 hover:shadow-md';
 kickButton.title = `Kick ${user.name}`;
 kickButton.innerHTML = `
 <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"></path>
 </svg>
 `;
 kickButton.onclick = (e) => {
 e.stopPropagation();
 kickUser(userId, user.name);
 };

 controlsContainer.appendChild(muteVideoButton);
 controlsContainer.appendChild(muteAudioButton);
 controlsContainer.appendChild(makeHostButton);
 controlsContainer.appendChild(kickButton);
 userItem.appendChild(controlsContainer);
 }

 usersList.appendChild(userItem);
 });
 }

 function initializeUsersTooltip() {
 const activeUsersElement = document.getElementById('active-users');

 if (!activeUsersElement) {
 console.log('Active users element not found');
 return;
 }

 // Create tooltip element and append to body
 const usersTooltip = document.createElement('div');
 usersTooltip.id = 'users-tooltip';
 usersTooltip.className = 'fixed bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-600 rounded-xl shadow-xl p-5 min-w-72 max-w-96 opacity-0 pointer-events-none transition-all duration-300 ease-out scale-95';
 usersTooltip.style.zIndex = '999999';
 usersTooltip.innerHTML = `
 <!-- Tooltip arrow pointing up -->
 <div class="absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-8 border-r-8 border-b-8 border-transparent border-b-white dark:border-b-slate-800"></div>
 <div class="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-3">Active Users</div>
 <div id="users-list" class="space-y-2">
 <!-- Users will be populated here -->
 </div>
 `;

 // Append to body to escape all container constraints
 document.body.appendChild(usersTooltip);

 let hoverTimeout;

 // Show tooltip on hover
 activeUsersElement.addEventListener('mouseenter', () => {
 clearTimeout(hoverTimeout);

 // Update users list before showing
 updateUsersTooltip();

 // Calculate position for fixed positioning
 const rect = activeUsersElement.getBoundingClientRect();
 const tooltipLeft = rect.left + (rect.width / 2);
 const tooltipTop = rect.bottom + 8; // 8px gap below the element

 usersTooltip.style.left = `${tooltipLeft}px`;
 usersTooltip.style.top = `${tooltipTop}px`;
 usersTooltip.style.transform = 'translateX(-50%) scale(1)';
 usersTooltip.style.opacity = '1';
 usersTooltip.style.pointerEvents = 'auto';
 });

 // Hide tooltip when leaving
 activeUsersElement.addEventListener('mouseleave', () => {
 hoverTimeout = setTimeout(() => {
 usersTooltip.style.opacity = '0';
 usersTooltip.style.transform = 'translateX(-50%) scale(0.95)';
 usersTooltip.style.pointerEvents = 'none';
 }, 150); // Small delay to prevent flickering
 });

 // Keep tooltip visible when hovering over it
 usersTooltip.addEventListener('mouseenter', () => {
 clearTimeout(hoverTimeout);
 });

 // Hide tooltip when leaving the tooltip itself
 usersTooltip.addEventListener('mouseleave', () => {
 usersTooltip.style.opacity = '0';
 usersTooltip.style.transform = 'translateX(-50%) scale(0.95)';
 usersTooltip.style.pointerEvents = 'none';
 });

 // Reposition tooltip on window resize if it's visible
 window.addEventListener('resize', () => {
 if (usersTooltip.style.opacity === '1') {
 const rect = activeUsersElement.getBoundingClientRect();
 const tooltipLeft = rect.left + (rect.width / 2);
 const tooltipTop = rect.bottom + 8;

 usersTooltip.style.left = `${tooltipLeft}px`;
 usersTooltip.style.top = `${tooltipTop}px`;
 }
 });
 }

 function loadCanvasState(state) {
 console.log('üîÑ Loading canvas state with', state.objects?.length || 0, 'objects');
 console.log('üé® Canvas state background:', state.background);
 console.log('üé® Canvas state pattern:', state.pattern);
 isProcessingRemoteOperation = true;

 fabricCanvas.clear();

 // Handle background patterns
 if (state.background === 'css_pattern' && state.pattern) {
 console.log('üé® Applying CSS pattern from canvas state:', state.pattern);

 // Set the current pattern for tracking
 currentCanvasPattern = state.pattern;

 // Generate and apply the pattern
 let cssPattern;
 switch (state.pattern.type) {
 case 'plain':
 cssPattern = {
 backgroundColor: state.pattern.backgroundColor,
 backgroundImage: '',
 backgroundSize: '',
 backgroundPosition: '',
 backgroundRepeat: ''
 };
 break;
 case 'boxes':
 cssPattern = generateBoxesPattern(
 state.pattern.backgroundColor,
 state.pattern.patternColor,
 state.pattern.opacity,
 state.pattern.scale
 );
 break;
 case 'polka':
 cssPattern = generatePolkaPattern(
 state.pattern.backgroundColor,
 state.pattern.patternColor,
 state.pattern.opacity,
 state.pattern.scale
 );
 break;
 case 'graph':
 cssPattern = generateGraphPattern(
 state.pattern.backgroundColor,
 state.pattern.patternColor,
 state.pattern.opacity,
 state.pattern.scale
 );
 break;
 case 'lines':
 cssPattern = generateLinesPattern(
 state.pattern.backgroundColor,
 state.pattern.patternColor,
 state.pattern.opacity,
 state.pattern.scale
 );
 break;
 default:
 console.error('‚ùå Unknown pattern type in canvas state:', state.pattern.type);
 fabricCanvas.backgroundColor = state.background || '#ffffff';
 }

 if (cssPattern) {
 applyCSSBackgroundToCanvas(cssPattern);
 console.log('‚úÖ CSS pattern applied from canvas state');
 }
 } else {
 // Regular solid background
 fabricCanvas.backgroundColor = state.background || '#ffffff';
 console.log('üé® Applied solid background:', fabricCanvas.backgroundColor);
 }

 if (state.objects && state.objects.length > 0) {
 const imageObjects = state.objects.filter(obj => obj.type === 'image');
 console.log('üñºÔ∏è Found', imageObjects.length, 'images in canvas state');

 let loadedObjectsCount = 0;
 const totalObjects = state.objects.length;

 state.objects.forEach((objData, index) => {
 console.log(`üì¶ Loading object ${index + 1}/${totalObjects}:`, objData.type, objData.id);

 // Special handling for images
 if (objData.type === 'image') {
 console.log('üñºÔ∏è Restoring image:', objData.id, 'size:', objData.width, 'x', objData.height);
 console.log('üñºÔ∏è Image position:', objData.left, objData.top, 'scale:', objData.scaleX, objData.scaleY);

 if (!objData.src) {
 console.error('‚ùå Image object has no src property:', objData.id);
 loadedObjectsCount++;
 if (loadedObjectsCount === totalObjects) {
 finishLoadingCanvasState();
 }
 return;
 }

 // Use fabric.Image.fromURL to properly load the image
 fabric.Image.fromURL(objData.src, function(img) {
 if (!img) {
 console.error('‚ùå Failed to restore image from URL:', objData.id);
 loadedObjectsCount++;
 if (loadedObjectsCount === totalObjects) {
 finishLoadingCanvasState();
 }
 return;
 }

 // Set all the properties from the saved object
 img.set({
 id: objData.id,
 left: objData.left,
 top: objData.top,
 scaleX: objData.scaleX || 1,
 scaleY: objData.scaleY || 1,
 angle: objData.angle || 0,
 originX: objData.originX || 'center',
 originY: objData.originY || 'center',
 selectable: objData.selectable !== false,
 evented: objData.evented !== false,
 visible: objData.visible !== false,
 opacity: objData.opacity || 1
 });

 fabricCanvas.add(img);

 // Force multiple renders to ensure visibility for restored images
 console.log('üîÑ Forcing canvas render for restored image visibility...');
 fabricCanvas.renderAll();

 // Additional render after a short delay
 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Secondary render completed for restored image');
 }, 10);

 console.log('‚úÖ Image restored successfully:', img.id);

 loadedObjectsCount++;
 if (loadedObjectsCount === totalObjects) {
 finishLoadingCanvasState();
 }

 }, function(img, isError) {
 console.error('‚ùå Error restoring image:', objData.id, isError);
 loadedObjectsCount++;
 if (loadedObjectsCount === totalObjects) {
 finishLoadingCanvasState();
 }
 }, {
 crossOrigin: 'anonymous'
 });

 } else {
 // Handle non-image objects with enlivenObjects
 fabric.util.enlivenObjects([objData], (objects) => {
 objects.forEach(obj => {
 fabricCanvas.add(obj);
 });

 loadedObjectsCount++;
 if (loadedObjectsCount === totalObjects) {
 finishLoadingCanvasState();
 }
 });
 }
 });

 } else {
 // No objects to load
 finishLoadingCanvasState();
 }

 function finishLoadingCanvasState() {
 fabricCanvas.renderAll();
 isProcessingRemoteOperation = false;

 // Final verification
 setTimeout(() => {
 const totalObjects = fabricCanvas.getObjects().length;
 const totalImages = fabricCanvas.getObjects().filter(obj => obj.type === 'image').length;
 console.log('‚úÖ Canvas state loaded:', totalObjects, 'total objects,', totalImages, 'images');

 // Run migration for legacy arrows
 migrateLegacyArrows();
 }, 100);
 }
 }

 function handleRemoteCanvasEvent(event, userId) {
 console.log('üì• Received canvas event:', event, 'from user:', userId);
 handleRemoteCanvasOperation(event, userId, 'websocket');
 }

 // Comprehensive remote canvas operation handler
 function handleRemoteCanvasOperation(operation, userId, source = 'websocket') {
 console.log(`üì• handleRemoteCanvasOperation called:`, {
 operation,
 userId,
 source,
 operationType: operation?.type,
 hasData: !!operation?.data
 });

 if (!operation || !operation.type) {
 console.error('‚ùå Invalid canvas operation received:', operation);
 return;
 }

 // Prevent processing our own operations
 if (operation.user_id === currentUserId) {
 console.log('‚è≠Ô∏è Skipping own operation from user:', operation.user_id);
 return;
 }

 console.log(`üì• Processing ${source} operation:`, operation.type, 'from user:', userId);

 isProcessingRemoteOperation = true;

 try {
 // Handle both new nested structure (operation.data) and old flat structure
 const eventData = operation.data || operation;

 switch (operation.type) {
 case 'selection_created':
 case 'selection_updated':
 handleRemoteSelection(eventData, userId);
 break;

 case 'selection_cleared':
 handleRemoteSelectionCleared(eventData, userId);
 break;

 case 'path_created':
 handleRemotePathCreated(eventData);
 break;

 case 'object_added':
 handleRemoteObjectAdded(eventData);
 break;

 case 'object_modified':
 handleRemoteObjectModified(eventData);
 break;

 case 'object_moving':
 handleRemoteObjectMoving(eventData);
 break;

 case 'object_scaling':
 handleRemoteObjectScaling(eventData);
 break;

 case 'object_rotating':
 handleRemoteObjectRotating(eventData);
 break;

 case 'object_removed':
 handleRemoteObjectRemoval(eventData);
 break;

 case 'canvas_cleared':
 handleRemoteCanvasCleared(eventData);
 break;

 case 'background_changed':
 handleRemoteBackgroundChanged(eventData);
 break;

 default:
 console.warn('Unknown operation type:', operation.type);
 }
 } catch (error) {
 console.error('Error processing remote operation:', error);
 } finally {
 // Restore flag after a short delay to ensure all related events are processed
 setTimeout(() => {
 isProcessingRemoteOperation = false;
 }, 10);
 }
 }

 // Remote operation handlers
 function handleRemoteSelection(data, userId) {
 console.log('üëÜ Remote selection from user:', userId, data);
 // Visual indication of remote user selection (optional)
 // Could show selection indicators for other users
 }

 function handleRemoteSelectionCleared(data, userId) {
 console.log('üëÜ Remote selection cleared from user:', userId);
 // Clear visual indicators for remote user selection
 }

 function handleRemotePathCreated(data) {
 console.log('üé® handleRemotePathCreated called with data:', data);
 if (data.path) {
 console.log('üé® Creating path from object:', data.path);

 // Check if path already exists to avoid duplicates
 const existingPath = fabricCanvas.getObjects().find(obj => obj.id === data.object_id);
 if (existingPath) {
 console.log('‚è≠Ô∏è Path already exists, skipping:', data.object_id);
 return;
 }

 fabric.Path.fromObject(data.path, (path) => {
 // Ensure the path has an ID
 path.id = data.object_id || generateObjectId();
 fabricCanvas.add(path);
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote path created successfully:', path.id);
 });
 } else {
 console.warn('‚ùå No path data in handleRemotePathCreated');
 }
 }

 function handleRemoteObjectAdded(data) {
 console.log('üé® handleRemoteObjectAdded called with data:', data);
 if (data.object) {
 // Skip paths since they're handled by handleRemotePathCreated
 if (data.object.type === 'path') {
 console.log('‚è≠Ô∏è Skipping path in handleRemoteObjectAdded (handled by handleRemotePathCreated)');
 return;
 }

 // Check if object already exists to avoid duplicates
 const existingObj = fabricCanvas.getObjects().find(obj => obj.id === data.object_id);
 if (existingObj) {
 console.log('‚è≠Ô∏è Object already exists, skipping:', data.object_id);
 return;
 }

 console.log('üé® Creating object from data:', data.object.type, data.object_id);

 // Special handling for new arrows
 if (data.object.type === 'arrow' || data.object.lineType === 'arrow') {
 console.log('üèπ Remote arrow received:', data.object_id);
 const arrow = new fabric.Arrow(data.object);
 arrow.id = data.object_id;
 fabricCanvas.add(arrow);
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote arrow created successfully:', arrow.id);
 return;
 }

 // Special handling for text objects
 if (data.object.type === 'i-text' || data.object.type === 'text') {
 console.log('üìù Remote text received:', data.object_id);
 }

 // Special handling for images - use fabric.Image.fromURL instead of enlivenObjects
 if (data.object.type === 'image') {
 console.log('üñºÔ∏è Remote image received:', data.object_id, 'src length:', data.object.src?.length || 0);
 console.log('üñºÔ∏è Image properties:', {
 left: data.object.left,
 top: data.object.top,
 width: data.object.width,
 height: data.object.height,
 scaleX: data.object.scaleX,
 scaleY: data.object.scaleY,
 visible: data.object.visible,
 opacity: data.object.opacity
 });

 if (!data.object.src) {
 console.error('‚ùå Remote image has no src property');
 return;
 }

 // Use fabric.Image.fromURL to properly load the image
 fabric.Image.fromURL(data.object.src, function(img) {
 if (!img) {
 console.error('‚ùå Failed to create remote image from URL');
 return;
 }

 // Set all the properties from the original object
 img.set({
 id: data.object_id,
 left: data.object.left,
 top: data.object.top,
 scaleX: data.object.scaleX || 1,
 scaleY: data.object.scaleY || 1,
 angle: data.object.angle || 0,
 originX: data.object.originX || 'center',
 originY: data.object.originY || 'center',
 selectable: data.object.selectable !== false,
 evented: data.object.evented !== false,
 visible: data.object.visible !== false,
 opacity: data.object.opacity || 1
 });

 fabricCanvas.add(img);

 // Function to ensure remote image is rendered properly
 function ensureRemoteImageRendered() {
 console.log('üîÑ Ensuring remote image is rendered...');

 // Check if image element is loaded
 const imgElement = img.getElement();
 if (imgElement && !imgElement.complete) {
 console.log('‚è≥ Remote image element not fully loaded, waiting...');
 imgElement.onload = function() {
 console.log('‚úÖ Remote image element loaded, rendering...');
 fabricCanvas.renderAll();
 };
 } else {
 console.log('‚úÖ Remote image element ready, rendering immediately...');
 fabricCanvas.renderAll();
 }

 // Force additional renders as fallback
 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Remote image fallback render 1 completed');
 }, 50);

 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Remote image fallback render 2 completed');
 }, 200);
 }

 // Ensure proper rendering
 ensureRemoteImageRendered();

 console.log('‚úÖ Remote image added successfully:', img.id);

 // Additional verification for images
 const canvasObjects = fabricCanvas.getObjects();
 const imageCount = canvasObjects.filter(o => o.type === 'image').length;
 console.log('üñºÔ∏è Total images on canvas:', imageCount);

 }, function(img, isError) {
 console.error('‚ùå Error loading remote image:', isError);
 }, {
 crossOrigin: 'anonymous'
 });

 return; // Exit early for images
 }

 // Handle non-image objects with enlivenObjects
 fabric.util.enlivenObjects([data.object], (objects) => {
 const obj = objects[0];
 if (obj) {
 // Ensure the object has an ID
 obj.id = data.object_id || generateObjectId();

 fabricCanvas.add(obj);
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote object added successfully:', obj.type, obj.id);
 } else {
 console.error('‚ùå Failed to enliven remote object:', data.object_id);
 }
 });
 } else {
 console.warn('‚ùå No object data in handleRemoteObjectAdded');
 }
 }

 function handleRemoteObjectModified(data) {
 if (data.object_id) {
 const existingObj = fabricCanvas.getObjects().find(obj => obj.id === data.object_id);
 if (existingObj && data.object) {

 // Special handling for images
 if (data.object.type === 'image') {
 console.log('üñºÔ∏è Remote image modified:', data.object_id);

 if (!data.object.src) {
 console.error('‚ùå Modified image has no src property');
 return;
 }

 // Use fabric.Image.fromURL to properly recreate the image
 fabric.Image.fromURL(data.object.src, function(img) {
 if (!img) {
 console.error('‚ùå Failed to recreate modified image from URL');
 return;
 }

 // Set all the properties from the modified object
 img.set({
 id: data.object_id,
 left: data.object.left,
 top: data.object.top,
 scaleX: data.object.scaleX || 1,
 scaleY: data.object.scaleY || 1,
 angle: data.object.angle || 0,
 originX: data.object.originX || 'center',
 originY: data.object.originY || 'center',
 selectable: data.object.selectable !== false,
 evented: data.object.evented !== false,
 visible: data.object.visible !== false,
 opacity: data.object.opacity || 1
 });

 fabricCanvas.remove(existingObj);
 fabricCanvas.add(img);

 // Force multiple renders to ensure visibility for modified images
 console.log('üîÑ Forcing canvas render for modified image visibility...');
 fabricCanvas.renderAll();

 // Additional render after a short delay
 setTimeout(() => {
 fabricCanvas.renderAll();
 console.log('üîÑ Secondary render completed for modified image');
 }, 10);

 console.log('‚úÖ Remote image modified successfully:', data.object_id);

 }, function(img, isError) {
 console.error('‚ùå Error recreating modified image:', data.object_id, isError);
 }, {
 crossOrigin: 'anonymous'
 });

 } else {
 // Handle non-image objects - preserve special properties like isAIHighlight
 console.log('üîÑ Processing remote object modification:', data.object_id, data.object.type);

 // For highlighter shapes, preserve the isAIHighlight property
 if (existingObj.isAIHighlight || data.object.isAIHighlight) {
 console.log('üé® Updating highlighter shape properties directly');

 // Update properties directly to preserve highlighter behavior
 existingObj.set({
 left: data.object.left,
 top: data.object.top,
 scaleX: data.object.scaleX || 1,
 scaleY: data.object.scaleY || 1,
 angle: data.object.angle || 0,
 fill: data.object.fill,
 stroke: data.object.stroke,
 strokeWidth: data.object.strokeWidth,
 opacity: data.object.opacity || 1,
 visible: data.object.visible !== false,
 isAIHighlight: true // Ensure this property is preserved
 });

 // For rectangles, update width/height
 if (existingObj.type === 'rect' && data.object.width !== undefined) {
 existingObj.set({
 width: data.object.width,
 height: data.object.height
 });
 }

 // For ellipses, update rx/ry
 if (existingObj.type === 'ellipse' && data.object.rx !== undefined) {
 existingObj.set({
 rx: data.object.rx,
 ry: data.object.ry
 });
 }

 existingObj.setCoords();
 fabricCanvas.renderAll();
 console.log('‚úÖ Highlighter shape updated directly:', data.object_id);

 } else {
 // Handle other objects with enlivenObjects
 fabric.util.enlivenObjects([data.object], (objects) => {
 const newObj = objects[0];
 if (newObj) {
 // Preserve the ID and update properties
 newObj.id = data.object_id;

 // If this is a highlighter shape, ensure it has the proper behavior
 if (data.object.isAIHighlight) {
 newObj.isAIHighlight = true;
 console.log('üé® Restored isAIHighlight property for remote object:', data.object_id);

 // Override toObject method to include isAIHighlight in future serializations
 newObj.toObject = (function(toObjectSuper) {
 return function(propertiesToInclude) {
 return fabric.util.object.extend(toObjectSuper.call(this, propertiesToInclude), {
 isAIHighlight: this.isAIHighlight
 });
 };
 })(newObj.toObject);
 }

 fabricCanvas.remove(existingObj);
 fabricCanvas.add(newObj);
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote object modified:', data.object_id);
 }
 });
 }
 }
 }
 }
 }

 function handleRemoteObjectMoving(data) {
 if (data.object_id && data.position) {
 const obj = fabricCanvas.getObjects().find(o => o.id === data.object_id);
 if (obj) {
 obj.set({
 left: data.position.left,
 top: data.position.top
 });
 obj.setCoords();
 fabricCanvas.renderAll();
 }
 }
 }

 function handleRemoteObjectScaling(data) {
 if (data.object_id && data.scale) {
 const obj = fabricCanvas.getObjects().find(o => o.id === data.object_id);
 if (obj) {
 obj.set({
 scaleX: data.scale.scaleX,
 scaleY: data.scale.scaleY
 });
 obj.setCoords();
 fabricCanvas.renderAll();
 }
 }
 }

 function handleRemoteObjectRotating(data) {
 if (data.object_id && data.angle !== undefined) {
 const obj = fabricCanvas.getObjects().find(o => o.id === data.object_id);
 if (obj) {
 obj.set('angle', data.angle);
 obj.setCoords();
 fabricCanvas.renderAll();
 }
 }
 }

 function handleRemoteObjectRemoval(data) {
 if (!data.object_id) {
 console.error('‚ùå Received object_removed without object_id');
 return;
 }

 const objToRemove = fabricCanvas.getObjects().find(obj => obj.id === data.object_id);
 if (objToRemove) {
 fabricCanvas.remove(objToRemove);
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote object removed:', data.object_id);
 } else {
 console.warn('‚ùå Object not found for removal:', data.object_id);
 }
 }

 function handleRemoteCanvasCleared(data) {
 fabricCanvas.clear();
 fabricCanvas.backgroundColor = data.background || (document.documentElement.classList.contains('dark') ? '#0f172a' : '#ffffff');
 fabricCanvas.renderAll();
 console.log('‚úÖ Remote canvas cleared');
 }

 function handleRemoteBackgroundChanged(data) {
 console.log('üé® Remote background change received:', data);
 console.log('üé® Current room ID:', currentRoomId);
 console.log('üé® Current user ID:', currentUserId);
 console.log('üé® Change from user:', data.changed_by);

 if (data.background === 'css_pattern' && data.pattern) {
 // Apply the same pattern that was set by the remote user
 console.log('üé® Applying remote CSS pattern:', data.pattern);

 // Update current pattern tracking
 currentCanvasPattern = data.pattern;

 // Apply the pattern using the same logic as local pattern changes
 let cssPattern;
 switch (data.pattern.type) {
 case 'plain':
 cssPattern = {
 backgroundColor: data.pattern.backgroundColor,
 backgroundImage: '',
 backgroundSize: '',
 backgroundPosition: '',
 backgroundRepeat: ''
 };
 break;
 case 'boxes':
 cssPattern = generateBoxesPattern(data.pattern.backgroundColor, data.pattern.patternColor, data.pattern.opacity, data.pattern.scale);
 break;
 case 'polka':
 cssPattern = generatePolkaPattern(data.pattern.backgroundColor, data.pattern.patternColor, data.pattern.opacity, data.pattern.scale);
 break;
 case 'graph':
 cssPattern = generateGraphPattern(data.pattern.backgroundColor, data.pattern.patternColor, data.pattern.opacity, data.pattern.scale);
 break;
 case 'lines':
 cssPattern = generateLinesPattern(data.pattern.backgroundColor, data.pattern.patternColor, data.pattern.opacity, data.pattern.scale);
 break;
 default:
 console.error('‚ùå Unknown remote pattern type:', data.pattern.type);
 return;
 }

 if (cssPattern) {
 // Use the same logic as applyCSSBackgroundToCanvas
 applyCSSBackgroundToCanvas(cssPattern);
 console.log('‚úÖ Remote pattern applied successfully');
 }
 } else if (data.background && data.background !== 'css_pattern') {
 // Handle solid color background changes
 console.log('üé® Applying remote solid background:', data.background);

 // Clear any CSS patterns
 const canvasElement = document.querySelector('.upper-canvas') || document.querySelector('canvas');
 if (canvasElement) {
 canvasElement.style.backgroundImage = '';
 canvasElement.style.backgroundColor = '';
 canvasElement.style.backgroundSize = '';
 canvasElement.style.backgroundPosition = '';
 canvasElement.style.backgroundRepeat = '';
 }

 // Set solid background
 fabricCanvas.setBackgroundColor(data.background);
 fabricCanvas.renderAll();
 currentCanvasPattern = null;

 console.log('‚úÖ Remote solid background applied successfully');
 }
 }

 // Enhanced WebRTC Data Channel message handler
function handleWebRTCMessage(message, userId) {
    try {
        const data = JSON.parse(message);
        console.log('üì° Received WebRTC message from', userId, ':', data);

        if (data.type === 'canvas_operation') {
            handleRemoteCanvasOperation(data.operation, userId, 'webrtc');
        } else if (data.type === 'host_broadcast_ai_message') {
            handleIncomingBroadcastAiMessage(data);
        }
    } catch (error) {
        console.error('‚ùå Error parsing WebRTC message:', error);
    }
}

 // Generate unique object ID
 function generateObjectId() {
 return `${currentUserId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
 }

 // Copy selected objects to clipboard
 function copySelectedObjects() {
 const activeObjects = fabricCanvas.getActiveObjects();

 if (activeObjects.length === 0) {
 console.log('üìã No objects selected to copy');
 return false;
 }

 console.log(`üìã Copying ${activeObjects.length} selected objects`);

 // Clear previous copied objects
 copiedObjects = [];

 // Serialize each selected object
 activeObjects.forEach(obj => {
 const serialized = obj.toObject();
 // Store additional properties needed for proper pasting
 serialized.originalLeft = obj.left;
 serialized.originalTop = obj.top;
 serialized.originalId = obj.id;
 copiedObjects.push(serialized);
 });

 console.log('üìã Objects copied to clipboard:', copiedObjects.length);

 return true;
 }

 // Paste copied objects to canvas at cursor position
 function pasteObjects() {
 if (copiedObjects.length === 0) {
 console.log('üìã No objects in clipboard to paste');
 return false;
 }

 // Determine target position from lastMousePosition
 const hasCursor = typeof lastMousePosition?.x === 'number' && typeof lastMousePosition?.y === 'number' && (lastMousePosition.x !== 0 || lastMousePosition.y !== 0);
 const targetX = hasCursor ? lastMousePosition.x : null;
 const targetY = hasCursor ? lastMousePosition.y : null;

 // Compute average original position (rough center) of copied objects
 let avgLeft = 0, avgTop = 0;
 copiedObjects.forEach(obj => {
 const l = (obj.originalLeft != null ? obj.originalLeft : obj.left) || 0;
 const t = (obj.originalTop != null ? obj.originalTop : obj.top) || 0;
 avgLeft += l; avgTop += t;
 });
 avgLeft /= copiedObjects.length;
 avgTop  /= copiedObjects.length;

 // dx, dy to place average at cursor (fallback to simple paste offset if no cursor)
 const dx = (targetX != null ? targetX - avgLeft : pasteOffset);
 const dy = (targetY != null ? targetY - avgTop  : pasteOffset);

 console.log(`üìã Pasting ${copiedObjects.length} objects at`, hasCursor ? `cursor (${targetX.toFixed(1)}, ${targetY.toFixed(1)})` : 'default offset');

 const pastedObjects = [];
 let processedCount = 0;

 copiedObjects.forEach((objData, index) => {
 const baseLeft = (objData.originalLeft != null ? objData.originalLeft : objData.left) || 0;
 const baseTop  = (objData.originalTop  != null ? objData.originalTop  : objData.top)  || 0;

 const newObjData = JSON.parse(JSON.stringify(objData));
 newObjData.id = generateObjectId();
 newObjData.left = baseLeft + dx;
 newObjData.top  = baseTop  + dy;

 // Clean original metadata
 delete newObjData.originalLeft;
 delete newObjData.originalTop;
 delete newObjData.originalId;

 fabric.util.enlivenObjects([newObjData], (objects) => {
 const newObj = objects[0];
 if (newObj) {
 newObj.id = newObjData.id;
 fabricCanvas.add(newObj);
 pastedObjects.push(newObj);

 // Sync
 sendCanvasOperation('object_added', {
 object: newObj.toObject(),
 object_id: newObj.id
 });
 console.log(`üìã Pasted object ${index + 1}/${copiedObjects.length}: ${newObj.type} (ID: ${newObj.id})`);
 }

 processedCount++;
 if (processedCount === copiedObjects.length) {
 fabricCanvas.renderAll();

 // Select pasted objects
 if (pastedObjects.length > 1) {
 const selection = new fabric.ActiveSelection(pastedObjects, { canvas: fabricCanvas });
 fabricCanvas.setActiveObject(selection);
 } else if (pastedObjects.length === 1) {
 fabricCanvas.setActiveObject(pastedObjects[0]);
 }
 fabricCanvas.requestRenderAll();

 // Increase paste offset if we had no cursor, otherwise leave offset alone
 if (!hasCursor) {
 pasteOffset += 20; if (pasteOffset > 100) pasteOffset = 20;
 }
 }
 });
 });

 return true;
 }

// Expose clipboard functions globally (for radial/keyboard interop)
window.copySelectedObjects = copySelectedObjects;
window.pasteObjects = pasteObjects;




 // Enhanced canvas operation sender with WebRTC + WebSocket fallback
 function sendCanvasOperation(operationType, data = {}, priority = 'normal') {
 if (!currentRoomId || isProcessingRemoteOperation) {
 return false;
 }

 const operation = {
 id: generateObjectId(),
 type: operationType,
 timestamp: Date.now(),
 priority,
 data,
 user_id: currentUserId
 };

 console.log(`üöÄ Sending ${priority} canvas operation:`, operation);

 let sentViaWebRTC = false;

 // For high-priority operations (real-time movement), try WebRTC first
 if (priority === 'high' && dataChannels.size > 0) {
 dataChannels.forEach((channel, userId) => {
 if (channel.readyState === 'open') {
 try {
 channel.send(JSON.stringify({
 type: 'canvas_operation',
 operation
 }));
 sentViaWebRTC = true;
 console.log(`‚úÖ Sent via WebRTC to user ${userId}`);
 } catch (error) {
 console.warn(`‚ö†Ô∏è WebRTC send failed to user ${userId}:`, error);
 }
 }
 });
 }

 // Always send via WebSocket as primary or backup
 const websocketSuccess = sendCanvasEvent(operationType, data);

 if (sentViaWebRTC || websocketSuccess) {
 // Store operation for potential retry
 pendingOperations.set(operation.id, operation);

 // Clean up old operations
 setTimeout(() => {
 pendingOperations.delete(operation.id);
 }, 5000);

 return true;
 }

 return false;
 }

 // Setup WebRTC data channel for a peer connection
 function setupDataChannel(peerConnection, userId) {
 try {
 const dataChannel = peerConnection.createDataChannel('objectOperations', {
 ordered: true,
 maxRetransmits: 3
 });

 dataChannel.onopen = () => {
 console.log('‚úÖ Data channel opened for user:', userId);
 dataChannels.set(userId, dataChannel);
 };

 dataChannel.onclose = () => {
 console.log('‚ùå Data channel closed for user:', userId);
 dataChannels.delete(userId);
 };

 dataChannel.onmessage = (event) => {
 handleWebRTCMessage(event.data, userId);
 };

 dataChannel.onerror = (error) => {
 console.error('‚ùå Data channel error for user', userId, ':', error);
 };

 // Handle incoming data channels
 peerConnection.ondatachannel = (event) => {
 const channel = event.channel;
 console.log('üì° Received data channel from user:', userId);

 channel.onopen = () => {
 console.log('‚úÖ Incoming data channel opened for user:', userId);
 dataChannels.set(userId, channel);
 };

 channel.onmessage = (event) => {
 handleWebRTCMessage(event.data, userId);
 };

 channel.onclose = () => {
 console.log('‚ùå Incoming data channel closed for user:', userId);
 dataChannels.delete(userId);
 };
 };

 return dataChannel;
 } catch (error) {
 console.error('‚ùå Error setting up data channel:', error);
 return null;
 }
 }



 function sendCanvasEvent(eventType, data = {}) {
 console.log('üöÄ sendCanvasEvent called:', {
 eventType,
 data,
 hasSocket: !!collaborationSocket,
 socketState: collaborationSocket?.readyState,
 currentRoomId,
 isProcessingRemoteOperation
 });

 if (!collaborationSocket) {
 console.error('‚ùå No collaboration socket available');
 return false;
 }

 if (collaborationSocket.readyState !== WebSocket.OPEN) {
 console.error('‚ùå WebSocket not open, state:', collaborationSocket.readyState);
 return false;
 }

 if (!currentRoomId) {
 console.error('‚ùå Not in a room, cannot send canvas event');
 return false;
 }

 if (isProcessingRemoteOperation) {
 console.warn('‚ö†Ô∏è Currently processing remote operation, skipping send to prevent loop');
 return false;
 }

 const eventData = {
 type: 'canvas_event',
 event: {
 type: eventType,
 timestamp: Date.now(),
 ...data
 }
 };

 console.log('‚úÖ Sending canvas event:', eventData);
 try {
 collaborationSocket.send(JSON.stringify(eventData));
 console.log('‚úÖ Canvas event sent successfully');
 return true;
 } catch (error) {
 console.error('‚ùå Error sending canvas event:', error);
 return false;
 }
 }

 function updateUserCursor(userId, x, y) {
 console.log('Updating cursor for user:', userId, 'at position:', x, y);
 const user = roomUsers.get(userId);
 if (!user) {
 console.log('User not found in roomUsers:', userId);
 return;
 }

 let cursor = document.getElementById(`cursor-${userId}`);
 if (!cursor) {
 console.log('Creating new cursor for user:', userId);
 cursor = document.createElement('div');
 cursor.id = `cursor-${userId}`;
 cursor.className = 'absolute pointer-events-none z-50 transition-all duration-100';
 cursor.innerHTML = `
 <div class="flex items-center space-x-1">
 <div class="w-4 h-4 bg-indigo-500 rounded-full border-2 border-white shadow-lg"></div>
 <span class="text-xs bg-indigo-500 text-white px-2 py-1 rounded shadow-lg">${user.name}</span>
 </div>
 `;
 userCursors.appendChild(cursor);
 }

 const canvasRect = mainCanvasEl.getBoundingClientRect();
 const left = canvasRect.left + x * currentZoom;
 const top = canvasRect.top + y * currentZoom;
 console.log('Setting cursor position:', left, top);
 cursor.style.left = left + 'px';
 cursor.style.top = top + 'px';
 }

 function removeUserCursor(userId) {
 const cursor = document.getElementById(`cursor-${userId}`);
 if (cursor) {
 cursor.remove();
 }
 }

 function clearUserCursors() {
 userCursors.innerHTML = '';
 }

 function sendCursorPosition(x, y) {
 if (!collaborationSocket || !currentRoomId) {
 console.log('Cursor not sent - socket:', !!collaborationSocket, 'room:', currentRoomId);
 return;
 }

 console.log('Sending cursor position:', x, y);
 collaborationSocket.send(JSON.stringify({
 type: 'cursor_move',
 x: x,
 y: y
 }));
 }











 // --- Video Call Event Handlers ---
 const startVideoCallBtn = document.getElementById('start-video-call-btn');
 const leaveCallBtn = document.getElementById('leave-call-btn');
 const videoMinimizeBtn = document.getElementById('video-minimize-btn');
 const videoResizeHandle = document.getElementById('video-resize-handle');

 startVideoCallBtn.addEventListener('click', async () => {
 if (!currentRoomId) {
 alert('Please join a collaboration room first to start a video call.');
 return;
 }

 if (isVideoCallActive) {
 alert('Video call is already active.');
 return;
 }

 try {
 const success = await videoCallManager.startCall(currentRoomId);
 if (success) {
 console.log('Video call started successfully');
 } else {
 alert('Failed to start video call. Please try again.');
 }
 } catch (error) {
 console.error('Error starting video call:', error);
 alert('Failed to start video call. Please check your camera and microphone permissions.');
 }
 });

 leaveCallBtn.addEventListener('click', () => {
 videoCallManager.leaveCall();
 });

 videoMinimizeBtn.addEventListener('click', () => {
 videoCallManager.toggleMinimize();
 });

 // Video container resize functionality
 let isResizingVideo = false;
 let startY = 0;
 let startHeight = 0;

 videoResizeHandle.addEventListener('mousedown', (e) => {
 isResizingVideo = true;
 startY = e.clientY;
 const videoContainer = document.getElementById('video-call-container');
 startHeight = parseInt(document.defaultView.getComputedStyle(videoContainer).height, 10);
 document.addEventListener('mousemove', handleVideoResize);
 document.addEventListener('mouseup', stopVideoResize);
 e.preventDefault();
 });

 function handleVideoResize(e) {
 if (!isResizingVideo) return;

 const videoContainer = document.getElementById('video-call-container');
 const participantsContainer = document.getElementById('video-participants-container');
 const deltaY = e.clientY - startY;
 const newHeight = Math.max(100, Math.min(500, startHeight + deltaY));

 videoContainer.style.minHeight = newHeight + 'px';
 videoContainer.style.maxHeight = newHeight + 'px';
 participantsContainer.style.maxHeight = (newHeight - 60) + 'px'; // Account for header
 }

 function stopVideoResize() {
 isResizingVideo = false;
 document.removeEventListener('mousemove', handleVideoResize);
 document.removeEventListener('mouseup', stopVideoResize);
 }

 // Touch support for mobile
 videoResizeHandle.addEventListener('touchstart', (e) => {
 isResizingVideo = true;
 startY = e.touches[0].clientY;
 const videoContainer = document.getElementById('video-call-container');
 startHeight = parseInt(document.defaultView.getComputedStyle(videoContainer).height, 10);
 document.addEventListener('touchmove', handleVideoResizeTouch);
 document.addEventListener('touchend', stopVideoResizeTouch);
 e.preventDefault();
 });

 function handleVideoResizeTouch(e) {
 if (!isResizingVideo) return;

 const videoContainer = document.getElementById('video-call-container');
 const participantsContainer = document.getElementById('video-participants-container');
 const deltaY = e.touches[0].clientY - startY;
 const newHeight = Math.max(100, Math.min(500, startHeight + deltaY));

 videoContainer.style.minHeight = newHeight + 'px';
 videoContainer.style.maxHeight = newHeight + 'px';
 participantsContainer.style.maxHeight = (newHeight - 60) + 'px';
 }

 function stopVideoResizeTouch() {
 isResizingVideo = false;
 document.removeEventListener('touchmove', handleVideoResizeTouch);
 document.removeEventListener('touchend', stopVideoResizeTouch);
 }

 // --- Collaboration Event Handlers ---
 createRoomBtn.addEventListener('click', () => {
 // Ask for display name first
 const userName = prompt('Enter your display name:');
 if (!userName || !userName.trim()) {
 alert('Display name is required to create a room');
 return;
 }

 // Store the name
 localStorage.setItem('userName', userName.trim());

 // Update user name on server if already connected
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'update_name',
 name: userName.trim()
 }));
 }

 createRoomModal.classList.remove('hidden');
 document.getElementById('room-name-input').focus();
 });

 joinRoomBtn.addEventListener('click', () => {
 // Ask for display name first if not already stored
 const storedName = localStorage.getItem('userName');
 if (!storedName || storedName === 'Anonymous') {
 const userName = prompt('Enter your display name:');
 if (!userName || !userName.trim()) {
 alert('Display name is required to join a room');
 return;
 }

 // Store the name
 localStorage.setItem('userName', userName.trim());

 // Update user name on server if already connected
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'update_name',
 name: userName.trim()
 }));
 }
 }

 joinRoomModal.classList.remove('hidden');
 // Pre-populate name field with stored name
 const currentName = localStorage.getItem('userName');
 if (currentName) {
 document.getElementById('user-name-input').value = currentName;
 }
 document.getElementById('room-id-input').focus();
 });

 leaveRoomBtn.addEventListener('click', () => {
 if (collaborationSocket && currentRoomId) {
 // Stop video call if active before leaving room
 if (videoCallManager.isActive) {
 console.log('Stopping video call before leaving room');
 videoCallManager.leaveCall();
 }

 collaborationSocket.send(JSON.stringify({
 type: 'leave_room'
 }));
 }
 });

 // Modal event handlers
 document.getElementById('cancel-create-room').addEventListener('click', () => {
 createRoomModal.classList.add('hidden');
 });

 document.getElementById('cancel-join-room').addEventListener('click', () => {
 joinRoomModal.classList.add('hidden');
 });

 document.getElementById('confirm-create-room').addEventListener('click', () => {
 const roomName = document.getElementById('room-name-input').value;
 const maxUsers = parseInt(document.getElementById('max-users-select').value);

 // Ensure user has a proper name before creating room
 const currentName = localStorage.getItem('userName');
 if (!currentName || currentName === 'Anonymous') {
 const userName = prompt('Please enter your display name:');
 if (userName && userName.trim()) {
 localStorage.setItem('userName', userName.trim());
 // Update name on server
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'update_name',
 name: userName.trim()
 }));
 }
 } else {
 alert('Display name is required to create a room');
 return;
 }
 }

 if (collaborationSocket) {
 // Capture current canvas state before creating room
 const currentCanvasState = {
 objects: [],
 background: fabricCanvas.backgroundColor || '#ffffff'
 };

 // Include pattern data if there's a CSS pattern applied
 if (currentCanvasPattern) {
 currentCanvasState.background = 'css_pattern';
 currentCanvasState.pattern = currentCanvasPattern;
 console.log('üé® Including pattern data in room creation:', currentCanvasPattern);
 }

 // Get all objects from the canvas and ensure they have IDs
 fabricCanvas.getObjects().forEach(obj => {
 if (obj.toObject) {
 // Ensure object has an ID
 if (!obj.id) {
 obj.id = generateObjectId();
 console.log('üÜî Generated ID for existing object:', obj.type, obj.id);
 }

 const objData = obj.toObject();
 objData.id = obj.id; // Ensure ID is included in serialized data
 currentCanvasState.objects.push(objData);
 }
 });

 console.log('üé® Sending canvas state with room creation:', {
 objectCount: currentCanvasState.objects.length,
 background: currentCanvasState.background,
 hasPattern: !!currentCanvasState.pattern,
 patternType: currentCanvasState.pattern?.type
 });

 collaborationSocket.send(JSON.stringify({
 type: 'create_room',
 room_name: roomName,
 max_users: maxUsers,
 initial_canvas_state: currentCanvasState
 }));
 }

 createRoomModal.classList.add('hidden');
 document.getElementById('room-name-input').value = '';
 });

 document.getElementById('confirm-join-room').addEventListener('click', () => {
 const roomId = document.getElementById('room-id-input').value.trim().toUpperCase();
 const userName = document.getElementById('user-name-input').value.trim();

 if (!roomId) {
 alert('Please enter a room ID');
 return;
 }

 if (!userName) {
 alert('Please enter your display name');
 return;
 }

 // Update stored user name
 localStorage.setItem('userName', userName);

 // Update user name on server if already connected
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'update_name',
 name: userName
 }));

 // Small delay to ensure name update is processed before joining room
 setTimeout(() => {
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: roomId
 }));
 }, 100);
 } else {
 // If not connected, connect first then join
 connectToCollaborationServer();
 setTimeout(() => {
 if (collaborationSocket && collaborationSocket.readyState === WebSocket.OPEN) {
 collaborationSocket.send(JSON.stringify({
 type: 'join_room',
 room_id: roomId
 }));
 }
 }, 500);
 }

 joinRoomModal.classList.add('hidden');
 document.getElementById('room-id-input').value = '';
 document.getElementById('user-name-input').value = '';
 });

 // Close modals when clicking outside
 createRoomModal.addEventListener('click', (e) => {
 if (e.target === createRoomModal) {
 createRoomModal.classList.add('hidden');
 }
 });

 joinRoomModal.addEventListener('click', (e) => {
 if (e.target === joinRoomModal) {
 joinRoomModal.classList.add('hidden');
 }
 });

 // --- Image Modal Functions ---
 function openImageModal(imageUrl, imageName) {
 const modal = document.getElementById('image-modal');
 const modalImg = document.getElementById('image-modal-img');
 const modalTitle = document.getElementById('image-modal-title');
 const modalDownload = document.getElementById('image-modal-download');

 modalImg.src = imageUrl;
 modalImg.alt = imageName;
 modalTitle.textContent = imageName;
 modalDownload.href = imageUrl;
 modalDownload.download = imageName;

 modal.classList.remove('hidden');
 }

 function closeImageModal() {
 const modal = document.getElementById('image-modal');
 modal.classList.add('hidden');
 }

 // Image modal event listeners
 document.getElementById('close-image-modal').addEventListener('click', closeImageModal);
 document.getElementById('close-image-modal-btn').addEventListener('click', closeImageModal);

 // Close modal when clicking outside the image
 document.getElementById('image-modal').addEventListener('click', (e) => {
 if (e.target.id === 'image-modal') {
 closeImageModal();
 }
 });

 // Close modal with Escape key
 document.addEventListener('keydown', (e) => {
 if (e.key === 'Escape') {
 const modal = document.getElementById('image-modal');
 if (!modal.classList.contains('hidden')) {
 closeImageModal();
 }

 // Also close video popup modal
 const videoModal = document.getElementById('video-popup-modal');
 if (videoModal && videoModal.classList.contains('show')) {
 closeVideoPopup();
 }
 }
 });

 // --- Kick Notification Modal Functions ---
 function showKickNotification(kickedBy, roomId) {
 const modal = document.getElementById('kick-notification-modal');
 const messageElement = document.getElementById('kick-notification-message');

 if (!modal || !messageElement) {
 console.error('Kick notification modal elements not found');
 return;
 }

 // Set the message with more emphasis
 messageElement.innerHTML = `You have been <strong>removed from the room</strong> by <strong class="text-red-600 dark:text-red-400">${kickedBy}</strong>.`;

 // Store room ID for potential rejoin
 modal.setAttribute('data-room-id', roomId);

 // Show the modal
 modal.classList.remove('hidden');

 // Add shake animation to the modal content
 const modalContent = modal.querySelector('.bg-white');
 if (modalContent) {
 modalContent.classList.add('kick-notification-shake');
 setTimeout(() => {
 modalContent.classList.remove('kick-notification-shake');
 }, 600);
 }

 // Prevent body scroll
 document.body.style.overflow = 'hidden';

 // Play a notification sound if available
 try {
 const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
 audio.volume = 0.3;
 audio.play().catch(() => {}); // Ignore errors if audio fails
 } catch (e) {
 // Ignore audio errors
 }
 }

 function hideKickNotification() {
 const modal = document.getElementById('kick-notification-modal');
 if (!modal) return;

 // Hide the modal
 modal.classList.add('hidden');

 // Restore body scroll
 document.body.style.overflow = '';
 }

 // --- Video Popup Modal Functions ---
 function openVideoPopup(videoElement, participantName, isLocal = false) {
 const modal = document.getElementById('video-popup-modal');
 const popupVideo = document.getElementById('video-popup-video');
 const popupTitle = document.getElementById('video-popup-title');

 if (!modal || !popupVideo || !popupTitle) {
 console.error('Video popup elements not found');
 return;
 }

 // Set the title
 popupTitle.textContent = isLocal ? `You (${participantName})` : participantName;

 // Clone the video stream
 if (videoElement.srcObject) {
 popupVideo.srcObject = videoElement.srcObject;
 popupVideo.muted = isLocal; // Mute local video to prevent feedback
 } else {
 console.error('No video stream found');
 return;
 }

 // Show the modal with animation
 modal.classList.add('show');

 // Prevent body scroll
 document.body.style.overflow = 'hidden';
 }

 function closeVideoPopup() {
 const modal = document.getElementById('video-popup-modal');
 const popupVideo = document.getElementById('video-popup-video');

 if (!modal || !popupVideo) return;

 // Hide the modal with animation
 modal.classList.remove('show');

 // Clear the video stream
 popupVideo.srcObject = null;

 // Restore body scroll
 document.body.style.overflow = '';
 }

 // Kick notification modal event listeners
 document.getElementById('kick-notification-close').addEventListener('click', hideKickNotification);

 // Close kick notification modal when clicking outside
 document.getElementById('kick-notification-modal').addEventListener('click', (e) => {
 if (e.target.id === 'kick-notification-modal') {
 hideKickNotification();
 }
 });

 // Video popup event listeners
 document.getElementById('video-popup-close').addEventListener('click', closeVideoPopup);

 // Close modal when clicking outside the video container
 document.getElementById('video-popup-modal').addEventListener('click', (e) => {
 if (e.target.id === 'video-popup-modal') {
 closeVideoPopup();
 }
 });

 // Function to add double-click functionality to video containers
 function addVideoDoubleClickHandler(videoContainer, videoElement, participantName, isLocal = false) {
 if (!videoContainer || !videoElement) return;

 // Add clickable class for hover effects
 videoContainer.classList.add('video-container-clickable');

 // Add double-click event listener
 videoContainer.addEventListener('dblclick', (e) => {
 e.preventDefault();
 e.stopPropagation();
 openVideoPopup(videoElement, participantName, isLocal);
 });

 // Add single click feedback (optional)
 videoContainer.addEventListener('click', (e) => {
 e.preventDefault();
 e.stopPropagation();
 // Add a subtle click effect
 videoContainer.style.transform = 'scale(0.98)';
 setTimeout(() => {
 videoContainer.style.transform = '';
 }, 100);
 });
 }

 // --- AI Chat Image Functions ---
 function showAiChatImagePreview(imageDataUrl) {
 aiChatPreviewImg.src = imageDataUrl;
 aiChatImagePreview.classList.remove('hidden');
 aiChatAttachedImage = imageDataUrl;
 }

 function hideAiChatImagePreview() {
 aiChatImagePreview.classList.add('hidden');
 aiChatPreviewImg.src = '';
 aiChatAttachedImage = null;
 }

 // Remove image button event listener
 aiChatRemoveImage.addEventListener('click', hideAiChatImagePreview);

 // AI Chat paste functionality
 chatInput.addEventListener('paste', (e) => {
 const items = e.clipboardData?.items;
 if (!items) return;

 for (let i = 0; i < items.length; i++) {
 const item = items[i];

 // Check if the item is an image
 if (item.type.indexOf('image') !== -1) {
 e.preventDefault(); // Prevent default paste behavior

 const file = item.getAsFile();
 const reader = new FileReader();

 reader.onload = (event) => {
 showAiChatImagePreview(event.target.result);
 };

 reader.readAsDataURL(file);
 break; // Only handle the first image
 }
 }
 });

 // --- Group Messaging Event Handlers ---
 // Note: Room joining/leaving is now handled automatically through collaboration system

 function sendGroupMessage() {
 const message = groupMessageInput.value.trim();
 if (!message || !currentGroupRoomId || !groupMessageSocket) {
 return;
 }

 const messageData = {
 type: 'send_message',
 content: message
 };

 // Add reply data if replying to a message
 if (currentGroupReply) {
 messageData.replyTo = {
 id: currentGroupReply.id,
 sender_name: currentGroupReply.sender_name,
 content: currentGroupReply.content
 };

 }

 groupMessageSocket.send(JSON.stringify(messageData));

 groupMessageInput.value = '';
 clearGroupReply(); // Clear reply context after sending
 }

 groupSendButton.addEventListener('click', sendGroupMessage);
 groupMessageInput.addEventListener('keypress', (e) => {
 if (e.key === 'Enter' && !e.shiftKey) {
 e.preventDefault();
 sendGroupMessage();
 }
 });

 // Mute notifications button
 if (muteNotificationsBtn) {
 muteNotificationsBtn.addEventListener('click', toggleNotifications);
 }

 // File upload functionality
 fileUploadButton.addEventListener('click', () => {
 fileUploadInput.click();
 });

 fileUploadInput.addEventListener('change', (e) => {
 const files = e.target.files;
 if (files.length === 0 || !currentGroupRoomId || !groupMessageSocket) {
 return;
 }

 for (let file of files) {
 const reader = new FileReader();
 reader.onload = (event) => {
 const base64Data = event.target.result.split(',')[1];
 groupMessageSocket.send(JSON.stringify({
 type: 'upload_file',
 file_data: base64Data,
 file_name: file.name,
 file_type: file.type
 }));
 };
 reader.readAsDataURL(file);
 }

 // Clear the input
 fileUploadInput.value = '';
 });

 // Clipboard paste functionality for files
 document.addEventListener('paste', (e) => {
 if (activeTab !== 'group-message' || !currentGroupRoomId || !groupMessageSocket || document.activeElement !== groupMessageInput) {
 return;
 }

 const items = e.clipboardData.items;
 for (let item of items) {
 if (item.type.indexOf('image') !== -1) {
 const file = item.getAsFile();
 const reader = new FileReader();
 reader.onload = (event) => {
 const base64Data = event.target.result.split(',')[1];
 groupMessageSocket.send(JSON.stringify({
 type: 'upload_file',
 file_data: base64Data,
 file_name: `pasted-image-${Date.now()}.png`,
 file_type: 'image/png'
 }));
 };
 reader.readAsDataURL(file);
 break;
 }
 }
 });

 // Group messaging will connect automatically when joining collaboration rooms

 // Initialize group messaging UI
 initializeGroupMessagingUI();

 // Setup scroll listeners for intelligent auto-scroll
 setupScrollListeners();

 // --- PDF Viewer Functions ---
 function initializePdfViewer() {
 console.log('Initializing PDF viewer...');
 pdfContainer = pdfContainerElement;

 // PDF upload button event
 if (pdfUploadButton && pdfFileInput) {
 pdfUploadButton.addEventListener('click', () => {
 console.log('PDF upload button clicked');
 pdfFileInput.click();
 });
 console.log('PDF upload button event listener added');
 } else {
 console.error('PDF upload elements not found:', { pdfUploadButton, pdfFileInput });
 }

 // File input change event
 if (pdfFileInput) {
 pdfFileInput.addEventListener('change', (e) => {
 console.log('PDF file input changed', e.target.files);
 const file = e.target.files[0];
 if (file && file.type === 'application/pdf') {
 console.log('Loading PDF file:', file.name);
 loadPdfFile(file);
 } else {
 console.error('Invalid file type or no file selected:', file);
 alert('Please select a valid PDF file.');
 }
 });
 console.log('PDF file input event listener added');
 }

 // Drag and drop functionality
 const pdfUploadSection = document.getElementById('pdf-upload-section');
 if (pdfUploadSection) {
 pdfUploadSection.addEventListener('dragover', (e) => {
 e.preventDefault();
 pdfUploadSection.classList.add('bg-indigo-50', 'dark:bg-indigo-900/20');
 });

 pdfUploadSection.addEventListener('dragleave', (e) => {
 e.preventDefault();
 pdfUploadSection.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/20');
 });

 pdfUploadSection.addEventListener('drop', (e) => {
 e.preventDefault();
 pdfUploadSection.classList.remove('bg-indigo-50', 'dark:bg-indigo-900/20');

 const files = e.dataTransfer.files;
 if (files.length > 0 && files[0].type === 'application/pdf') {
 loadPdfFile(files[0]);
 } else {
 alert('Please drop a valid PDF file.');
 }
 });
 }

 // PDF controls
 if (pdfCloseButton) pdfCloseButton.addEventListener('click', closePdf);
 if (pdfPrevPage) pdfPrevPage.addEventListener('click', () => navigateToPage(currentPdfPage - 1));
 if (pdfNextPage) pdfNextPage.addEventListener('click', () => navigateToPage(currentPdfPage + 1));
 if (pdfPageInput) pdfPageInput.addEventListener('change', goToPage);
 if (pdfZoomIn) pdfZoomIn.addEventListener('click', () => {
 // Dynamic zoom step based on current zoom level
 const zoomStep = pdfZoomLevel < 1 ? 0.05 : (pdfZoomLevel < 5 ? 0.1 : 0.5);
 changeZoom(zoomStep);
 });
 if (pdfZoomOut) pdfZoomOut.addEventListener('click', () => {
 // Dynamic zoom step based on current zoom level
 const zoomStep = pdfZoomLevel <= 1 ? 0.05 : (pdfZoomLevel <= 5 ? 0.1 : 0.5);
 changeZoom(-zoomStep);
 });
 if (pdfFitWidth) pdfFitWidth.addEventListener('click', fitToWidth);

 // Enhanced mouse wheel zoom and pan
 if (pdfViewerArea) {
 pdfViewerArea.addEventListener('wheel', (e) => {
 if (e.ctrlKey || e.metaKey) {
 // Zoom with Ctrl/Cmd + wheel
 e.preventDefault();
 const rect = pdfViewerArea.getBoundingClientRect();
 const centerX = e.clientX - rect.left;
 const centerY = e.clientY - rect.top;
 // Dynamic zoom step based on current zoom level
 const zoomStep = pdfZoomLevel < 1 ? 0.05 : (pdfZoomLevel < 5 ? 0.1 : 0.5);
 const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
 changeZoomAtPoint(delta, centerX, centerY);
 } else {
 // Allow normal scrolling without Ctrl/Cmd
 // Browser handles this naturally, no need to prevent default
 }
 });

 // Pan functionality
 pdfViewerArea.addEventListener('mousedown', startPan);
 pdfViewerArea.addEventListener('mousemove', doPan);
 pdfViewerArea.addEventListener('mouseup', endPan);
 pdfViewerArea.addEventListener('mouseleave', endPan);

 // Touch/trackpad gesture support
 pdfViewerArea.addEventListener('touchstart', handleTouchStart, { passive: false });
 pdfViewerArea.addEventListener('touchmove', handleTouchMove, { passive: false });
 pdfViewerArea.addEventListener('touchend', handleTouchEnd, { passive: false });
 }

 // Initialize intersection observer for current page tracking
 initializePageObserver();
 }

 async function loadPdfFile(file) {
 try {
 console.log('Starting PDF load...');
 pdfLoading.style.display = 'flex';
 pdfViewerArea.classList.remove('hidden');

 const arrayBuffer = await file.arrayBuffer();

 // Create a copy of the ArrayBuffer for base64 encoding before PDF.js consumes it
 const arrayBufferCopy = arrayBuffer.slice();

 const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

 currentPdfDoc = pdf;
 totalPdfPages = pdf.numPages;
 currentPdfPage = 1;

 // Store PDF data for session export using the copy
 try {
 const uint8Array = new Uint8Array(arrayBufferCopy);
 // For large files, process in chunks to avoid "Maximum call stack size exceeded"
 if (uint8Array.length > 100000) {
 let binaryString = '';
 for (let i = 0; i < uint8Array.length; i += 8192) {
 const chunk = uint8Array.slice(i, i + 8192);
 binaryString += String.fromCharCode(...chunk);
 }
 currentPdfData = btoa(binaryString);
 } else {
 currentPdfData = btoa(String.fromCharCode(...uint8Array));
 }
 } catch (error) {
 console.error('Error encoding PDF data:', error);
 // Fallback: don't store PDF data for export if encoding fails
 currentPdfData = null;
 }
 currentPdfName = file.name;

 console.log(`PDF loaded: ${totalPdfPages} pages`);

 // Update UI
 pdfFilename.textContent = file.name;
 pdfInfo.textContent = `${totalPdfPages} pages`;
 pdfTotalPages.textContent = totalPdfPages;
 pdfPageInput.value = currentPdfPage;
 pdfPageInput.max = totalPdfPages;

 // Show loaded state
 pdfNotLoaded.classList.add('hidden');
 pdfLoaded.classList.remove('hidden');
 pdfControls.classList.remove('hidden');

 // Clear previous content
 pdfContainer.innerHTML = '';
 pdfPages = [];
 pageElements = [];

 // Render all pages
 await renderAllPages();
 updateNavigationButtons();

 pdfLoading.style.display = 'none';
 console.log('PDF rendering complete');

 // Auto-save after PDF loading (only when not in a room)
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 setTimeout(() => saveAppState(), 100);
 }
 if (!isApplyingBroadcastedPdf && currentPdfData) {
 maybeBroadcastPdfState('load', {
 pdf_name: currentPdfName,
 pdf_data: currentPdfData,
 current_page: currentPdfPage,
 total_pages: totalPdfPages
 });
 }
 } catch (error) {
 console.error('Error loading PDF:', error);
 pdfLoading.style.display = 'none';
 alert('Error loading PDF file. Please try again.');
 }
 }

 async function renderAllPages() {
 if (!currentPdfDoc) return;

 console.log('Rendering all pages...');

 for (let pageNum = 1; pageNum <= totalPdfPages; pageNum++) {
 try {
 const page = await currentPdfDoc.getPage(pageNum);
 const viewport = page.getViewport({ scale: pdfZoomLevel });

 // Create page container
 const pageDiv = document.createElement('div');
 pageDiv.className = 'pdf-page';
 pageDiv.dataset.pageNumber = pageNum;

 // Set explicit dimensions for better layout control
 pageDiv.style.width = viewport.width + 'px';
 pageDiv.style.height = (viewport.height + 30) + 'px'; // Extra space for page number

 // Create page number indicator
 const pageNumberDiv = document.createElement('div');
 pageNumberDiv.className = 'pdf-page-number';
 pageNumberDiv.textContent = `Page ${pageNum}`;
 pageNumberDiv.style.cssText = `
 position: absolute;
 bottom: 5px;
 left: 50%;
 transform: translateX(-50%);
 background: rgba(0, 0, 0, 0.7);
 color: white;
 padding: 2px 8px;
 border-radius: 4px;
 font-size: ${Math.max(10, 12 * pdfZoomLevel)}px;
 z-index: 10;
 `;
 pageDiv.appendChild(pageNumberDiv);

 // Create canvas for this page
 const canvas = document.createElement('canvas');
 const context = canvas.getContext('2d');

 canvas.width = viewport.width;
 canvas.height = viewport.height;
 canvas.style.width = viewport.width + 'px';
 canvas.style.height = viewport.height + 'px';

 const renderContext = {
 canvasContext: context,
 viewport: viewport
 };

 // Render the page
 await page.render(renderContext).promise;

 pageDiv.appendChild(canvas);
 pdfContainer.appendChild(pageDiv);

 // Store references
 pdfPages.push({ page, canvas, context, viewport });
 pageElements.push(pageDiv);

 console.log(`Rendered page ${pageNum}/${totalPdfPages}`);
 } catch (error) {
 console.error(`Error rendering page ${pageNum}:`, error);
 }
 }

 // Update page observer
 updatePageObserver();
 }

 // Pan functionality
 function startPan(e) {
 if (e.button !== 0) return; // Only left mouse button
 // Allow panning at any zoom level when content overflows
 const hasHorizontalScroll = pdfViewerArea.scrollWidth > pdfViewerArea.clientWidth;
 const hasVerticalScroll = pdfViewerArea.scrollHeight > pdfViewerArea.clientHeight;
 if (!hasHorizontalScroll && !hasVerticalScroll) return;

 isPdfPanning = true;
 panStart.x = e.clientX;
 panStart.y = e.clientY;
 scrollStart.x = pdfViewerArea.scrollLeft;
 scrollStart.y = pdfViewerArea.scrollTop;

 pdfViewerArea.classList.add('panning');
 e.preventDefault();
 }

 function doPan(e) {
 if (!isPdfPanning) return;

 const deltaX = e.clientX - panStart.x;
 const deltaY = e.clientY - panStart.y;

 pdfViewerArea.scrollLeft = scrollStart.x - deltaX;
 pdfViewerArea.scrollTop = scrollStart.y - deltaY;

 e.preventDefault();
 }

 function endPan() {
 if (isPdfPanning) {
 isPdfPanning = false;
 pdfViewerArea.classList.remove('panning');
 }
 }

 // Touch handling for mobile/trackpad gestures
 let touchStartDistance = 0;
 let touchStartZoom = 1.0;
 let touches = [];

 function handleTouchStart(e) {
 touches = Array.from(e.touches);

 if (touches.length === 2) {
 // Two-finger gesture (pinch to zoom)
 e.preventDefault();
 touchStartDistance = getTouchDistance(touches[0], touches[1]);
 touchStartZoom = pdfZoomLevel;
 } else if (touches.length === 1) {
 // Single finger (pan)
 const touch = touches[0];
 panStart.x = touch.clientX;
 panStart.y = touch.clientY;
 scrollStart.x = pdfViewerArea.scrollLeft;
 scrollStart.y = pdfViewerArea.scrollTop;
 isPdfPanning = true;
 pdfViewerArea.classList.add('panning');
 }
 }

 function handleTouchMove(e) {
 touches = Array.from(e.touches);

 if (touches.length === 2 && touchStartDistance > 0) {
 // Pinch to zoom
 e.preventDefault();
 const currentDistance = getTouchDistance(touches[0], touches[1]);
 const scale = currentDistance / touchStartDistance;
 const newZoom = Math.max(0.01, Math.min(50.0, touchStartZoom * scale));

 if (Math.abs(newZoom - pdfZoomLevel) > 0.05) {
 pdfZoomLevel = newZoom;
 // Format zoom display for better readability at extreme values
 if (pdfZoomLevel >= 10) {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel) + 'x';
 } else if (pdfZoomLevel < 0.1) {
 pdfZoomLevelDisplay.textContent = (pdfZoomLevel * 100).toFixed(1) + '%';
 } else {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel * 100) + '%';
 }
 rerenderAllPages();
 }
 } else if (touches.length === 1 && isPdfPanning) {
 // Pan with single finger
 e.preventDefault();
 const touch = touches[0];
 const deltaX = touch.clientX - panStart.x;
 const deltaY = touch.clientY - panStart.y;

 pdfViewerArea.scrollLeft = scrollStart.x - deltaX;
 pdfViewerArea.scrollTop = scrollStart.y - deltaY;
 }
 }

 function handleTouchEnd(e) {
 if (e.touches.length === 0) {
 isPdfPanning = false;
 pdfViewerArea.classList.remove('panning');
 touchStartDistance = 0;
 touches = [];
 }
 }

 function getTouchDistance(touch1, touch2) {
 const dx = touch1.clientX - touch2.clientX;
 const dy = touch1.clientY - touch2.clientY;
 return Math.sqrt(dx * dx + dy * dy);
 }

 function navigateToPage(pageNum) {
 if (pageNum >= 1 && pageNum <= totalPdfPages) {
 currentPdfPage = pageNum;
 pdfPageInput.value = currentPdfPage;

 // Scroll to the page
 const pageElement = pageElements[pageNum - 1];
 if (pageElement) {
 pageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
 }
 updateNavigationButtons();
 if (!isApplyingBroadcastedPdf) {
 maybeBroadcastPdfState('page_change', { current_page: currentPdfPage });
 }
 }
 }

 function goToPage() {
 const pageNum = parseInt(pdfPageInput.value);
 if (pageNum >= 1 && pageNum <= totalPdfPages) {
 navigateToPage(pageNum);
 }
 }

 function changeZoom(delta) {
 // Remove zoom limits - allow infinite zoom with reasonable bounds
 const newZoom = Math.max(0.01, Math.min(50.0, pdfZoomLevel + delta));
 if (newZoom !== pdfZoomLevel) {
 // Store current scroll position relative to content
 const scrollRatioX = pdfViewerArea.scrollLeft / (pdfViewerArea.scrollWidth - pdfViewerArea.clientWidth || 1);
 const scrollRatioY = pdfViewerArea.scrollTop / (pdfViewerArea.scrollHeight - pdfViewerArea.clientHeight || 1);

 pdfZoomLevel = newZoom;
 // Format zoom display for better readability at extreme values
 if (pdfZoomLevel >= 10) {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel) + 'x';
 } else if (pdfZoomLevel < 0.1) {
 pdfZoomLevelDisplay.textContent = (pdfZoomLevel * 100).toFixed(1) + '%';
 } else {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel * 100) + '%';
 }

 // Throttle re-renders for better performance
 if (renderTimeout) {
 clearTimeout(renderTimeout);
 }
 renderTimeout = setTimeout(() => {
 rerenderAllPages().then(() => {
 // Restore scroll position
 const newScrollX = scrollRatioX * (pdfViewerArea.scrollWidth - pdfViewerArea.clientWidth);
 const newScrollY = scrollRatioY * (pdfViewerArea.scrollHeight - pdfViewerArea.clientHeight);
 pdfViewerArea.scrollLeft = newScrollX;
 pdfViewerArea.scrollTop = newScrollY;
 });
 }, 100); // 100ms throttle
 }
 }

 function changeZoomAtPoint(delta, centerX, centerY) {
 // Remove zoom limits - allow infinite zoom with reasonable bounds
 const newZoom = Math.max(0.01, Math.min(50.0, pdfZoomLevel + delta));
 if (newZoom !== pdfZoomLevel) {
 // Calculate scroll position to maintain zoom center
 const scrollX = pdfViewerArea.scrollLeft;
 const scrollY = pdfViewerArea.scrollTop;

 const zoomRatio = newZoom / pdfZoomLevel;

 pdfZoomLevel = newZoom;
 // Format zoom display for better readability at extreme values
 if (pdfZoomLevel >= 10) {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel) + 'x';
 } else if (pdfZoomLevel < 0.1) {
 pdfZoomLevelDisplay.textContent = (pdfZoomLevel * 100).toFixed(1) + '%';
 } else {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel * 100) + '%';
 }

 // Throttle re-renders for better performance
 if (renderTimeout) {
 clearTimeout(renderTimeout);
 }
 renderTimeout = setTimeout(() => {
 rerenderAllPages().then(() => {
 // Adjust scroll to maintain center point
 const newScrollX = (scrollX + centerX) * zoomRatio - centerX;
 const newScrollY = (scrollY + centerY) * zoomRatio - centerY;
 pdfViewerArea.scrollLeft = Math.max(0, newScrollX);
 pdfViewerArea.scrollTop = Math.max(0, newScrollY);
 });
 }, 50); // Shorter throttle for wheel zoom for better responsiveness
 }
 }

 async function rerenderAllPages() {
 if (!currentPdfDoc || pdfPages.length === 0 || isRendering) return;

 isRendering = true;
 console.log('Re-rendering all pages with zoom:', pdfZoomLevel);

 try {
 // For very high zoom levels, render pages in batches to prevent blocking
 const batchSize = pdfZoomLevel > 10 ? 2 : (pdfZoomLevel > 5 ? 5 : pdfPages.length);

 for (let batchStart = 0; batchStart < pdfPages.length; batchStart += batchSize) {
 const batchEnd = Math.min(batchStart + batchSize, pdfPages.length);

 // Process batch
 for (let i = batchStart; i < batchEnd; i++) {
 const pageData = pdfPages[i];
 const pageElement = pageElements[i];
 const canvas = pageData.canvas;
 const context = pageData.context;

 // Get new viewport with updated zoom
 const viewport = pageData.page.getViewport({ scale: pdfZoomLevel });

 // Update page container dimensions
 pageElement.style.width = viewport.width + 'px';
 pageElement.style.height = (viewport.height + 30) + 'px';

 // Update canvas size and styling
 canvas.width = viewport.width;
 canvas.height = viewport.height;
 canvas.style.width = viewport.width + 'px';
 canvas.style.height = viewport.height + 'px';

 // Update page number styling for zoom level
 const pageNumberDiv = pageElement.querySelector('.pdf-page-number');
 if (pageNumberDiv) {
 pageNumberDiv.style.fontSize = Math.max(10, 12 * pdfZoomLevel) + 'px';
 }

 // Re-render the page
 const renderContext = {
 canvasContext: context,
 viewport: viewport
 };

 await pageData.page.render(renderContext).promise;

 // Update stored viewport
 pageData.viewport = viewport;
 }

 // Allow UI to update between batches for high zoom levels
 if (batchSize < pdfPages.length) {
 await new Promise(resolve => setTimeout(resolve, 10));
 }
 }
 } finally {
 isRendering = false;
 }
 }

 function fitToWidth() {
 if (!currentPdfDoc || !pdfViewerArea || pdfPages.length === 0) return;

 const containerWidth = pdfViewerArea.clientWidth - 40; // Account for padding
 const firstPageData = pdfPages[0];
 if (!firstPageData) return;

 // Get original page width at scale 1.0
 const originalViewport = firstPageData.page.getViewport({ scale: 1.0 });
 const newZoom = containerWidth / originalViewport.width;

 // Allow any zoom level for fit to width
 const clampedZoom = Math.max(0.01, Math.min(50.0, newZoom));
 if (clampedZoom !== pdfZoomLevel) {
 pdfZoomLevel = clampedZoom;
 // Format zoom display for better readability at extreme values
 if (pdfZoomLevel >= 10) {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel) + 'x';
 } else if (pdfZoomLevel < 0.1) {
 pdfZoomLevelDisplay.textContent = (pdfZoomLevel * 100).toFixed(1) + '%';
 } else {
 pdfZoomLevelDisplay.textContent = Math.round(pdfZoomLevel * 100) + '%';
 }
 rerenderAllPages();
 }
 }

 function initializePageObserver() {
 if (pageObserver) {
 pageObserver.disconnect();
 }

 pageObserver = new IntersectionObserver((entries) => {
 let mostVisiblePage = null;
 let maxVisibility = 0;

 entries.forEach(entry => {
 if (entry.isIntersecting) {
 const visibility = entry.intersectionRatio;
 if (visibility > maxVisibility) {
 maxVisibility = visibility;
 mostVisiblePage = parseInt(entry.target.dataset.pageNumber);
 }
 }
 });

 if (mostVisiblePage && mostVisiblePage !== currentPdfPage) {
 currentPdfPage = mostVisiblePage;
 pdfPageInput.value = currentPdfPage;
 updateNavigationButtons();
 if (!isApplyingBroadcastedPdf) {
 maybeBroadcastPdfState('page_change', { current_page: currentPdfPage });
 }
 }
 }, {
 root: pdfViewerArea,
 threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
 });
 }

 function updatePageObserver() {
 if (pageObserver && pageElements.length > 0) {
 pageElements.forEach(element => {
 pageObserver.observe(element);
 });
 }
 }

 function updateNavigationButtons() {
 if (pdfPrevPage) pdfPrevPage.disabled = currentPdfPage <= 1;
 if (pdfNextPage) pdfNextPage.disabled = currentPdfPage >= totalPdfPages;
 }

 function closePdf() {
 currentPdfDoc = null;
 currentPdfPage = 1;
 totalPdfPages = 0;
 pdfZoomLevel = 1.0;
 pdfPages = [];
 pageElements = [];

 // Clear PDF data for session export
 currentPdfData = null;
 currentPdfName = null;

 // Disconnect observer
 if (pageObserver) {
 pageObserver.disconnect();
 }

 // Clear container
 if (pdfContainer) {
 pdfContainer.innerHTML = '';
 }

 // Reset UI
 pdfNotLoaded.classList.remove('hidden');
 pdfLoaded.classList.add('hidden');
 pdfControls.classList.add('hidden');
 pdfViewerArea.classList.add('hidden');
 if (pdfFileInput) pdfFileInput.value = '';
 if (pdfZoomLevelDisplay) pdfZoomLevelDisplay.textContent = '100%';
 if (!isApplyingBroadcastedPdf) {
 maybeBroadcastPdfState('close');
 }
 }

 // Initialize PDF viewer
 console.log('Initializing PDF viewer...');
 initializePdfViewer();

 // --- Enhanced Canvas Collaboration Events ---

 // Text inspector update function
  let lastTextForInspector = null;
  function positionTextInspectorForObject(obj) {
    if (!obj) return;
    const rect = fabricCanvas.getElement().getBoundingClientRect();
    const vpt = fabricCanvas.viewportTransform || [1,0,0,1,0,0];
    const pt = new fabric.Point(obj.left, obj.top);
    const sp = fabric.util.transformPoint(pt, vpt); // viewport coords relative to canvas
    const objW = (obj.getScaledWidth ? obj.getScaledWidth() : obj.width || 0) * vpt[0];
    const objH = (obj.getScaledHeight ? obj.getScaledHeight() : obj.height || 0) * vpt[3];

    // Default place to the right and slightly above the object
    let left = rect.left + sp.x + objW + 8;
    let top = rect.top + sp.y - 32;

    // Clamp to viewport bounds
    const panelWidth = 280; // approximate max width of inspector
    const panelHeight = 56; // approx height
    if (left + panelWidth > window.innerWidth - 8) {
      left = rect.left + sp.x - panelWidth - 8; // place to the left of object
    }
    if (left < 8) left = 8;
    if (top < 8) top = rect.top + sp.y + objH + 8; // place below if above is out of view

    textInspector.style.left = left + 'px';
    textInspector.style.top = top + 'px';
  }

  function updateTextInspector(e) {
  const ao = e.selected?.[0];
  if (ao && ao.type === 'i-text') {
  lastTextForInspector = ao;
  positionTextInspectorForObject(ao);
  textInspector.style.display = 'flex';

  // Update controls to reflect current text properties
  fontSelect.value = ao.fontFamily || 'Inter';
  sizeSelect.value = ao.fontSize || 20;
  colorInput.value = ao.fill || '#000000';

  // Update button states
  boldButton.style.backgroundColor = ao.fontWeight === 'bold' ? '#3b82f6' : '';
  boldButton.style.color = ao.fontWeight === 'bold' ? 'white' : '';
  italicButton.style.backgroundColor = ao.fontStyle === 'italic' ? '#3b82f6' : '';
  italicButton.style.color = ao.fontStyle === 'italic' ? 'white' : '';

  // Add visual indicator for editing state
 const editingIndicator = textInspector.querySelector('.editing-indicator') ||
 (() => {
 const indicator = document.createElement('span');
 indicator.className = 'editing-indicator text-xs px-2 py-1 rounded';
 textInspector.appendChild(indicator);
 return indicator;
 })();

 if (ao.isEditing) {
 editingIndicator.textContent = 'EDITING';
 editingIndicator.className = 'editing-indicator text-xs px-2 py-1 rounded bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100';
 } else {
 editingIndicator.textContent = 'SELECTED';
 editingIndicator.className = 'editing-indicator text-xs px-2 py-1 rounded bg-blue-100 text-blue-800 dark:bg-blue-800 dark:text-blue-100';
 }
  } else {
  textInspector.style.display = 'none';
  lastTextForInspector = null;
  }
  }

  // Track object selection changes
  fabricCanvas.on('selection:created', (e) => {
 // Block selection in Pan Mode
 if (isPanModeActive) {
     console.log('üéØ Pan Mode active - blocking selection:created');
     fabricCanvas.discardActiveObject();
     fabricCanvas.renderAll();
     return;
 }

 // Block selection during actual two-finger gestures only (but allow in select mode)
 if (isGesturing && touchStartPoint && currentTool !== 'select') {
     console.log('üö´ Blocking selection:created during two-finger gesture');
     fabricCanvas.discardActiveObject();
     fabricCanvas.renderAll();
     return;
 }

 // Allow selection in select mode
 if (currentTool === 'select' && isGesturing) {
     console.log('‚úÖ Allowing selection:created in select mode');
 }

 const selectedObjects = e.selected || [];

 // Handle text inspector
 updateTextInspector(e);

 // Handle advanced line editing (including new arrows) - only clear control points, don't auto-create
 if (selectedObjects.length === 1 && (selectedObjects[0].isAdvancedLine || selectedObjects[0].type === 'arrow')) {
 // Don't automatically create control points - wait for user to double-click
 if (selectedLineForEditing && selectedLineForEditing !== selectedObjects[0]) {
 clearControlPoints();
 }
 selectedLineForEditing = selectedObjects[0];
 } else {
 clearControlPoints();
 selectedLineForEditing = null;
 }

 if (!isProcessingRemoteOperation && currentRoomId) {
 // Ensure all selected objects have IDs
 selectedObjects.forEach(obj => {
 if (!obj.id) {
 obj.id = generateObjectId();
 console.log('üÜî Generated missing ID for selected object:', obj.type, obj.id);
 }
  });

 console.log('üëÜ Selection created:', selectedObjects.map(obj => ({type: obj.type, id: obj.id})));
 sendCanvasOperation('selection_created', {
 object_ids: selectedObjects.map(obj => obj.id).filter(id => id),
 user_id: currentUserId
 });
 }
 });

  fabricCanvas.on('selection:updated', (e) => {
 // Block selection in Pan Mode
 if (isPanModeActive) {
     console.log('üéØ Pan Mode active - blocking selection:updated');
     fabricCanvas.discardActiveObject();
     fabricCanvas.renderAll();
     return;
 }

 // Block selection during actual two-finger gestures only (but allow in select mode)
 if (isGesturing && touchStartPoint && currentTool !== 'select') {
     console.log('üö´ Blocking selection:updated during two-finger gesture');
     fabricCanvas.discardActiveObject();
     fabricCanvas.renderAll();
     return;
 }

 // Allow selection updates in select mode
 if (currentTool === 'select' && isGesturing) {
     console.log('‚úÖ Allowing selection:updated in select mode');
 }

 const selectedObjects = e.selected || [];

 // Handle text inspector
 updateTextInspector(e);

 // Handle advanced line editing (including new arrows) - only clear control points, don't auto-create
 if (selectedObjects.length === 1 && (selectedObjects[0].isAdvancedLine || selectedObjects[0].type === 'arrow')) {
 // Don't automatically create control points - wait for user to double-click
 if (selectedLineForEditing && selectedLineForEditing !== selectedObjects[0]) {
 clearControlPoints();
 }
 selectedLineForEditing = selectedObjects[0];
 } else {
 clearControlPoints();
 selectedLineForEditing = null;
 }

 if (!isProcessingRemoteOperation && currentRoomId) {
 // Ensure all selected objects have IDs
 selectedObjects.forEach(obj => {
 if (!obj.id) {
 obj.id = generateObjectId();
 console.log('üÜî Generated missing ID for updated selection:', obj.type, obj.id);
 }
  });

 console.log('üëÜ Selection updated:', selectedObjects.map(obj => ({type: obj.type, id: obj.id})));
 sendCanvasOperation('selection_updated', {
 object_ids: selectedObjects.map(obj => obj.id).filter(id => id),
 user_id: currentUserId
 });
 }
 });

  fabricCanvas.on('selection:cleared', (e) => {
  // Hide text inspector
  textInspector.style.display = 'none';
  lastTextForInspector = null;

 // Clear control points when selection is cleared
 clearControlPoints();
 selectedLineForEditing = null;

 if (!isProcessingRemoteOperation && currentRoomId) {
 console.log('üëÜ Selection cleared');
 sendCanvasOperation('selection_cleared', {
 user_id: currentUserId
  });

  // Reposition text inspector on render (pan/zoom/move)
  fabricCanvas.on('after:render', () => {
    if (textInspector.style.display !== 'none' && lastTextForInspector && fabricCanvas.getObjects().includes(lastTextForInspector)) {
      positionTextInspectorForObject(lastTextForInspector);
    }
  });
 }
 });

 // Handle double-click on arrows to enable control point editing
 fabricCanvas.on('mouse:dblclick', (e) => {
 // Block all events during gestures
 if (isGesturing) {
     e.e.preventDefault();
     e.e.stopPropagation();
     return false;
 }

 if (e.target && e.target.type === 'arrow') {
 console.log('üèπ Double-clicked arrow, enabling control point editing:', e.target.id);
 selectedLineForEditing = e.target;
 createControlPoints(e.target);

 // Show user feedback
 addChatMessage('System', 'üèπ Arrow editing enabled! Drag the blue control points to bend the arrow, or red points to move endpoints. Click elsewhere to finish editing.', false);
 }
 });

 // Track path creation (drawing) - this handles ALL drawing strokes
 fabricCanvas.on('path:created', (e) => {
 const path = e.path;
 if (!path.id) {
 path.id = generateObjectId();
 }

 // Track this path ID to prevent duplicate object:added events
 recentPathIds.add(path.id);
 setTimeout(() => {
 recentPathIds.delete(path.id);
 }, 1000); // Clean up after 1 second

 console.log('üé® Path created locally:', path.id);

 // Create and execute command for undo/redo support
 if (!isExecutingCommand && commandHistory && undoRedoEnabled) {
 try {
 const command = new AddPathCommand(path, 'Draw Path');
 // Add the command to history properly
 // Since the path is already added by Fabric.js, create a command that handles both undo and redo
 const pathCommand = {
     description: 'Draw path',
     execute: () => {
         // For redo: re-add the path to canvas
         if (!fabricCanvas.getObjects().includes(e.path)) {
             fabricCanvas.add(e.path);
             fabricCanvas.renderAll();
         }
     },
     undo: () => {
         fabricCanvas.remove(e.path);
         fabricCanvas.renderAll();
     },
     canUndo: () => true,
     toString: () => 'Draw Path Command'
 };

 // Add to history using proper method
 commandHistory.undoStack.push(pathCommand);
 commandHistory.redoStack = []; // Clear redo stack

 // Limit stack size
 if (commandHistory.undoStack.length > commandHistory.maxHistorySize) {
     commandHistory.undoStack.shift();
 }

 commandHistory.updateUI();
 console.log('üìù Path added to undo history. Stack size:', commandHistory.undoStack.length);
 } catch (error) {
 console.warn('‚ö†Ô∏è Error adding path to undo history:', error);
 }
 }

    // Update recenter anchor
    try { const c = e.path.getCenterPoint(); lastDrawCenter = new fabric.Point(c.x, c.y); } catch(_) {}
    // Send to collaboration if in room
 if (!isProcessingRemoteOperation && currentRoomId) {
 sendCanvasOperation('path_created', {
 path: path.toObject(),
 object_id: path.id
 });
 }
 });

 // Track object addition - this handles shapes, text, images, etc. (NOT drawing paths)
 fabricCanvas.on('object:added', (e) => {
 const obj = e.target;
 if (!obj) return;

 console.log('üé® Object added event - type:', obj.type, 'class:', obj.constructor.name, 'id:', obj.id);

 // Skip if we're manually handling this object's synchronization
 if (skipNextObjectAdded) {
 console.log('‚è≠Ô∏è Skipping object:added - manual sync in progress');
 skipNextObjectAdded = false;
 return;
 }

 // Skip control points - they are not synchronized
 if (obj.isControlPoint) {
 console.log('‚è≠Ô∏è Skipping control point in object:added');
 return;
 }

 // Skip if this object was recently created as a path
 if (obj.id && recentPathIds.has(obj.id)) {
 console.log('‚è≠Ô∏è Skipping object:added for recent path:', obj.id);
 return;
 }

 // COMPLETELY SKIP all paths - they are ONLY handled by path:created
 if (obj.type === 'path' || obj.constructor.name === 'Path' || obj.constructor.name === 'fabric.Path') {
 console.log('‚è≠Ô∏è Skipping path in object:added (handled by path:created)', obj.type, obj.constructor.name);
 return;
 }

 // Only handle non-path objects (rectangles, circles, text, images, etc.)
 if (!obj.id) {
 obj.id = generateObjectId();
 }
  console.log('üé® Non-path object added locally:', obj.type, obj.id);
  // Update recenter anchor to this object's center
  try { const c = obj.getCenterPoint(); lastDrawCenter = new fabric.Point(c.x, c.y); } catch(_) {}

 // Create and execute command for undo/redo support
 if (!isExecutingCommand && commandHistory) {
 const command = new AddObjectCommand(obj, `Add ${obj.type}`);
 // Add the command to history properly
 // Since the object is already added by Fabric.js, create a command that handles both undo and redo
 const objectCommand = {
     description: `Add ${obj.type}`,
     execute: () => {
         // For redo: re-add the object to canvas
         if (!fabricCanvas.getObjects().includes(obj)) {
             fabricCanvas.add(obj);
             fabricCanvas.renderAll();
         }
     },
     undo: () => {
         fabricCanvas.remove(obj);
         fabricCanvas.renderAll();
     },
     canUndo: () => true,
     toString: () => `Add ${obj.type} Command`
 };

 // Add to history using proper method
 commandHistory.undoStack.push(objectCommand);
 commandHistory.redoStack = []; // Clear redo stack

 // Limit stack size
 if (commandHistory.undoStack.length > commandHistory.maxHistorySize) {
     commandHistory.undoStack.shift();
 }

 commandHistory.updateUI();
 console.log('üìù Object added to undo history. Stack size:', commandHistory.undoStack.length);
 }

 // Send to collaboration if in room
 if (!isProcessingRemoteOperation && currentRoomId) {
 sendCanvasOperation('object_added', {
 object: obj.toObject(),
 object_id: obj.id
 });
 }
 });

 // Track object modifications (move, resize, rotate)
 fabricCanvas.on('object:modified', (e) => {
 const obj = e.target;
 if (!obj || !obj.id) {
 if (obj && !obj.id) {
 obj.id = generateObjectId();
 }
 return;
 }

 console.log('üîÑ Object modified:', obj.type, obj.id);

 // Create command for undo/redo support
 if (!isExecutingCommand && commandHistory && objectStatesBeforeModification.has(obj.id)) {
 const oldState = objectStatesBeforeModification.get(obj.id);
 const newState = {
 left: obj.left,
 top: obj.top,
 scaleX: obj.scaleX,
 scaleY: obj.scaleY,
 angle: obj.angle
 };

 const command = new ModifyObjectCommand(obj, oldState, newState, `Move/Transform ${obj.type}`);
 commandHistory.executeCommand(command);

 // Clear the stored state
 objectStatesBeforeModification.delete(obj.id);
 }

 // Send to collaboration if in room
 if (!isProcessingRemoteOperation && currentRoomId) {
 sendCanvasOperation('object_modified', {
 object_id: obj.id,
 object: obj.toObject(),
 transform: {
 left: obj.left,
 top: obj.top,
 scaleX: obj.scaleX,
 scaleY: obj.scaleY,
 angle: obj.angle
 }
 });
 }
 });

 // Track text editing changes
 fabricCanvas.on('text:changed', (e) => {
 if (!isProcessingRemoteOperation && currentRoomId && e.target) {
 const obj = e.target;
 if (!obj.id) {
 obj.id = generateObjectId();
 }

 console.log('üìù Text content changed:', obj.id, obj.text);
 sendCanvasOperation('object_modified', {
 object_id: obj.id,
 object: obj.toObject()
 });
 }
 });

 // Store text state before editing for undo/redo
 let textStateBeforeEdit = new Map();

  // Track when text enters editing mode
  fabricCanvas.on('text:editing:entered', (e) => {
 console.log('üìù Text entered editing mode:', e.target.id);

 // Store the text state before editing for undo/redo
 if (!isExecutingCommand && e.target && e.target.id) {
 textStateBeforeEdit.set(e.target.id, {
 text: e.target.text,
 fontSize: e.target.fontSize,
 fontFamily: e.target.fontFamily,
 fontWeight: e.target.fontWeight,
 fontStyle: e.target.fontStyle,
 fill: e.target.fill
 });
 console.log('üíæ Stored text state before editing:', e.target.id);
 }

  // Ensure inspector is positioned near the text being edited
  try {
    if (e.target && e.target.type === 'i-text') {
      positionTextInspectorForObject(e.target);
      textInspector.style.display = 'flex';
      lastTextForInspector = e.target;
    }
  } catch (_) {}
  // Update text inspector to show editing state
 updateTextInspector({ selected: [e.target] });
 });

  // Track when text exits editing mode
  fabricCanvas.on('text:editing:exited', (e) => {
 console.log('üìù Text exited editing mode:', e.target.id);

 // Create undo/redo command for text changes
 if (!isExecutingCommand && commandHistory && e.target && e.target.id && textStateBeforeEdit.has(e.target.id)) {
 const oldState = textStateBeforeEdit.get(e.target.id);
 const newState = {
 text: e.target.text,
 fontSize: e.target.fontSize,
 fontFamily: e.target.fontFamily,
 fontWeight: e.target.fontWeight,
 fontStyle: e.target.fontStyle,
 fill: e.target.fill
 };

 // Only create command if text actually changed
 if (oldState.text !== newState.text ||
     oldState.fontSize !== newState.fontSize ||
     oldState.fontFamily !== newState.fontFamily ||
     oldState.fontWeight !== newState.fontWeight ||
     oldState.fontStyle !== newState.fontStyle ||
     oldState.fill !== newState.fill) {

 const command = new ModifyObjectCommand(e.target, oldState, newState, 'Edit Text');
 commandHistory.executeCommand(command);
 console.log('üìù Text edit command added to undo history');
 }

 // Clean up stored state
 textStateBeforeEdit.delete(e.target.id);
 }

  // Keep inspector visible and reposition (properties may have changed)
  try {
    if (e.target && e.target.type === 'i-text') {
      positionTextInspectorForObject(e.target);
      textInspector.style.display = 'flex';
      lastTextForInspector = e.target;
    }
  } catch (_) {}
  // Update text inspector to show selected state
 updateTextInspector({ selected: [e.target] });
 });

 // Track object movement during drag
 fabricCanvas.on('object:moving', (e) => {
 const obj = e.target;

 // Handle control point movement for new arrows
 if (obj.isControlPoint && selectedLineForEditing && selectedLineForEditing.type === 'arrow') {
 const controlIndex = obj.controlIndex;
 if (controlIndex === 0) {
 selectedLineForEditing.cp1 = { x: obj.left, y: obj.top };
 } else if (controlIndex === 1) {
 selectedLineForEditing.cp2 = { x: obj.left, y: obj.top };
 }
 selectedLineForEditing.updatePath();
 fabricCanvas.renderAll();
 return; // Don't send collaboration events for control points
 }

 // Handle endpoint movement for new arrows
 if (obj.isEndPoint && selectedLineForEditing && selectedLineForEditing.type === 'arrow') {
 const endIndex = obj.endIndex;
 if (endIndex === 0) {
 selectedLineForEditing.x1 = obj.left;
 selectedLineForEditing.y1 = obj.top;
 } else if (endIndex === 1) {
 selectedLineForEditing.x2 = obj.left;
 selectedLineForEditing.y2 = obj.top;
 }
 selectedLineForEditing.updatePath();
 fabricCanvas.renderAll();
 return; // Don't send collaboration events for endpoint handles
 }

 // Handle legacy control point movement
 if (obj.isControlPoint && selectedLineForEditing) {
 const controlIndex = obj.controlIndex;
 if (selectedLineForEditing.controlPoints && selectedLineForEditing.controlPoints[controlIndex]) {
 selectedLineForEditing.controlPoints[controlIndex] = {
 x: obj.left,
 y: obj.top
 };
 updateLineWithControlPoints(selectedLineForEditing, selectedLineForEditing.controlPoints);
 }
 return; // Don't send collaboration events for control points
 }

 if (!isProcessingRemoteOperation && currentRoomId && e.target) {
 if (!obj.id) {
 obj.id = generateObjectId();
 }
 // üöÄ MOBILE OPTIMIZATION: Adaptive throttling for object movement
 const now = Date.now();
 const movementInterval = isCoarse ? 100 : 50; // 10fps on mobile, 20fps on desktop
 if (now - lastOperationTime > movementInterval) {
 sendCanvasOperation('object_moving', {
 object_id: obj.id,
 position: {
 left: obj.left,
 top: obj.top
 }
 }, 'high'); // High priority for real-time movement
 lastOperationTime = now;
 }
 }
 });

 // Track object scaling
 fabricCanvas.on('object:scaling', (e) => {
 if (!isProcessingRemoteOperation && currentRoomId && e.target) {
 const obj = e.target;
 if (!obj.id) {
 obj.id = generateObjectId();
 }
 const now = Date.now();
 const scalingInterval = isCoarse ? 100 : 50; // Adaptive throttling
 if (now - lastOperationTime > scalingInterval) {
 sendCanvasOperation('object_scaling', {
 object_id: obj.id,
 scale: {
 scaleX: obj.scaleX,
 scaleY: obj.scaleY
 }
 }, 'high');
 lastOperationTime = now;
 }
 }
 });

 // Track object rotation
 fabricCanvas.on('object:rotating', (e) => {
 if (!isProcessingRemoteOperation && currentRoomId && e.target) {
 const obj = e.target;
 if (!obj.id) {
 obj.id = generateObjectId();
 }
 const now = Date.now();
 const rotationInterval = isCoarse ? 100 : 50; // Adaptive throttling
 if (now - lastOperationTime > rotationInterval) {
 sendCanvasOperation('object_rotating', {
 object_id: obj.id,
 angle: obj.angle
 }, 'high');
 lastOperationTime = now;
 }
 }
 });

 // Track object removal
 fabricCanvas.on('object:removed', (e) => {
 if (!isProcessingRemoteOperation && currentRoomId && e.target) {
 const obj = e.target;
 if (!obj.id) {
 console.warn('Object removed without ID, cannot sync');
 return;
 }
 sendCanvasOperation('object_removed', {
 object_id: obj.id,
 object_type: obj.type
 });
 }
 });

 // Track mouse movement for cursor sharing
 let lastCursorSend = 0;

 // üöÄ MOBILE OPTIMIZATION: Adaptive throttling based on device type
 const cursorInterval = isCoarse ? 120 : 50; // 8fps on mobile, 20fps on desktop

 // Combined mouse move event listener for cursor sharing and image positioning
 fabricCanvas.on('mouse:move', (e) => {
 // Block all events during gestures
 if (isGesturing) {
     e.e.preventDefault();
     e.e.stopPropagation();
     return false;
 }

 const pointer = fabricCanvas.getPointer(e.e);

 // Update last mouse position for image pasting
 lastMousePosition.x = pointer.x;
 lastMousePosition.y = pointer.y;

 // Send cursor position to other users (adaptive throttling)
 if (currentRoomId && Date.now() - lastCursorSend > cursorInterval) {
 sendCursorPosition(pointer.x, pointer.y);
 lastCursorSend = Date.now();
 }
 });

 // Also capture last cursor position on mouse down so paste works even without moving first
 fabricCanvas.on('mouse:down', (e) => {
   try {
     const p = fabricCanvas.getPointer(e.e);
     lastMousePosition.x = p.x;
     lastMousePosition.y = p.y;
   } catch (_) {}
 });



 // --- Resizable AI Panel Functionality ---
 let isResizing = false;
 let isChatSidebarVisible = true;

 // Load saved sidebar width
 const savedSidebarWidth = localStorage.getItem('aiSidebarWidth');
 if (savedSidebarWidth) {
 aiChatSidebar.style.width = savedSidebarWidth + 'px';
 }

 // Resize handle functionality - Mouse events
 resizeHandle.addEventListener('mousedown', (e) => {
 isResizing = true;
 document.body.style.cursor = 'col-resize';
 document.body.style.userSelect = 'none';

 const startX = e.clientX;
 const startWidth = parseInt(document.defaultView.getComputedStyle(aiChatSidebar).width, 10);

 function doResize(e) {
 if (!isResizing) return;

 const newWidth = startWidth - (e.clientX - startX);
 const minWidth = 200;
 const maxWidth = Math.floor(window.innerWidth * 0.5); // 50% of screen width

 if (newWidth >= minWidth && newWidth <= maxWidth) {
 aiChatSidebar.style.width = newWidth + 'px';
 localStorage.setItem('aiSidebarWidth', newWidth);

 // Update toolbar scrolling
 updateToolbarScrolling();

 // Trigger PDF fit-to-width if PDF viewer is active and a PDF is loaded
 if (activeTab === 'pdf-viewer' && currentPdfDoc) {
 setTimeout(() => {
 fitToWidth();
 }, 100);
 }
 }
 }

 function stopResize() {
 isResizing = false;
 document.body.style.cursor = '';
 document.body.style.userSelect = '';
 document.removeEventListener('mousemove', doResize);
 document.removeEventListener('mouseup', stopResize);
 }

 document.addEventListener('mousemove', doResize);
 document.addEventListener('mouseup', stopResize);
 });

 // Resize handle functionality - Touch events for mobile
 resizeHandle.addEventListener('touchstart', (e) => {
 isResizing = true;
 document.body.style.userSelect = 'none';

 // Add visual feedback for touch
 resizeHandle.style.backgroundColor = '#6366f1';
 resizeHandle.style.opacity = '1';

 const startX = e.touches[0].clientX;
 const startWidth = parseInt(document.defaultView.getComputedStyle(aiChatSidebar).width, 10);

 function doResizeTouch(e) {
 if (!isResizing) return;
 e.preventDefault(); // Prevent scrolling

 const newWidth = startWidth - (e.touches[0].clientX - startX);
 const minWidth = 200;
 const maxWidth = Math.floor(window.innerWidth * 0.5); // 50% of screen width

 if (newWidth >= minWidth && newWidth <= maxWidth) {
 aiChatSidebar.style.width = newWidth + 'px';
 localStorage.setItem('aiSidebarWidth', newWidth);

 // Update toolbar scrolling
 updateToolbarScrolling();

 // Trigger PDF fit-to-width if PDF viewer is active and a PDF is loaded
 if (activeTab === 'pdf-viewer' && currentPdfDoc) {
 setTimeout(() => {
 fitToWidth();
 }, 100);
 }
 }
 }

 function stopResizeTouch() {
 isResizing = false;
 document.body.style.userSelect = '';

 // Remove visual feedback
 resizeHandle.style.backgroundColor = '';
 resizeHandle.style.opacity = '';

 document.removeEventListener('touchmove', doResizeTouch);
 document.removeEventListener('touchend', stopResizeTouch);
 }

 document.addEventListener('touchmove', doResizeTouch, { passive: false });
 document.addEventListener('touchend', stopResizeTouch);

 e.preventDefault(); // Prevent default touch behavior
 });

 // Update max width on window resize and ensure toolbar scrolling
 function updateToolbarScrolling() {
     const toolbarContent = document.getElementById('toolbar-content');
     if (toolbarContent) {
         // Force recalculation of scrollable area
         toolbarContent.style.width = '100%';
         toolbarContent.scrollLeft = 0;
     }
 }

 window.addEventListener('resize', () => {
     const currentWidth = parseInt(aiChatSidebar.style.width || '384', 10);
     const newMaxWidth = Math.floor(window.innerWidth * 0.5);
     if (currentWidth > newMaxWidth) {
         aiChatSidebar.style.width = newMaxWidth + 'px';
         localStorage.setItem('aiSidebarWidth', newMaxWidth);
     }
     updateToolbarScrolling();
 });

 // Function to toggle sidebar visibility
 function toggleAISidebar() {
 isChatSidebarVisible = !isChatSidebarVisible;

 if (isChatSidebarVisible) {
 aiChatSidebar.style.display = 'flex';
 floatingAiBtn.style.display = 'none';
 toggleChatSidebarBtn.innerHTML = `
 <svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 `;
 toggleChatSidebarBtn.title = 'Hide AI Panel';
 } else {
 aiChatSidebar.style.display = 'none';
 floatingAiBtn.style.display = 'block';
 toggleChatSidebarBtn.innerHTML = `
 <svg class="w-4 h-4 text-slate-600 dark:text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
 </svg>
 `;
 toggleChatSidebarBtn.title = 'Show AI Panel';
 }

 localStorage.setItem('aiSidebarVisible', isChatSidebarVisible);

 // Trigger canvas resize after sidebar toggle with proper timing
 setTimeout(() => {
     const newWidth = canvasParent.clientWidth;
     const newHeight = canvasParent.clientHeight;

     if (newWidth > 0 && newHeight > 0) {
         fabricCanvas.setDimensions({
             width: newWidth,
             height: newHeight
         });
         fabricCanvas.requestRenderAll();

         // Force a second resize check after CSS transitions complete
         setTimeout(() => {
             const finalWidth = canvasParent.clientWidth;
             const finalHeight = canvasParent.clientHeight;
             if (finalWidth !== newWidth || finalHeight !== newHeight) {
                 fabricCanvas.setDimensions({
                     width: finalWidth,
                     height: finalHeight
                 });
                 fabricCanvas.requestRenderAll();
             }
         }, 350); // Wait for CSS transition to complete
     }
 }, 50);
 }

 // Toggle sidebar visibility
 toggleChatSidebarBtn.addEventListener('click', toggleAISidebar);
 floatingAiBtn.addEventListener('click', toggleAISidebar);

 // Load saved sidebar visibility - default to hidden for full canvas
 const savedSidebarVisibility = localStorage.getItem('aiSidebarVisible');
 if (savedSidebarVisibility === null || savedSidebarVisibility === 'false') {
 isChatSidebarVisible = true; // Set to true so toggle will make it false
 toggleAISidebar(); // Use our new function to hide and show floating button
 }

 // Connect to collaboration server on load
 connectToCollaborationServer();

 // Initialize users tooltip hover functionality
 initializeUsersTooltip();

 // Initialize PDF modal controls
 initializePdfModal();

 // Initial typesetting for welcome message
 if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
 MathJax.typesetPromise([chatHistory]).catch((err) => console.error('MathJax initial typesetting error:', err));
 }

 // Initialize notification system
 function initializeNotificationSystem() {
 // Load saved notification preference
 const savedNotificationState = localStorage.getItem('groupNotificationsEnabled');
 if (savedNotificationState !== null) {
 notificationsEnabled = savedNotificationState === 'true';
 }

 // Update mute button state
 if (muteNotificationsBtn) {
 const muteBtn = document.getElementById('mute-btn-text');
 const muteIcon = muteNotificationsBtn.querySelector('svg path');

 if (notificationsEnabled) {
 muteBtn.textContent = 'Mute';
 muteNotificationsBtn.classList.remove('muted');
 } else {
 muteBtn.textContent = 'Unmute';
 muteNotificationsBtn.classList.add('muted');
 if (muteIcon) {
 muteIcon.setAttribute('d', 'M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2');
 }
 }
 }

 console.log('Notification system initialized. Notifications enabled:', notificationsEnabled);
 }

 initializeNotificationSystem();

 // --- Session Management Functions ---

 // Function to export the entire application state
 async function exportSession() {
     try {
         console.log('Exporting session...');
         console.log('Current PDF data available:', !!currentPdfData);
         console.log('Current PDF name:', currentPdfName);
         console.log('Number of cells to export:', cells.length);
         console.log('Canvas objects to export:', fabricCanvas.getObjects().length);
         console.log('Canvas background pattern to export:', currentCanvasPattern ? currentCanvasPattern.type : 'none');
         console.log('AI chat history entries:', chatHistoryStorage.length);
         console.log('Datasets to export:', importedDatasets.size);

         // Fetch uploaded files data for group messaging
         let uploadedFilesData = {};
         try {
             const response = await fetch('/api/uploaded-files');
             if (response.ok) {
                 const result = await response.json();
                 uploadedFilesData = result.files || {};
                 console.log('Uploaded files to export:', Object.keys(uploadedFilesData).length);
             } else {
                 console.warn('Failed to fetch uploaded files for export');
             }
         } catch (error) {
             console.warn('Error fetching uploaded files for export:', error);
         }

         const sessionData = {
             version: "1.0",
             timestamp: new Date().toISOString(),
             canvasState: {
                 ...fabricCanvas.toJSON(['id', 'selectable', 'evented']),
                 background: currentCanvasPattern ? 'css_pattern' : (fabricCanvas.backgroundColor || '#ffffff'),
                 pattern: currentCanvasPattern || null,
                 width: fabricCanvas.width,
                 height: fabricCanvas.height,
                 zoom: currentZoom
             },
             aiChatHistory: chatHistoryStorage.map(msg => ({
                 ...msg,
                 // Convert image data to base64 if present
                 imageData: msg.imageData ? msg.imageData : null
             })),
             groupMessages: extractGroupMessages(),
             uploadedFiles: uploadedFilesData,
             jupyterNotebook: {
                 cells: cells.map(cell => ({
                     id: cell.id,
                     type: 'code',
                     code: cell.codeInput ? cell.codeInput.value : '',
                     output: cell.outputContent ? cell.outputContent.innerHTML : ''
                 })),
                 cellCounter: cellCounter
             },
             pdfData: currentPdfData ? {
                 name: currentPdfName,
                 data: currentPdfData,
                 currentPage: currentPdfPage,
                 totalPages: totalPdfPages,
                 zoom: pdfZoomLevel
             } : null,
             datasets: Array.from(importedDatasets.entries()).map(([varName, dataset]) => ({
                 varName: varName,
                 filename: dataset.filename,
                 variable: dataset.variable,
                 info: dataset.info
             })),
             settings: {
                 darkMode: document.documentElement.classList.contains('dark'),
                 activeTab: activeTab,
                 sidebarVisible: !document.getElementById('ai-chat-sidebar').classList.contains('hidden')
             }
         };

         console.log('Session data prepared, PDF included:', !!sessionData.pdfData);

         const jsonString = JSON.stringify(sessionData, null, 2);
         const blob = new Blob([jsonString], { type: 'application/json' });
         const url = URL.createObjectURL(blob);

         const a = document.createElement('a');
         a.href = url;
         a.download = `fluxnotebook-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.fluxnb`;
         document.body.appendChild(a);
         a.click();
         document.body.removeChild(a);
         URL.revokeObjectURL(url);

         addChatMessage('System', 'Session exported successfully!');
         console.log('Session exported successfully');
     } catch (error) {
         console.error('Error exporting session:', error);
         addChatMessage('System', 'Error exporting session: ' + error.message);
     }
 }

 // Function to restore chat messages without filtering (for session import)
 function restoreChatMessage(sender, message, isHtml = false, imageData = null, replyTo = null, messageId = null) {
     const msgDiv = document.createElement('div');

     // Use provided message ID or generate new one
     const finalMessageId = messageId || `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
     msgDiv.setAttribute('data-message-id', finalMessageId);

     let senderPrefix = '';
     if (sender.toLowerCase() === 'user') {
         msgDiv.className = 'user-message self-start mr-auto max-w-[95%] message-item';
         senderPrefix = 'You: ';
     } else if (sender.toLowerCase() === 'ai') {
         msgDiv.className = 'ai-message self-start mr-auto max-w-[95%] message-item';
         senderPrefix = 'AI: ';
     } else { // System
         msgDiv.className = 'system-message-ai text-center w-full message-item';
         senderPrefix = 'System: ';
     }

     const senderStrong = document.createElement('strong');
     senderStrong.textContent = senderPrefix;

     // Add reply context if this is a reply
     if (replyTo) {
         const replyContext = document.createElement('div');
         replyContext.className = 'reply-context';
         replyContext.style.cssText = 'cursor: pointer; background: #22c55e !important; color: white !important; padding: 10px !important; margin: 5px 0 !important; border-radius: 5px !important;';
         replyContext.title = 'Click to go to original message';
         replyContext.setAttribute('data-reply-to-id', replyTo.id);

         const replyHeader = document.createElement('div');
         replyHeader.className = 'reply-context-header';
         replyHeader.style.cssText = 'color: white !important; font-weight: bold !important;';
         replyHeader.textContent = `~ ${replyTo.sender === 'user' ? 'You' : replyTo.sender}`;

         const replyContent = document.createElement('div');
         replyContent.className = 'reply-context-content';
         replyContent.style.cssText = 'color: #f0f0f0 !important;';
         const messageText = replyTo.message || '';
         const cleanMessage = messageText.replace(/<[^>]*>/g, '').substring(0, 100);
         replyContent.textContent = cleanMessage + (messageText.length > 100 ? '...' : '');

         // Add click handler to scroll to original message
         replyContext.addEventListener('click', () => {
             const replyToId = replyContext.getAttribute('data-reply-to-id');
             if (replyToId) {
                 scrollToMessage(replyToId);
             }
         });

         replyContext.appendChild(replyHeader);
         replyContext.appendChild(replyContent);
         msgDiv.appendChild(replyContext);
     }

     // Create message content
     const messageContent = document.createElement('div');
     messageContent.className = 'message-content';

     if (isHtml) {
         messageContent.innerHTML = message;
     } else {
         messageContent.appendChild(senderStrong);
         const messageText = document.createElement('span');
         messageText.textContent = message;
         messageContent.appendChild(messageText);
     }

     // Add image preview if imageData is provided (before the text content)
     if (imageData) {
         const imageContainer = document.createElement('div');
         imageContainer.className = 'image-preview-container mb-3 p-3 bg-slate-50 dark:bg-slate-800 rounded-xl border border-slate-200 dark:border-slate-600 shadow-sm';

         const img = document.createElement('img');
         img.src = imageData;
         img.alt = 'Attached image';
         img.className = 'w-full max-h-64 rounded-lg border border-slate-200 dark:border-slate-600 cursor-pointer hover:opacity-90 transition-opacity block object-contain';
         img.onclick = () => openImageModal(imageData, 'Attached image');

         imageContainer.appendChild(img);
         msgDiv.appendChild(imageContainer);
     }

     msgDiv.appendChild(messageContent);

     // Add to chat history
     const chatHistory = document.getElementById('chat-history');
     chatHistory.appendChild(msgDiv);
     chatHistory.scrollTop = chatHistory.scrollHeight;

     // Process MathJax for restored messages if they contain math expressions
     if ((sender.toLowerCase() === 'ai' || sender.toLowerCase() === 'user') &&
         !isHtml && (message.includes('$') || message.includes('\\') || message.includes('^') || message.includes('_'))) {
         setTimeout(() => {
             reprocessMathJax(messageContent);
         }, 10); // Small delay to ensure DOM is updated
     }
 }

 // Function to extract group messages from DOM
 function extractGroupMessages() {
     const messages = [];
     const messageElements = document.querySelectorAll('#group-messages .message-item');

     messageElements.forEach(msgEl => {
         const messageId = msgEl.getAttribute('data-message-id');
         const isSystemMessage = msgEl.classList.contains('system-message');
         const isFileMessage = msgEl.classList.contains('file-message');

         let messageData = {
             id: messageId,
             timestamp: new Date().toISOString()
         };

         if (isSystemMessage) {
             messageData.type = 'system';
             messageData.content = msgEl.querySelector('.message-content')?.textContent || '';
         } else if (isFileMessage) {
             messageData.type = 'file';
             const header = msgEl.querySelector('.message-header');
             const content = msgEl.querySelector('.message-content');
             messageData.sender_name = header?.querySelector('span')?.textContent || 'Unknown';

             // Extract file information more accurately
             const downloadLink = content?.querySelector('a[href*="/download/"]');
             if (downloadLink) {
                 messageData.content = downloadLink.textContent || '';
                 const href = downloadLink.getAttribute('href');
                 if (href) {
                     messageData.file_id = href.split('/download/')[1];
                 }
             }

             // Determine file type from image element or link
             const imageElement = content?.querySelector('img');
             if (imageElement) {
                 messageData.file_type = 'image/png'; // Default for images
                 messageData.is_image = true;
             } else {
                 messageData.file_type = 'application/octet-stream';
                 messageData.is_image = false;
             }

             // Check if message is deleted
             if (msgEl.classList.contains('deleted')) {
                 messageData.deleted = true;
             }
         } else {
             messageData.type = 'text';
             const header = msgEl.querySelector('.message-header');
             const content = msgEl.querySelector('.message-content');
             messageData.sender_name = header?.querySelector('span')?.textContent || 'Unknown';
             messageData.content = content?.textContent || '';

             // Check for reply context
             const replyContext = msgEl.querySelector('.reply-context');
             if (replyContext) {
                 const replyHeader = replyContext.querySelector('.reply-context-header')?.textContent || '';
                 const replyContent = replyContext.querySelector('.reply-context-content')?.textContent || '';
                 messageData.replyTo = {
                     sender: replyHeader.replace('Reply to ', ''),
                     content: replyContent
                 };
             }
         }

         messages.push(messageData);
     });

     return messages;
 }

 // Function to import and restore application state
 function importSession(file) {
     const reader = new FileReader();
     reader.onload = async function(e) {
         try {
             const sessionData = JSON.parse(e.target.result);

             if (!sessionData.version) {
                 throw new Error('Invalid session file format');
             }

             // Clear current state
             fabricCanvas.clear();
             chatHistoryStorage = [];
             clearGroupMessages();
             clearAllCells();

             // Restore canvas state
             if (sessionData.canvasState) {
                 console.log('üé® Restoring canvas state with background:', sessionData.canvasState.background);
                 console.log('üé® Pattern data in session:', sessionData.canvasState.pattern);

                 // Create a proper Fabric.js JSON structure and fix invalid textBaseline values
                 const objects = (sessionData.canvasState.objects || []).map(obj => {
                     if (obj.type === 'text' || obj.type === 'i-text' || obj.type === 'textbox') {
                         // Fix invalid textBaseline values
                         if (obj.textBaseline === 'alphabetical') {
                             obj.textBaseline = 'alphabetic';
                         }
                     }
                     return obj;
                 });

                 const fabricJson = {
                     objects: objects,
                     background: '#ffffff' // Always start with white, pattern will be applied separately
                 };

                 fabricCanvas.loadFromJSON(fabricJson, () => {
                     // Handle background patterns
                     if (sessionData.canvasState.background === 'css_pattern' && sessionData.canvasState.pattern) {
                         console.log('üé® Restoring CSS pattern from session:', sessionData.canvasState.pattern);

                         // Set the current pattern for tracking
                         currentCanvasPattern = sessionData.canvasState.pattern;

                         // Generate and apply the pattern
                         let cssPattern;
                         switch (sessionData.canvasState.pattern.type) {
                             case 'plain':
                                 cssPattern = {
                                     backgroundColor: sessionData.canvasState.pattern.backgroundColor,
                                     backgroundImage: '',
                                     backgroundSize: '',
                                     backgroundPosition: '',
                                     backgroundRepeat: ''
                                 };
                                 break;
                             case 'boxes':
                                 cssPattern = generateBoxesPattern(
                                     sessionData.canvasState.pattern.backgroundColor,
                                     sessionData.canvasState.pattern.patternColor,
                                     sessionData.canvasState.pattern.opacity,
                                     sessionData.canvasState.pattern.scale
                                 );
                                 break;
                             case 'polka':
                                 cssPattern = generatePolkaPattern(
                                     sessionData.canvasState.pattern.backgroundColor,
                                     sessionData.canvasState.pattern.patternColor,
                                     sessionData.canvasState.pattern.opacity,
                                     sessionData.canvasState.pattern.scale
                                 );
                                 break;
                             case 'graph':
                                 cssPattern = generateGraphPattern(
                                     sessionData.canvasState.pattern.backgroundColor,
                                     sessionData.canvasState.pattern.patternColor,
                                     sessionData.canvasState.pattern.opacity,
                                     sessionData.canvasState.pattern.scale
                                 );
                                 break;
                             case 'lines':
                                 cssPattern = generateLinesPattern(
                                     sessionData.canvasState.pattern.backgroundColor,
                                     sessionData.canvasState.pattern.patternColor,
                                     sessionData.canvasState.pattern.opacity,
                                     sessionData.canvasState.pattern.scale
                                 );
                                 break;
                             default:
                                 console.error('‚ùå Unknown pattern type in session:', sessionData.canvasState.pattern.type);
                                 fabricCanvas.setBackgroundColor('#ffffff');
                         }

                         if (cssPattern) {
                             applyCSSBackgroundToCanvas(cssPattern);
                             console.log('‚úÖ CSS pattern restored from session');
                         }
                     } else {
                         // Regular solid background
                         fabricCanvas.setBackgroundColor(sessionData.canvasState.background || '#ffffff');
                         console.log('üé® Solid background restored:', sessionData.canvasState.background);
                     }

                     if (sessionData.canvasState.width && sessionData.canvasState.height) {
                         fabricCanvas.setDimensions({
                             width: sessionData.canvasState.width,
                             height: sessionData.canvasState.height
                         });

                         // Reapply pattern after canvas dimensions change
                         setTimeout(() => {
                             if (currentCanvasPattern) {
                                 console.log('üîÑ Reapplying pattern after session canvas dimensions restore');
                                 reapplyCanvasPatternOnResize();
                             }
                         }, 100);
                     }
                     if (sessionData.canvasState.zoom) {
                         currentZoom = sessionData.canvasState.zoom;
                         fabricCanvas.setZoom(currentZoom);
                     }
                     fabricCanvas.renderAll();
                     console.log('Canvas state restored with', fabricCanvas.getObjects().length, 'objects');
                 });
             }

             // Restore AI chat history
             if (sessionData.aiChatHistory) {
                 console.log('Found AI chat history in session:', sessionData.aiChatHistory.length, 'messages');
                 console.log('Sample message:', sessionData.aiChatHistory[0]);

                 chatHistoryStorage = sessionData.aiChatHistory;
                 const chatHistory = document.getElementById('chat-history');
                 if (!chatHistory) {
                     console.error('chat-history element not found!');
                     return;
                 }
                 chatHistory.innerHTML = '';

                 sessionData.aiChatHistory.forEach((msg, index) => {
                     console.log(`Restoring message ${index + 1}:`, msg.sender, msg.message?.substring(0, 50));
                     try {
                         restoreChatMessage(msg.sender, msg.message, false, msg.imageData, msg.replyTo, msg.id);
                     } catch (error) {
                         console.error('Error restoring message:', error, msg);
                     }
                 });
                 console.log('AI chat history restored:', sessionData.aiChatHistory.length, 'messages');

                // Re-process MathJax for all restored chat content
                setTimeout(() => {
                    reprocessMathJax(chatHistory);
                }, 100); // Small delay to ensure DOM is updated
             } else {
                 console.log('No AI chat history found in session data');
             }

             // Restore group messages
             if (sessionData.groupMessages) {
                 clearGroupMessages();
                 sessionData.groupMessages.forEach(msg => {
                     addGroupMessage(msg);
                 });
             }

             // Restore Jupyter notebook
             if (sessionData.jupyterNotebook) {
                 clearAllCells();
                 cellCounter = sessionData.jupyterNotebook.cellCounter || 0;

                 sessionData.jupyterNotebook.cells.forEach(cellData => {
                     const cell = createCell(cellData.code || '');
                     if (cell.outputContent && cellData.output) {
                         cell.outputContent.innerHTML = cellData.output;
                         cell.output.classList.remove('hidden');
                     }
                     // Append the cell to the container
                     const cellsContainer = document.getElementById('cells-container');
                     if (cellsContainer) {
                         cellsContainer.appendChild(cell);
                     }
                 });
                 console.log('Jupyter notebook restored with', sessionData.jupyterNotebook.cells.length, 'cells');
             }

             // Restore PDF if present
             if (sessionData.pdfData && sessionData.pdfData.data) {
                 try {
                     console.log('Restoring PDF from session:', sessionData.pdfData.name);
                     currentPdfData = sessionData.pdfData.data;
                     currentPdfName = sessionData.pdfData.name;
                     currentPdfPage = sessionData.pdfData.currentPage || 1;
                     totalPdfPages = sessionData.pdfData.totalPages || 1;
                     if (sessionData.pdfData.zoom) {
                         pdfZoomLevel = sessionData.pdfData.zoom;
                     }

                     // Decode base64 PDF data
                     console.log('Decoding PDF data, length:', currentPdfData.length);
                     const binaryString = atob(currentPdfData);
                     const uint8Array = new Uint8Array(binaryString.length);
                     for (let i = 0; i < binaryString.length; i++) {
                         uint8Array[i] = binaryString.charCodeAt(i);
                     }

                     console.log('PDF data decoded, loading...');
                     // Load the PDF with a small delay to ensure DOM is ready
                     setTimeout(() => {
                         loadPdfFromData(uint8Array, currentPdfName);
                     }, 100);
                 } catch (pdfError) {
                     console.error('Error restoring PDF:', pdfError);
                     addChatMessage('System', 'Error restoring PDF: ' + pdfError.message);
                 }
             } else {
                 console.log('No PDF data found in session');
             }

             // Restore datasets
             if (sessionData.datasets && Array.isArray(sessionData.datasets)) {
                 importedDatasets.clear();
                 sessionData.datasets.forEach(dataset => {
                     importedDatasets.set(dataset.varName, {
                         filename: dataset.filename,
                         variable: dataset.variable,
                         info: dataset.info
                     });
                 });
                 updateDatasetList();
                 updateDatasetButton();
                 console.log('Datasets restored:', sessionData.datasets.length);
             }

             // Restore settings
             if (sessionData.settings) {
                 // Dark mode
                 if (sessionData.settings.darkMode !== document.documentElement.classList.contains('dark')) {
                     toggleDarkMode();
                 }

                 // Active tab
                 if (sessionData.settings.activeTab) {
                     switchTab(sessionData.settings.activeTab);
                 }

                 // Sidebar visibility
                 const sidebar = document.getElementById('ai-chat-sidebar');
                 const isCurrentlyVisible = !sidebar.classList.contains('hidden');
                 if (sessionData.settings.sidebarVisible !== isCurrentlyVisible) {
                     toggleChatSidebar();
                 }
             }

             // Restore uploaded files for group messaging
             if (sessionData.uploadedFiles) {
                 try {
                     const response = await fetch('/api/uploaded-files', {
                         method: 'POST',
                         headers: {
                             'Content-Type': 'application/json'
                         },
                         body: JSON.stringify({
                             files: sessionData.uploadedFiles
                         })
                     });

                     if (response.ok) {
                         const result = await response.json();
                         console.log('Uploaded files restored:', result.restored_count);
                     } else {
                         console.warn('Failed to restore uploaded files');
                     }
                 } catch (error) {
                     console.warn('Error restoring uploaded files:', error);
                 }
             }

             addChatMessage('System', `Session imported successfully! Loaded from ${sessionData.timestamp}`);
             console.log('Session imported successfully');

         } catch (error) {
             console.error('Error importing session:', error);
             addChatMessage('System', 'Error importing session: ' + error.message);
         }
     };

     reader.readAsText(file);
 }

 // Helper function to clear all Jupyter cells
 function clearAllCells() {
     cells.forEach(cell => {
         if (cell.element && cell.element.parentNode) {
             cell.element.parentNode.removeChild(cell.element);
         }
     });
     cells = [];
     cellCounter = 0;
 }

 // Helper function to load PDF from data
 async function loadPdfFromData(uint8Array, fileName) {
     try {
         console.log('Loading PDF from session data...', fileName);

         // Ensure PDF viewer is initialized
         if (!pdfContainer) {
             console.log('PDF container not initialized, initializing...');
             initializePdfViewer();
         }

         if (pdfLoading) pdfLoading.style.display = 'flex';
         if (pdfViewerArea) pdfViewerArea.classList.remove('hidden');

         const pdf = await pdfjsLib.getDocument(uint8Array).promise;

         currentPdfDoc = pdf;
         totalPdfPages = pdf.numPages;
         currentPdfPage = 1;

         console.log(`PDF loaded from session: ${totalPdfPages} pages`);

         // Update UI using the correct element references
         if (pdfFilename) pdfFilename.textContent = fileName;
         if (pdfInfo) pdfInfo.textContent = `${totalPdfPages} pages`;
         if (pdfTotalPages) pdfTotalPages.textContent = totalPdfPages;
         if (pdfPageInput) {
             pdfPageInput.value = currentPdfPage;
             pdfPageInput.max = totalPdfPages;
         }

         // Show loaded state
         if (pdfNotLoaded) pdfNotLoaded.classList.add('hidden');
         if (pdfLoaded) pdfLoaded.classList.remove('hidden');
         if (pdfControls) pdfControls.classList.remove('hidden');

         // Clear previous content and reset arrays
         if (pdfContainer) {
             pdfContainer.innerHTML = '';
         }
         pdfPages = [];
         pageElements = [];

         // Render all pages
         await renderAllPages();
         updateNavigationButtons();

         if (pdfLoading) pdfLoading.style.display = 'none';
         console.log('PDF rendering from session complete');

         // Switch to PDF viewer tab
         switchTab('pdf-viewer');

         addChatMessage('System', `PDF "${fileName}" restored successfully from session.`);

     } catch (error) {
         console.error('Error loading PDF from session:', error);
         if (pdfLoading) pdfLoading.style.display = 'none';
         addChatMessage('System', 'Error loading PDF from session: ' + error.message);

         // Reset PDF state on error
         currentPdfDoc = null;
         currentPdfData = null;
         currentPdfName = null;
         currentPdfPage = 1;
         totalPdfPages = 0;
     }
 }

 async function loadPdfFromBroadcastData(pdfPayload) {
 if (!pdfPayload || !pdfPayload.pdf_data) {
 return;
 }

 try {
 isApplyingBroadcastedPdf = true;
 console.log('üì° Loading host PDF broadcast:', pdfPayload.pdf_name);
 const binaryString = atob(pdfPayload.pdf_data);
 const uint8Array = new Uint8Array(binaryString.length);
 for (let i = 0; i < binaryString.length; i++) {
 uint8Array[i] = binaryString.charCodeAt(i);
 }
 await loadPdfFromData(uint8Array, pdfPayload.pdf_name || 'Shared PDF');
 currentPdfData = pdfPayload.pdf_data;
 currentPdfName = pdfPayload.pdf_name || currentPdfName;
 if (pdfPayload.current_page) {
 navigateToPage(pdfPayload.current_page);
 }
 } catch (error) {
 console.error('‚ùå Failed to load broadcasted PDF:', error);
 } finally {
 isApplyingBroadcastedPdf = false;
 }
 }

 // Debug function to test PDF state
 window.debugPdfState = function() {
     console.log('=== PDF State Debug ===');
     console.log('currentPdfDoc:', !!currentPdfDoc);
     console.log('currentPdfData:', !!currentPdfData);
     console.log('currentPdfName:', currentPdfName);
     console.log('currentPdfPage:', currentPdfPage);
     console.log('totalPdfPages:', totalPdfPages);
     console.log('pdfZoomLevel:', pdfZoomLevel);
     console.log('pdfContainer:', !!pdfContainer);
     console.log('PDF elements initialized:', {
         pdfNotLoaded: !!pdfNotLoaded,
         pdfLoaded: !!pdfLoaded,
         pdfViewerArea: !!pdfViewerArea,
         pdfFilename: !!pdfFilename,
         pdfInfo: !!pdfInfo
     });
 };

 // Debug function to test Jupyter state
 window.debugJupyterState = function() {
 console.log('=== Jupyter State Debug ===');
 console.log('cells.length:', cells.length);
 console.log('cellCounter:', cellCounter);
 console.log('pyodideReady:', pyodideReady);
 console.log('cells:', cells.map(cell => ({
 id: cell.id,
 hasCodeInput: !!cell.codeInput,
 codeLength: cell.codeInput ? cell.codeInput.value.length : 0,
 hasOutput: !!cell.outputContent
 })));
 };

 // Debug function to test persistence state
 window.debugPersistenceState = function() {
 console.log('=== Persistence State Debug ===');
 console.log('currentRoomId:', currentRoomId);
 console.log('isConnected:', isConnected);
 console.log('isInRoom:', currentRoomId && isConnected);

 const appState = localStorage.getItem('appState');
 if (appState) {
 const parsed = JSON.parse(appState);
 console.log('localStorage appState:', {
 hasPdfData: !!parsed.pdfData,
 pdfName: parsed.pdfData?.name,
 hasJupyterNotebook: !!parsed.jupyterNotebook,
 jupyterCells: parsed.jupyterNotebook?.cells?.length || 0,
 hasCanvasState: !!parsed.canvasState,
 canvasObjects: parsed.canvasState?.objects?.length || 0,
 hasChatHistory: !!parsed.aiChatHistory,
 chatMessages: parsed.aiChatHistory?.length || 0,
 isInRoom: parsed.isInRoom,
 timestamp: new Date(parsed.timestamp).toLocaleString()
 });
 } else {
 console.log('No appState in localStorage');
 }
 };

 // Event listeners for session management
 document.getElementById('save-session').addEventListener('click', async () => {
     try {
         await exportSession();
     } catch (error) {
         console.error('Error in save session:', error);
         addChatMessage('System', 'Error saving session: ' + error.message);
     }
 });

 document.getElementById('open-session').addEventListener('click', () => {
     document.getElementById('session-file-input').click();
 });

 document.getElementById('session-file-input').addEventListener('change', (e) => {
     const file = e.target.files[0];
     if (file && file.name.endsWith('.fluxnb')) {
         importSession(file);
     } else if (file) {
         addChatMessage('System', 'Please select a valid .fluxnb session file.');
     }
     e.target.value = ''; // Reset input
 });

 // ===== VOICE ASSISTANT IMPLEMENTATION =====

 // Voice Assistant State Management
 class VoiceAssistant {
     constructor() {
         this.isListening = false;
         this.isSpeaking = false;
         this.recognition = null;
         this.synthesis = window.speechSynthesis;
         this.currentUtterance = null;

         // Voice settings
         this.voiceSettings = {
             rate: 1.0,
             pitch: 1.0,
             volume: 1.0,
             voice: null
         };

         // Context tracking for voice interactions
         this.lastCanvasCapture = null;
         this.lastCanvasCaptureTime = 0;

         // Context detection keywords
         this.canvasKeywords = [
             'canvas', 'drawing', 'draw', 'sketch', 'image', 'picture', 'diagram',
             'graph', 'chart', 'whiteboard', 'board', 'screen', 'visual', 'see',
             'look', 'show', 'display', 'analyze', 'explain', 'solve',
             'calculate', 'math', 'equation', 'formula', 'problem'
         ];

         // Follow-up question patterns
         this.followUpPatterns = [
             /how does (this|that|it) work/i,
             /can you explain (this|that|it)/i,
             /what does (this|that|it) mean/i,
             /why (does|is) (this|that|it)/i,
             /how (do|can) i/i,
             /what if/i,
             /can you modify/i,
             /change (this|that|it)/i,
             /improve (this|that|it)/i,
             /add to (this|that|it)/i,
             /tell me more/i,
             /explain further/i,
             /give me an example/i,
             /show me how/i
         ];

         this.loadVoiceSettings();
         this.initializeVoiceRecognition();
         this.initializeEventListeners();
         this.initializeVoiceSettings();
         this.forceVoiceInitialization();
         this.updateVoiceStatus('Ready');
     }

     initializeVoiceRecognition() {
         // Check for browser support
         if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
             console.error('Speech recognition not supported in this browser');
             this.updateVoiceStatus('Not Supported');
             return;
         }

         // Initialize speech recognition
         const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
         this.recognition = new SpeechRecognition();

         // Configure recognition settings
         this.recognition.continuous = false;
         this.recognition.interimResults = false;
         this.recognition.lang = 'en-US';
         this.recognition.maxAlternatives = 1;

         // Set up event handlers
         this.recognition.onstart = () => {
             console.log('üé§ Voice recognition started');
             this.isListening = true;
             this.updateVoiceUI(true);
             this.updateVoiceStatus('Listening...');
         };

         this.recognition.onresult = (event) => {
             const transcript = event.results[0][0].transcript;
             console.log('üé§ Voice input received:', transcript);
             this.handleVoiceInput(transcript);
         };

         this.recognition.onerror = (event) => {
             console.error('üé§ Voice recognition error:', event.error);
             this.handleVoiceError(event.error);
         };

         this.recognition.onend = () => {
             console.log('üé§ Voice recognition ended');
             this.isListening = false;
             this.updateVoiceUI(false);
             this.updateVoiceStatus('Ready');
         };
     }

     initializeEventListeners() {
         const voiceBtn = document.getElementById('voice-assistant-btn');
         if (voiceBtn) {
             voiceBtn.addEventListener('click', () => {
                 // If speaking, stop speaking first
                 if (this.isSpeaking) {
                     this.stopSpeaking();
                     return;
                 }

                 // If listening, stop listening
                 if (this.isListening) {
                     this.stopListening();
                 } else {
                     this.startListening();
                 }
             });
         }

         // Escape key to stop voice operations (keep this inside the class)
         document.addEventListener('keydown', (e) => {
             if (e.key === 'Escape' && this.isActive()) {
                 e.preventDefault();
                 console.log('üé§ Escape key - stopping voice operations');
                 this.stopListening();
                 this.stopSpeaking();
             }
         });
     }

     initializeVoiceSettings() {
         // Wait for voices to be loaded
         const loadVoices = () => {
             const voices = this.getAvailableVoices();
             if (voices.length > 0) {
                 console.log('üé§ Available voices:', voices.map(v => `${v.name} (${v.lang})`));

                 // Set default voice if none selected - prioritize Google US English
                 if (!this.voiceSettings.voice && voices.length > 0) {
                     // Priority order for default voice selection
                     const preferredVoice =
                         // 1st priority: Google US English
                         voices.find(v =>
                             v.name.toLowerCase().includes('google') &&
                             v.lang === 'en-US'
                         ) ||
                         // 2nd priority: Any Google English voice
                         voices.find(v =>
                             v.name.toLowerCase().includes('google') &&
                             v.lang.startsWith('en')
                         ) ||
                         // 3rd priority: US English voices
                         voices.find(v => v.lang === 'en-US') ||
                         // 4th priority: Any English voice
                         voices.find(v => v.lang.startsWith('en')) ||
                         // Fallback: First available voice
                         voices[0];

                     this.voiceSettings.voice = preferredVoice;
                     this.updateVoiceSettings({ voice: preferredVoice });
                     console.log('üé§ Default voice set:', preferredVoice.name, preferredVoice.lang);
                 }
             } else {
                 // Retry after a short delay
                 setTimeout(loadVoices, 100);
             }
         };

         // Enhanced voice loading for mobile browsers
         const forceVoiceLoad = () => {
             // Force voice loading on mobile browsers
             if (this.synthesis.getVoices().length === 0) {
                 // Create a dummy utterance to trigger voice loading
                 const dummyUtterance = new SpeechSynthesisUtterance('');
                 this.synthesis.speak(dummyUtterance);
                 this.synthesis.cancel();
             }
             loadVoices();
         };

         // Load voices when they become available
         if (this.synthesis.getVoices().length > 0) {
             loadVoices();
         } else {
             // Multiple strategies for voice loading
             this.synthesis.addEventListener('voiceschanged', loadVoices);

             // Force load after delay (mobile browsers)
             setTimeout(forceVoiceLoad, 100);
             setTimeout(forceVoiceLoad, 500);
             setTimeout(forceVoiceLoad, 1000);
         }

         // Additional mobile browser support
         document.addEventListener('click', () => {
             if (this.synthesis.getVoices().length === 0) {
                 forceVoiceLoad();
             }
         }, { once: true });
     }

     forceVoiceInitialization() {
         // Force voice initialization for mobile browsers
         console.log('üé§ Forcing voice initialization...');

         // Create and immediately cancel a speech to wake up the synthesis engine
         const initUtterance = new SpeechSynthesisUtterance('');
         initUtterance.volume = 0; // Silent
         this.synthesis.speak(initUtterance);
         this.synthesis.cancel();

         // Set default voice immediately if available
         setTimeout(() => {
             const voices = this.synthesis.getVoices();
             if (voices.length > 0 && !this.voiceSettings.voice) {
                 const googleUSVoice = voices.find(v =>
                     v.name.toLowerCase().includes('google') && v.lang === 'en-US'
                 ) || voices.find(v => v.lang === 'en-US') || voices[0];

                 this.voiceSettings.voice = googleUSVoice;
                 this.updateVoiceSettings({ voice: googleUSVoice });
                 console.log('üé§ Force-initialized voice:', googleUSVoice.name);
             }
         }, 100);
     }

     startListening(isPdfContext = false) {
         if (!this.recognition) {
             alert('Voice recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
             return;
         }

         if (this.isListening) {
             console.log('üé§ Already listening');
             return;
         }

         // Store PDF context flag
         this.isPdfContext = isPdfContext;

         // Request microphone permission and start recognition
         navigator.mediaDevices.getUserMedia({ audio: true })
             .then(() => {
                 console.log('üé§ Microphone access granted');
                 if (isPdfContext) {
                     console.log('üìÑ Voice AI started with PDF context');
                 }
                 this.recognition.start();
             })
             .catch((error) => {
                 console.error('üé§ Microphone access denied:', error);
                 alert('Microphone access is required for voice input. Please allow microphone access and try again.');
             });
     }

     stopListening() {
         if (this.recognition && this.isListening) {
             this.recognition.stop();
         }
     }

     async handleVoiceInput(transcript) {
         try {
             this.updateVoiceStatus('Processing...');

             let imageData = null;
             let contextType = '';

             // Check if this is PDF context or canvas context
             if (this.isPdfContext && currentPdfDoc) {
                 // Capture PDF page screenshot
                 console.log('üìÑ Capturing PDF page for voice query...');
                 imageData = capturePdfPageScreenshot();
                 contextType = 'PDF';
             } else {
                 // Capture canvas for voice queries
                 console.log('üì∏ Auto-capturing canvas for voice query...');
                 imageData = await this.captureCanvasForVoice();
                 contextType = 'Canvas';
             }

             // Detect context for prompt enhancement
             const isCanvasQuery = this.detectCanvasContext(transcript);
             const isPdfQuery = this.isPdfContext || this.detectPdfContext(transcript);
             console.log('üß† Context detected:', { canvas: isCanvasQuery, pdf: isPdfQuery, type: contextType });

             // Send to AI with voice-specific prompt enhancement
             const enhancedPrompt = this.enhancePromptForVoice(transcript, isCanvasQuery, isPdfQuery, contextType);

             // Add voice interaction to chat history with appropriate indicator
             const indicator = this.isPdfContext ? 'üé§üìÑ' : 'üé§';
             addChatMessage('User', `${indicator} ${transcript}`, false, imageData, null);

             // Send to Gemini API
             await this.sendVoiceQueryToAI(enhancedPrompt, imageData);

             // Reset PDF context flag after use
             this.isPdfContext = false;

         } catch (error) {
             console.error('üé§ Error processing voice input:', error);
             this.updateVoiceStatus('Error');
             this.speakResponse('Sorry, I encountered an error processing your voice input.');
         }
     }

     detectCanvasContext(transcript) {
         const lowerTranscript = transcript.toLowerCase();

         // Add to main chat history for proper memory integration
         const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
         const historyEntry = { sender: 'user', message: transcript, timestamp: Date.now(), id: messageId };
         chatHistoryStorage.push(historyEntry);

         // Check if we're discussing code from a previous response
         const isDiscussingCode = this.isDiscussingPreviousCode(transcript);
         if (isDiscussingCode) {
             console.log('üß† Detected follow-up question about code - no canvas needed');
             return false;
         }

         // Check for explicit visual references
         const visualReferencePatterns = [
             /what.*this.*drawing/i,
             /what.*this.*image/i,
             /what.*this.*diagram/i,
             /what.*on.*canvas/i,
             /what.*on.*screen/i,
             /analyze.*this.*image/i,
             /solve.*this.*problem/i,
             /explain.*this.*diagram/i,
             /what.*see.*here/i,
             /what.*shown.*here/i
         ];

         const hasVisualReference = visualReferencePatterns.some(pattern =>
             pattern.test(transcript)
         );

         // Check for new visual content keywords
         const newVisualKeywords = ['new', 'different', 'another', 'current', 'fresh'];
         const hasNewVisualKeyword = newVisualKeywords.some(keyword =>
             lowerTranscript.includes(keyword) &&
             (lowerTranscript.includes('drawing') || lowerTranscript.includes('diagram') || lowerTranscript.includes('image'))
         );

         // Only capture canvas for explicit visual references or new content
         const needsCanvas = hasVisualReference || hasNewVisualKeyword;

         console.log('üß† Context analysis:', {
             transcript: transcript.substring(0, 50) + '...',
             isDiscussingCode,
             hasVisualReference,
             hasNewVisualKeyword,
             needsCanvas
         });

         return needsCanvas;
     }

     detectPdfContext(transcript) {
         const lowerTranscript = transcript.toLowerCase();

         // Check for PDF-specific keywords
         const pdfKeywords = [
             'page', 'document', 'pdf', 'text', 'paragraph', 'section',
             'chapter', 'read', 'explain', 'summarize', 'what does this say',
             'what is written', 'content', 'passage', 'article'
         ];

         return pdfKeywords.some(keyword => lowerTranscript.includes(keyword));
     }

     isDiscussingPreviousCode(transcript) {
         const lowerTranscript = transcript.toLowerCase();

         // Check if last AI response contained code using main chat history
         const recentAIMessages = chatHistoryStorage
             .filter(msg => msg.sender === 'ai')
             .slice(-3); // Check last 3 AI messages

         if (recentAIMessages.length === 0) return false;

         const lastResponse = recentAIMessages[recentAIMessages.length - 1];
         const lastResponseText = lastResponse.message.toLowerCase();
         const hasCodeInLastResponse = lastResponseText.includes('```') ||
                                     lastResponseText.includes('function') ||
                                     lastResponseText.includes('class') ||
                                     lastResponseText.includes('def ') ||
                                     lastResponseText.includes('var ') ||
                                     lastResponseText.includes('let ') ||
                                     lastResponseText.includes('const ');

         if (!hasCodeInLastResponse) return false;

         // Check if current question is about the code
         const codeQuestionPatterns = [
             /how.*work/i,
             /what.*do/i,
             /explain.*code/i,
             /explain.*function/i,
             /explain.*this/i,
             /what.*mean/i,
             /how.*use/i,
             /modify.*this/i,
             /change.*this/i,
             /improve.*this/i,
             /fix.*this/i,
             /debug.*this/i,
             /error.*this/i,
             /why.*not.*work/i
         ];

         return codeQuestionPatterns.some(pattern => pattern.test(transcript));
     }



     async captureCanvasForVoice() {
         try {
             // Ensure proper background for screenshot
             const originalBackgroundColor = fabricCanvas.backgroundColor;
             if (fabricCanvas.backgroundColor === 'transparent' || !fabricCanvas.backgroundColor) {
                 fabricCanvas.backgroundColor = document.documentElement.classList.contains('dark') ? '#0f172a' : '#FFFFFF';
             }

             fabricCanvas.renderAll();
             const dataURL = fabricCanvas.toDataURL({ format: 'png', quality: 0.9 });

             // Restore original background
             fabricCanvas.backgroundColor = originalBackgroundColor;
             fabricCanvas.renderAll();

             console.log('üì∏ Canvas captured for voice query, data URL length:', dataURL.length);
             return dataURL;

         } catch (error) {
             console.error('üì∏ Failed to capture canvas for voice query:', error);
             return null;
         }
     }

     enhancePromptForVoice(transcript, isCanvasQuery, isPdfQuery, contextType) {
         let enhancedPrompt = transcript;

         // Add conversation context
         const recentContext = this.getRecentConversationContext();
         if (recentContext) {
             enhancedPrompt = `${recentContext}\n\nCurrent question: ${transcript}`;
         }

         // Add context-specific instructions
         if (contextType === 'PDF') {
             enhancedPrompt = `[Voice Query with PDF Context] ${enhancedPrompt}. Please analyze the provided PDF page image and respond accordingly. Focus on the text and content visible in the PDF. Use clear, conversational language suitable for voice response.`;
         } else {
             enhancedPrompt = `[Voice Query with Canvas Context] ${enhancedPrompt}. Please analyze the provided canvas image and respond accordingly. Use clear, conversational language suitable for voice response.`;
         }

         // Add LaTeX formatting instruction for math content
         enhancedPrompt += " If your response contains mathematical expressions, format them using LaTeX notation.";

         return enhancedPrompt;
     }

     getRecentConversationContext() {
         // Use main chat history for better context integration
         const chatContext = getChatHistory(8); // Get last 8 messages

         if (!chatContext || chatContext.trim().length === 0) {
             return null;
         }

         return `Previous conversation context:\n${chatContext}`;
     }

    async sendVoiceQueryToAI(prompt, imageData) {
        let slowNetworkTimer = null;
        try {
            // Check message limit before sending
            if (window.aiSettings && !window.aiSettings.incrementMessageCount()) {
                this.updateVoiceStatus('Message limit reached');
                return;
            }

             this.updateVoiceStatus('Asking AI...');

             // Prepare payload similar to existing sendToGemini function
             const payload = {
                message: prompt
            };

             // Add custom API key and model if available
             if (window.aiSettings) {
                 const customApiKey = window.aiSettings.getApiKey();
                 const selectedModel = window.aiSettings.getSelectedModel();

                 if (customApiKey) {
                     payload.customApiKey = customApiKey;
                     console.log('üîë Voice: Using custom API key');
                 }

                 payload.model = selectedModel;
                 console.log('ü§ñ Voice: Using model:', selectedModel);
             }

             if (imageData) {
                 const parts = imageData.split(',');
                 if (parts.length === 2) {
                     payload.image_data = parts[1];
                     console.log('üñºÔ∏è Image data included in voice query');
                 }
             }

            // Warn users if network is dragging before we even get a response
            slowNetworkTimer = setTimeout(() => {
                console.warn('üé§ Voice request still processing - slow connection detected');
                this.updateVoiceStatus('Still working...');
                addChatMessage('System', 'üì° Voice request is taking longer than usual because of a slow connection. Please hold on.', false);
            }, VOICE_AI_SLOW_NETWORK_WARNING_MS);

            // Send to backend with the extended timeout
            const response = await fetchWithTimeout(`${GEMINI_BACKEND_URL}/api/chat`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }, VOICE_AI_REQUEST_TIMEOUT_MS);

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

             const data = await response.json();
             const aiResponse = data.response || "I couldn't generate a response.";

             // Add AI response to chat (this automatically adds to main chat history)
             addChatMessage('AI', ` ${aiResponse}`, false);

             // Speak the response
             this.updateVoiceStatus('Speaking...');
             await this.speakResponse(aiResponse);

        } catch (error) {
            console.error('üé§ Error sending voice query to AI:', error);
            const isTimeoutError = error.message && error.message.toLowerCase().includes('timed out');
            const errorMessage = isTimeoutError
                ? 'The network is extremely slow and the voice request timed out. Please try again after improving the connection.'
                : `Sorry, I encountered an error: ${error.message}`;

            if (isTimeoutError) {
                this.updateVoiceStatus('Timeout');
            }

            addChatMessage('AI', `üîä ${errorMessage}`, false);
            await this.speakResponse(errorMessage);
        } finally {
            if (slowNetworkTimer) {
                clearTimeout(slowNetworkTimer);
            }
        }
    }

     async speakResponse(text) {
         try {
             // Stop any current speech
             this.synthesis.cancel();

             // Clean text for speech (remove HTML tags and LaTeX)
             const cleanText = this.cleanTextForSpeech(text);

             if (!cleanText.trim()) {
                 console.log('üîä No text to speak');
                 this.updateVoiceStatus('Ready');
                 return;
             }

             console.log('üîä Preparing to speak:', cleanText.substring(0, 100) + '...');
             this.updateVoiceStatus('Speaking...');
             this.isSpeaking = true;

             // Create utterance
             this.currentUtterance = new SpeechSynthesisUtterance(cleanText);

             // Apply voice settings
             this.currentUtterance.rate = this.voiceSettings.rate;
             this.currentUtterance.pitch = this.voiceSettings.pitch;
             this.currentUtterance.volume = this.voiceSettings.volume;

             // Enhanced voice selection for mobile browsers
             if (this.voiceSettings.voice) {
                 this.currentUtterance.voice = this.voiceSettings.voice;
             } else {
                 // Force default voice selection if none set
                 const voices = this.synthesis.getVoices();
                 const defaultVoice = voices.find(v =>
                     v.name.toLowerCase().includes('google') && v.lang === 'en-US'
                 ) || voices.find(v => v.lang === 'en-US') || voices[0];

                 if (defaultVoice) {
                     this.currentUtterance.voice = defaultVoice;
                     this.voiceSettings.voice = defaultVoice;
                     console.log('üîä Using fallback voice:', defaultVoice.name);
                 }
             }

             // Set up event handlers
             this.currentUtterance.onstart = () => {
                 console.log('üîä Speech synthesis started');
                 this.updateVoiceUI(false); // Update UI to show speaking state
             };

             this.currentUtterance.onend = () => {
                 console.log('üîä Speech synthesis ended');
                 this.isSpeaking = false;
                 this.updateVoiceStatus('Ready');
                 this.updateVoiceUI(false); // Reset UI to normal state
             };

             this.currentUtterance.onerror = (event) => {
                 console.error('üîä Speech synthesis error:', event.error);
                 this.isSpeaking = false;
                 this.updateVoiceStatus('Ready');
                 this.updateVoiceUI(false); // Reset UI to normal state
                 addChatMessage('System', `üîä Speech error: ${event.error}`, false);
             };

             // Start speaking with mobile browser support
             console.log('üîä Starting speech synthesis with settings:', this.voiceSettings);

             // Mobile browser fix: Resume synthesis if paused
             if (this.synthesis.paused) {
                 this.synthesis.resume();
             }

             this.synthesis.speak(this.currentUtterance);

             // Mobile browser fix: Force start if needed
             setTimeout(() => {
                 if (this.synthesis.paused) {
                     this.synthesis.resume();
                 }
             }, 100);

            // Fallback timeout in case speech doesn't start
            setTimeout(() => {
                if (this.isSpeaking && this.synthesis.speaking === false) {
                    console.log('üîä Speech synthesis timeout - resetting status');
                    this.isSpeaking = false;
                    this.updateVoiceStatus('Ready');
                }
            }, 6000); // Increased timeout for slow devices/networks

         } catch (error) {
             console.error('üîä Error in speech synthesis:', error);
             this.isSpeaking = false;
             this.updateVoiceStatus('Ready');
             addChatMessage('System', `üîä Speech synthesis error: ${error.message}`, false);
         }
     }

     cleanTextForSpeech(text) {
         // Remove HTML tags
         let cleanText = text.replace(/<[^>]*>/g, '');

         // Remove LaTeX math expressions and replace with spoken equivalents
         cleanText = cleanText.replace(/\$\$([^$]+)\$\$/g, (match, math) => {
             return ` mathematical expression: ${math} `;
         });

         cleanText = cleanText.replace(/\$([^$]+)\$/g, (match, math) => {
             return ` ${math} `;
         });

         // Replace common mathematical symbols with spoken words
         cleanText = cleanText.replace(/\+/g, ' plus ');
         cleanText = cleanText.replace(/-/g, ' minus ');
         cleanText = cleanText.replace(/\*/g, ' times ');
         cleanText = cleanText.replace(/\//g, ' divided by ');
         cleanText = cleanText.replace(/=/g, ' equals ');
         cleanText = cleanText.replace(/\^/g, ' to the power of ');

         // Clean up extra whitespace
         cleanText = cleanText.replace(/\s+/g, ' ').trim();

         return cleanText;
     }

     updateVoiceUI(isRecording) {
         const voiceBtn = document.getElementById('voice-assistant-btn');
         const voiceIcon = document.getElementById('voice-icon');
         const voiceBtnText = document.getElementById('voice-btn-text');
         const recordingIndicator = document.getElementById('voice-recording-indicator');

         if (isRecording) {
             if (recordingIndicator) recordingIndicator.style.opacity = '1';
             if (voiceBtnText) voiceBtnText.textContent = 'Stop';
             if (voiceBtn) {
                 voiceBtn.classList.add('voice-listening');
                 voiceBtn.style.transform = 'scale(1.05)';
             }
         } else if (this.isSpeaking) {
             // Show speaking state
             if (recordingIndicator) recordingIndicator.style.opacity = '0';
             if (voiceBtnText) voiceBtnText.textContent = 'Stop';
             if (voiceBtn) {
                 voiceBtn.classList.remove('voice-listening');
                 voiceBtn.style.transform = 'scale(1.02)';
                 voiceBtn.style.background = 'linear-gradient(to right, #f59e0b, #d97706)';
             }
         } else {
             // Reset to normal state
             if (recordingIndicator) recordingIndicator.style.opacity = '0';
             if (voiceBtnText) voiceBtnText.textContent = 'Voice';
             if (voiceBtn) {
                 voiceBtn.classList.remove('voice-listening');
                 voiceBtn.style.transform = 'scale(1)';
                 voiceBtn.style.background = '';
             }
         }
     }

     updateVoiceStatus(status) {
         const statusElement = document.getElementById('voice-status-text');
         const indicatorElement = document.getElementById('voice-status-indicator');
         const containerElement = document.getElementById('voice-assistant-status');

         if (statusElement) {
             statusElement.textContent = status;
         }

         if (indicatorElement && containerElement) {
             // Show status container
             containerElement.classList.remove('hidden');

             // Update indicator color based on status
             indicatorElement.className = 'w-2 h-2 rounded-full';

             switch (status.toLowerCase()) {
                 case 'ready':
                     indicatorElement.classList.add('bg-green-500');
                     break;
                 case 'listening...':
                     indicatorElement.classList.add('bg-blue-500', 'animate-pulse');
                     break;
                 case 'processing...':
                 case 'asking ai...':
                     indicatorElement.classList.add('bg-yellow-500', 'animate-pulse');
                     break;
                 case 'speaking...':
                     indicatorElement.classList.add('bg-purple-500', 'animate-pulse');
                     break;
                 case 'error':
                     indicatorElement.classList.add('bg-red-500');
                     break;
                 case 'not supported':
                     indicatorElement.classList.add('bg-gray-500');
                     containerElement.classList.add('hidden');
                     break;
                 default:
                     indicatorElement.classList.add('bg-green-500');
             }
         }

         console.log('üé§ Voice status updated:', status);
     }

     handleVoiceError(error) {
         let errorMessage = 'Voice recognition error occurred.';
         let shouldShowAlert = false;

         switch (error) {
             case 'no-speech':
                 errorMessage = 'No speech was detected. Please try again.';
                 break;
             case 'audio-capture':
                 errorMessage = 'Audio capture failed. Please check your microphone.';
                 shouldShowAlert = true;
                 break;
             case 'not-allowed':
                 errorMessage = 'Microphone access was denied. Please allow microphone access.';
                 shouldShowAlert = true;
                 break;
             case 'network':
                 errorMessage = 'Network error occurred during voice recognition.';
                 shouldShowAlert = true;
                 break;
             case 'aborted':
                 errorMessage = 'Voice recognition was aborted.';
                 break;
             case 'service-not-allowed':
                 errorMessage = 'Speech recognition service is not allowed.';
                 shouldShowAlert = true;
                 break;
             case 'bad-grammar':
                 errorMessage = 'Speech recognition grammar error.';
                 break;
             case 'language-not-supported':
                 errorMessage = 'Language not supported for speech recognition.';
                 shouldShowAlert = true;
                 break;
         }

         console.error('üé§ Voice error:', error, errorMessage);
         this.updateVoiceStatus('Error');

         // Add error message to chat for user feedback
         addChatMessage('System', `üé§ Voice Assistant: ${errorMessage}`, false);

         // Show alert for critical errors
         if (shouldShowAlert) {
             setTimeout(() => {
                 alert(errorMessage);
             }, 100);
         }

         // Reset status after delay
         setTimeout(() => {
             this.updateVoiceStatus('Ready');
         }, 3000);
     }

     // Voice settings management
     updateVoiceSettings(settings) {
         this.voiceSettings = { ...this.voiceSettings, ...settings };
         localStorage.setItem('voiceAssistantSettings', JSON.stringify(this.voiceSettings));
         console.log('üé§ Voice settings updated:', this.voiceSettings);
     }

     loadVoiceSettings() {
         try {
             const saved = localStorage.getItem('voiceAssistantSettings');
             if (saved) {
                 this.voiceSettings = { ...this.voiceSettings, ...JSON.parse(saved) };
                 console.log('üé§ Voice settings loaded:', this.voiceSettings);
             }
         } catch (error) {
             console.error('üé§ Error loading voice settings:', error);
         }
     }

     getAvailableVoices() {
         return this.synthesis.getVoices().filter(voice => voice.lang.startsWith('en'));
     }

     setVoice(voiceIndex) {
         const voices = this.getAvailableVoices();
         if (voiceIndex >= 0 && voiceIndex < voices.length) {
             this.voiceSettings.voice = voices[voiceIndex];
             this.updateVoiceSettings({ voice: voices[voiceIndex] });
         }
     }

     setRate(rate) {
         const clampedRate = Math.max(0.1, Math.min(3.0, rate));
         this.updateVoiceSettings({ rate: clampedRate });
     }

     setPitch(pitch) {
         const clampedPitch = Math.max(0.0, Math.min(2.0, pitch));
         this.updateVoiceSettings({ pitch: clampedPitch });
     }

     setVolume(volume) {
         const clampedVolume = Math.max(0.0, Math.min(1.0, volume));
         this.updateVoiceSettings({ volume: clampedVolume });
     }



     // Public methods for external control
     stopSpeaking() {
         if (this.synthesis && this.isSpeaking) {
             this.synthesis.cancel();
             this.isSpeaking = false;
             this.updateVoiceStatus('Ready');
             this.updateVoiceUI(false); // Reset UI to normal state
             console.log('üîä Speech stopped by user');
         }
     }

     isActive() {
         return this.isListening || this.isSpeaking;
     }

     // Test voice functionality
     testVoice() {
         this.speakResponse("Voice assistant is working correctly. You can now use voice commands to interact with the AI.");
     }
 }

 // Initialize Voice Assistant
 const voiceAssistant = new VoiceAssistant();

 // Read Message Aloud Function
 function readMessageAloud(message, messageId) {
     try {
         // Stop any current speech
         if (voiceAssistant.synthesis.speaking) {
             voiceAssistant.synthesis.cancel();
             // Remove reading class from all buttons
             document.querySelectorAll('.message-read-aloud-button.reading').forEach(btn => {
                 btn.classList.remove('reading');
             });
             return;
         }

         // Find the button for this message and add reading class
         const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
         const readButton = messageElement?.querySelector('.message-read-aloud-button');

         if (readButton) {
             readButton.classList.add('reading');
         }

         // Use the voice assistant's speakResponse method to maintain consistency
         voiceAssistant.speakResponse(message).then(() => {
             // Remove reading class when done
             if (readButton) {
                 readButton.classList.remove('reading');
             }
         }).catch((error) => {
             console.error('Error reading message aloud:', error);
             if (readButton) {
                 readButton.classList.remove('reading');
             }
         });

         console.log('üîä Reading message aloud:', message.substring(0, 50) + '...');
     } catch (error) {
         console.error('Error in readMessageAloud:', error);
     }
 }

 // Stop all speech function
 function stopAllSpeech() {
     if (voiceAssistant.synthesis.speaking) {
         voiceAssistant.synthesis.cancel();
         // Remove reading class from all buttons
         document.querySelectorAll('.message-read-aloud-button.reading').forEach(btn => {
             btn.classList.remove('reading');
         });
         console.log('üîá Stopped all speech');
     }
 }

 // Add keyboard shortcut to stop speech (Escape key)
 document.addEventListener('keydown', (e) => {
     if (e.key === 'Escape' && voiceAssistant.synthesis.speaking) {
         e.preventDefault();
         stopAllSpeech();
     }
 });

 // Add global keyboard shortcut for voice activation (Ctrl/Cmd + Shift + V)
 document.addEventListener('keydown', (e) => {
     // Only handle if not typing in input fields
     if (document.activeElement && (
         document.activeElement.tagName === 'INPUT' ||
         document.activeElement.tagName === 'TEXTAREA' ||
         document.activeElement.contentEditable === 'true'
     )) {
         return;
     }

     if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'V') {
         e.preventDefault();
         console.log('üé§ Global voice shortcut triggered - Ctrl+Shift+V');

         // If speaking, stop speaking first
         if (voiceAssistant.isSpeaking) {
             voiceAssistant.stopSpeaking();
             return;
         }

         // If listening, stop listening, otherwise start
         if (voiceAssistant.isListening) {
             voiceAssistant.stopListening();
         } else {
             voiceAssistant.startListening();
         }
     }
 });

 // Voice Settings Modal Management
 function showVoiceSettings() {
     const modal = document.getElementById('voice-settings-modal');
     if (modal) {
         // Update current settings in the modal
         const rateSlider = document.getElementById('voice-rate-slider');
         const pitchSlider = document.getElementById('voice-pitch-slider');
         const volumeSlider = document.getElementById('voice-volume-slider');
         const voiceSelect = document.getElementById('voice-select');

         if (rateSlider) rateSlider.value = voiceAssistant.voiceSettings.rate;
         if (pitchSlider) pitchSlider.value = voiceAssistant.voiceSettings.pitch;
         if (volumeSlider) volumeSlider.value = voiceAssistant.voiceSettings.volume;

         // Populate voice options
         if (voiceSelect) {
             voiceSelect.innerHTML = '';
             const voices = voiceAssistant.getAvailableVoices();
             voices.forEach((voice, index) => {
                 const option = document.createElement('option');
                 option.value = index;
                 option.textContent = `${voice.name} (${voice.lang})`;
                 if (voice === voiceAssistant.voiceSettings.voice) {
                     option.selected = true;
                 }
                 voiceSelect.appendChild(option);
             });
         }

         modal.classList.remove('hidden');
     }
 }

 function hideVoiceSettings() {
     const modal = document.getElementById('voice-settings-modal');
     if (modal) {
         modal.classList.add('hidden');
     }
 }

 // Voice Settings Event Listeners
 const voiceSettingsBtn = document.getElementById('voice-settings-btn');
 if (voiceSettingsBtn) {
     voiceSettingsBtn.addEventListener('click', showVoiceSettings);
 }

 // Voice settings modal event listeners - Initialize immediately since DOM is already loaded
 function initializeVoiceSettingsModal() {
     const modal = document.getElementById('voice-settings-modal');
     const cancelBtn = document.getElementById('cancel-voice-settings');
     const saveBtn = document.getElementById('save-voice-settings');
     const testBtn = document.getElementById('test-voice-btn');
     const resetBtn = document.getElementById('reset-voice-settings-btn');

     const rateSlider = document.getElementById('voice-rate-slider');
     const pitchSlider = document.getElementById('voice-pitch-slider');
     const volumeSlider = document.getElementById('voice-volume-slider');
     const voiceSelect = document.getElementById('voice-select');

     const rateValue = document.getElementById('rate-value');
     const pitchValue = document.getElementById('pitch-value');
     const volumeValue = document.getElementById('volume-value');

     // Update value displays
     if (rateSlider && rateValue) {
         rateSlider.addEventListener('input', (e) => {
             rateValue.textContent = e.target.value;
         });
     }

     if (pitchSlider && pitchValue) {
         pitchSlider.addEventListener('input', (e) => {
             pitchValue.textContent = e.target.value;
         });
     }

     if (volumeSlider && volumeValue) {
         volumeSlider.addEventListener('input', (e) => {
             volumeValue.textContent = e.target.value;
         });
     }

     // Modal controls
     if (cancelBtn) {
         cancelBtn.addEventListener('click', hideVoiceSettings);
     }

     if (saveBtn) {
         saveBtn.addEventListener('click', () => {
             // Save settings
             if (rateSlider) voiceAssistant.setRate(parseFloat(rateSlider.value));
             if (pitchSlider) voiceAssistant.setPitch(parseFloat(pitchSlider.value));
             if (volumeSlider) voiceAssistant.setVolume(parseFloat(volumeSlider.value));
             if (voiceSelect) voiceAssistant.setVoice(parseInt(voiceSelect.value));

             hideVoiceSettings();
             addChatMessage('System', 'üé§ Voice settings saved successfully!', false);
         });
     }

     if (testBtn) {
         testBtn.addEventListener('click', () => {
             // Apply current settings temporarily and test
             const tempSettings = {
                 rate: rateSlider ? parseFloat(rateSlider.value) : 1.0,
                 pitch: pitchSlider ? parseFloat(pitchSlider.value) : 1.0,
                 volume: volumeSlider ? parseFloat(volumeSlider.value) : 1.0
             };

             if (voiceSelect) {
                 const voices = voiceAssistant.getAvailableVoices();
                 tempSettings.voice = voices[parseInt(voiceSelect.value)];
             }

             // Temporarily apply settings
             const originalSettings = { ...voiceAssistant.voiceSettings };
             voiceAssistant.voiceSettings = { ...voiceAssistant.voiceSettings, ...tempSettings };

             // Test voice
             voiceAssistant.speakResponse("This is a test of the voice assistant settings. How does this sound?");

             // Restore original settings after test
             setTimeout(() => {
                 voiceAssistant.voiceSettings = originalSettings;
             }, 100);
         });
     }

     if (resetBtn) {
         resetBtn.addEventListener('click', () => {
             // Reset to defaults
             if (rateSlider) {
                 rateSlider.value = 1.0;
                 rateValue.textContent = '1.0';
             }
             if (pitchSlider) {
                 pitchSlider.value = 1.0;
                 pitchValue.textContent = '1.0';
             }
             if (volumeSlider) {
                 volumeSlider.value = 1.0;
                 volumeValue.textContent = '1.0';
             }
             if (voiceSelect) {
                 voiceSelect.selectedIndex = 0;
             }
         });
     }

     // Close modal when clicking outside
     if (modal) {
         modal.addEventListener('click', (e) => {
             if (e.target === modal) {
                 hideVoiceSettings();
             }
         });
     }
 }

 // Initialize the voice settings modal
 initializeVoiceSettingsModal();

 // Make voice assistant globally accessible for debugging
 window.voiceAssistant = voiceAssistant;

 // ===== MATHJAX HELPER FUNCTIONS =====
 function reprocessMathJax(element = null) {
     if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
         const targetElement = element || document.getElementById('chat-history');
         if (targetElement) {
             MathJax.typesetPromise([targetElement]).catch((err) =>
                 console.error('MathJax re-processing error:', err)
             );
         }
     }
 }

 // Make MathJax reprocessing globally accessible
 window.reprocessMathJax = reprocessMathJax;

 // ===== AI SETTINGS SYSTEM =====
 class AISettingsManager {
     constructor() {
         this.settings = {
             customApiKey: '',
             selectedModel: 'gemini-2.5-flash',
             messageLimit: 100,
             messageCount: 0,
             lastResetDate: new Date().toDateString()
         };

         this.loadSettings();
         this.initializeEventListeners();
         this.updateUI();
         this.checkMessageReset();
     }

     loadSettings() {
         try {
             const saved = localStorage.getItem('aiSettings');
             if (saved) {
                 this.settings = { ...this.settings, ...JSON.parse(saved) };
                 console.log('ü§ñ AI settings loaded:', this.settings);
             }
         } catch (error) {
             console.error('ü§ñ Error loading AI settings:', error);
         }
     }

     saveSettings() {
         try {
             localStorage.setItem('aiSettings', JSON.stringify(this.settings));
             console.log('ü§ñ AI settings saved:', this.settings);
         } catch (error) {
             console.error('ü§ñ Error saving AI settings:', error);
         }
     }

     checkMessageReset() {
         const today = new Date().toDateString();
         if (this.settings.lastResetDate !== today) {
             this.settings.messageCount = 0;
             this.settings.lastResetDate = today;
             this.saveSettings();
             console.log('ü§ñ Message count reset for new day');
         }
     }

     incrementMessageCount() {
         this.checkMessageReset();
         this.settings.messageCount++;
         this.saveSettings();
         this.updateMessageProgress();

         // Check if limit is reached
         if (this.settings.messageLimit > 0 && this.settings.messageCount >= this.settings.messageLimit) {
             this.showMessageLimitModal();
             return false; // Prevent message
         }
         return true; // Allow message
     }

     resetMessageCount() {
         this.settings.messageCount = 0;
         this.saveSettings();
         this.updateMessageProgress();
         console.log('ü§ñ Message count reset manually');
     }

     updateMessageProgress() {
         const countElement = document.getElementById('current-message-count');
         const progressBar = document.getElementById('message-progress-bar');

         if (countElement) {
             countElement.textContent = this.settings.messageCount;
         }

         if (progressBar && this.settings.messageLimit > 0) {
             const percentage = Math.min((this.settings.messageCount / this.settings.messageLimit) * 100, 100);
             progressBar.style.width = `${percentage}%`;

             // Change color based on usage
             if (percentage >= 90) {
                 progressBar.className = 'bg-red-500 h-2 rounded-full transition-all duration-300';
             } else if (percentage >= 70) {
                 progressBar.className = 'bg-orange-500 h-2 rounded-full transition-all duration-300';
             } else {
                 progressBar.className = 'bg-indigo-500 h-2 rounded-full transition-all duration-300';
             }
         }
     }

     showMessageLimitModal() {
         const modal = document.getElementById('message-limit-modal');
         if (modal) {
             modal.classList.remove('hidden');
         }
     }

     hideMessageLimitModal() {
         const modal = document.getElementById('message-limit-modal');
         if (modal) {
             modal.classList.add('hidden');
         }
     }

     getApiKey() {
         return this.settings.customApiKey.trim() || null; // Return null if empty to use default
     }

     getSelectedModel() {
         return this.settings.selectedModel;
     }

     async testApiKey(apiKey) {
         try {
             // Test the API key by making a simple request
             const testResponse = await fetch('/api/chat', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json',
                 },
                 body: JSON.stringify({
                     message: 'Test',
                     customApiKey: apiKey,
                     model: this.settings.selectedModel
                 })
             });

             return testResponse.ok;
         } catch (error) {
             console.error('ü§ñ API key test failed:', error);
             return false;
         }
     }

     updateUI() {
         // Update modal fields
         const apiKeyInput = document.getElementById('custom-api-key');
         const modelFlash = document.getElementById('model-flash');
         const modelFlashLite = document.getElementById('model-flash-lite');
         const messageLimitInput = document.getElementById('message-limit');

         if (apiKeyInput) {
             apiKeyInput.value = this.settings.customApiKey;
         }

         if (this.settings.selectedModel === 'gemini-2.5-flash' && modelFlash) {
             modelFlash.checked = true;
         } else if (this.settings.selectedModel === 'gemini-2.5-flash-lite' && modelFlashLite) {
             modelFlashLite.checked = true;
         }

         if (messageLimitInput) {
             messageLimitInput.value = this.settings.messageLimit;
         }

         this.updateMessageProgress();
     }

     initializeEventListeners() {
         // AI Settings button
         const aiSettingsBtn = document.getElementById('ai-settings-btn');
         if (aiSettingsBtn) {
             aiSettingsBtn.addEventListener('click', () => {
                 this.showAISettings();
             });
         }

         // Modal controls
         const cancelBtn = document.getElementById('cancel-ai-settings');
         const saveBtn = document.getElementById('save-ai-settings');
         const testBtn = document.getElementById('test-api-key');

         if (cancelBtn) {
             cancelBtn.addEventListener('click', () => this.hideAISettings());
         }

         if (saveBtn) {
             saveBtn.addEventListener('click', () => this.saveAISettings());
         }

         if (testBtn) {
             testBtn.addEventListener('click', () => this.testCurrentApiKey());
         }

         // API key visibility toggle
         const toggleBtn = document.getElementById('toggle-api-key-visibility');
         if (toggleBtn) {
             toggleBtn.addEventListener('click', () => this.toggleApiKeyVisibility());
         }

         // Reset message count button
         const resetBtn = document.getElementById('reset-message-count');
         if (resetBtn) {
             resetBtn.addEventListener('click', () => this.resetMessageCount());
         }

         // Message limit modal controls
         const resetLimitBtn = document.getElementById('reset-limit-counter');
         const openSettingsBtn = document.getElementById('open-settings-from-limit');
         const closeLimitBtn = document.getElementById('close-limit-modal');

         if (resetLimitBtn) {
             resetLimitBtn.addEventListener('click', () => {
                 this.resetMessageCount();
                 this.hideMessageLimitModal();
             });
         }

         if (openSettingsBtn) {
             openSettingsBtn.addEventListener('click', () => {
                 this.hideMessageLimitModal();
                 this.showAISettings();
             });
         }

         if (closeLimitBtn) {
             closeLimitBtn.addEventListener('click', () => this.hideMessageLimitModal());
         }

         // Close modals when clicking outside
         const aiModal = document.getElementById('ai-settings-modal');
         const limitModal = document.getElementById('message-limit-modal');

         if (aiModal) {
             aiModal.addEventListener('click', (e) => {
                 if (e.target === aiModal) {
                     this.hideAISettings();
                 }
             });
         }

         if (limitModal) {
             limitModal.addEventListener('click', (e) => {
                 if (e.target === limitModal) {
                     this.hideMessageLimitModal();
                 }
             });
         }
     }

     showAISettings() {
         this.updateUI();
         const modal = document.getElementById('ai-settings-modal');
         if (modal) {
             modal.classList.remove('hidden');
         }
     }

     hideAISettings() {
         const modal = document.getElementById('ai-settings-modal');
         if (modal) {
             modal.classList.add('hidden');
         }
     }

     toggleApiKeyVisibility() {
         const input = document.getElementById('custom-api-key');
         const eyeClosed = document.getElementById('eye-closed');
         const eyeOpen = document.getElementById('eye-open');

         if (input && eyeClosed && eyeOpen) {
             if (input.type === 'password') {
                 input.type = 'text';
                 eyeClosed.classList.add('hidden');
                 eyeOpen.classList.remove('hidden');
             } else {
                 input.type = 'password';
                 eyeClosed.classList.remove('hidden');
                 eyeOpen.classList.add('hidden');
             }
         }
     }

     async testCurrentApiKey() {
         const apiKeyInput = document.getElementById('custom-api-key');
         const statusDiv = document.getElementById('api-key-status');
         const statusIcon = document.getElementById('api-key-status-icon');
         const statusText = document.getElementById('api-key-status-text');
         const testBtn = document.getElementById('test-api-key');

         if (!apiKeyInput || !statusDiv || !statusIcon || !statusText || !testBtn) return;

         const apiKey = apiKeyInput.value.trim();
         if (!apiKey) {
             this.showApiKeyStatus('info', 'No custom API key provided. Default key will be used.');
             return;
         }

         // Show loading state
         testBtn.disabled = true;
         testBtn.textContent = 'Testing...';
         this.showApiKeyStatus('info', 'Testing API key...');

         try {
             const isValid = await this.testApiKey(apiKey);

             if (isValid) {
                 this.showApiKeyStatus('success', 'API key is valid and working!');
             } else {
                 this.showApiKeyStatus('error', 'API key test failed. Please check your key.');
             }
         } catch (error) {
             this.showApiKeyStatus('error', 'Failed to test API key. Please try again.');
         } finally {
             testBtn.disabled = false;
             testBtn.textContent = 'Test API Key';
         }
     }

     showApiKeyStatus(type, message) {
         const statusDiv = document.getElementById('api-key-status');
         const statusIcon = document.getElementById('api-key-status-icon');
         const statusText = document.getElementById('api-key-status-text');

         if (!statusDiv || !statusIcon || !statusText) return;

         statusDiv.classList.remove('hidden');
         statusText.textContent = message;

         // Clear previous classes
         statusIcon.className = '';

         if (type === 'success') {
             statusIcon.innerHTML = '<svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
         } else if (type === 'error') {
             statusIcon.innerHTML = '<svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
         } else {
             statusIcon.innerHTML = '<svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
         }
     }

     saveAISettings() {
         const apiKeyInput = document.getElementById('custom-api-key');
         const modelFlash = document.getElementById('model-flash');
         const modelFlashLite = document.getElementById('model-flash-lite');
         const messageLimitInput = document.getElementById('message-limit');

         if (apiKeyInput) {
             this.settings.customApiKey = apiKeyInput.value.trim();
         }

         if (modelFlash && modelFlash.checked) {
             this.settings.selectedModel = 'gemini-2.5-flash';
         } else if (modelFlashLite && modelFlashLite.checked) {
             this.settings.selectedModel = 'gemini-2.5-flash-lite';
         }

         if (messageLimitInput) {
             this.settings.messageLimit = parseInt(messageLimitInput.value) || 0;
         }

         this.saveSettings();
         this.updateMessageProgress();
         this.hideAISettings();

         // Show success message
         addChatMessage('System', 'ü§ñ AI settings saved successfully!', false);
         console.log('ü§ñ AI settings updated:', this.settings);
     }
 }

 // Initialize AI Settings Manager
 const aiSettings = new AISettingsManager();

 // Make it globally accessible for debugging
 window.aiSettings = aiSettings;

 // Make read-aloud functions globally accessible
 window.readMessageAloud = readMessageAloud;
 window.stopAllSpeech = stopAllSpeech;

 // Add test functions for debugging
 window.testVoice = () => {
     voiceAssistant.speakResponse("Voice assistant is working correctly. You can now use voice commands.");
 };

 window.testVoiceRecognition = () => {
     voiceAssistant.startListening();
 };

 window.testReadAloud = () => {
     readMessageAloud("This is a test of the read-aloud feature for AI messages. The voice should match your voice assistant settings.", "test-message");
 };

 window.testVoiceMemory = () => {
     const context = voiceAssistant.getRecentConversationContext();
     console.log('üß† Voice conversation context:', context);
     addChatMessage('System', `üß† Voice memory test: ${context ? 'Context found' : 'No context'} - ${chatHistoryStorage.length} messages in history`, false);
 };

 window.testVoiceShortcut = () => {
     console.log('üé§ Testing voice shortcut manually...');
     addChatMessage('System', 'üé§ Voice shortcut test - try pressing Ctrl+Shift+V now', false);
 };

 // Force voice initialization on page load
 function initializeVoicesOnLoad() {
     console.log('üé§ Initializing voices on page load...');

     // Force speechSynthesis to load voices
     if (window.speechSynthesis) {
         const voices = window.speechSynthesis.getVoices();
         if (voices.length === 0) {
             // Create dummy utterance to trigger voice loading
             const dummy = new SpeechSynthesisUtterance('');
             window.speechSynthesis.speak(dummy);
             window.speechSynthesis.cancel();
         }

         // Set up default voice after a delay
         setTimeout(() => {
             const availableVoices = window.speechSynthesis.getVoices();
             if (availableVoices.length > 0) {
                 const googleUSVoice = availableVoices.find(v =>
                     v.name.toLowerCase().includes('google') && v.lang === 'en-US'
                 ) || availableVoices.find(v => v.lang === 'en-US') || availableVoices[0];

                 console.log('üé§ Page load default voice:', googleUSVoice.name, googleUSVoice.lang);
             }
         }, 500);
     }
 }

 // Initialize voices immediately
 initializeVoicesOnLoad();

 // Also initialize on first user interaction (mobile requirement)
 document.addEventListener('click', initializeVoicesOnLoad, { once: true });
 document.addEventListener('touchstart', initializeVoicesOnLoad, { once: true });

 console.log("üé§ Voice Assistant initialized");
 console.log("üé§ Test functions available: testVoice(), testVoiceRecognition(), testVoiceMemory(), testVoiceShortcut()");
 console.log("üé§ Global keyboard shortcut (Ctrl+Shift+V) registered");

 // Restore app state on page load with proper initialization check
 function attemptRestore() {
 // Check if all required components are ready
 const componentsReady = {
 fabricCanvas: !!fabricCanvas,
 chatHistory: !!document.getElementById('chat-history'),
 cellsContainer: !!document.getElementById('cells-container'),
 createCell: typeof createCell === 'function',
 loadPdfFromData: typeof loadPdfFromData === 'function',
 switchTab: typeof switchTab === 'function'
 };

 console.log('üîç Component readiness check:', componentsReady);

 const allReady = Object.values(componentsReady).every(ready => ready);

 if (allReady) {
 console.log('‚úÖ All components ready, starting restoration...');
 try {
 restoreAppState();
 } catch (error) {
 console.error('‚ùå Error restoring app state:', error);
 }
 } else {
 console.log('‚è≥ Components not ready yet, retrying in 1 second...');
 setTimeout(attemptRestore, 1000);
 }
 }

 // Start restoration attempt after initial delay
 setTimeout(attemptRestore, 1000);

 // Periodic state saving (every 30 seconds when not in a room) - reduced frequency
 setInterval(() => {
 if (fabricCanvas) {
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 saveAppState();
 }
 }
 }, 30000); // Increased from 3 seconds to 30 seconds

 // Auto-save on canvas changes (when not in a room)
 fabricCanvas.on('object:added', () => {
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 setTimeout(() => saveAppState(), 100); // Small delay to batch changes
 }
 });

 fabricCanvas.on('object:modified', () => {
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 setTimeout(() => saveAppState(), 100);
 }
 });

 fabricCanvas.on('object:removed', () => {
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 setTimeout(() => saveAppState(), 100);
 }
 });

 fabricCanvas.on('path:created', () => {
 const isInRoom = currentRoomId && isConnected;
 if (!isInRoom) {
 setTimeout(() => saveAppState(), 100);
 }
 });

 // Save state on canvas changes
 let saveStateTimeout;
 fabricCanvas.on('after:render', () => {
 clearTimeout(saveStateTimeout);
 saveStateTimeout = setTimeout(() => {
 saveAppState();
 }, 1000); // Debounce to avoid too frequent saves
 });

 // Initialize canvas pattern restoration
 restoreCanvasPattern();

 // Add window resize event listener for canvas patterns and responsive sizing
 window.addEventListener('resize', () => {
     reapplyCanvasPatternOnResize();

     // Update canvas size to match container
     const newWidth = canvasParent.clientWidth;
     const newHeight = canvasParent.clientHeight;

     if (newWidth > 0 && newHeight > 0) {
         fabricCanvas.setDimensions({
             width: newWidth,
             height: newHeight
         });
         fabricCanvas.requestRenderAll();
     }
 });

 // Add ResizeObserver for more reliable canvas resizing
 if (window.ResizeObserver) {
     const resizeObserver = new ResizeObserver((entries) => {
         for (const entry of entries) {
             const { width, height } = entry.contentRect;
             if (width > 0 && height > 0) {
                 fabricCanvas.setDimensions({ width, height });
                 fabricCanvas.requestRenderAll();
             }
         }
     });
     resizeObserver.observe(canvasParent);
 }

 console.log("Modern UI Notebook script fully initialized.");

// Radial Menu Implementation
class RadialMenu {
    constructor() {
        this.menu = document.getElementById('radial-menu');
        this.container = this.menu.querySelector('.radial-menu-container');
        this.centerButton = this.menu.querySelector('.radial-menu-center');
        this.items = this.menu.querySelectorAll('.radial-menu-item');
        this.isVisible = false;
        this.longPressTimer = null;
        this.longPressDelay = 600; // 600ms (0.6 second) for long press
        this.currentPosition = { x: 0, y: 0 };
        this.copiedObjects = [];
        // Track how menu was closed and what was chosen
        this.closedBySelection = false;
        this.selectedToolId = null;
        this.selectedToolIsDrawing = false;
        this.colorPopoverOpen = false;

        this.init();
    }

        init() {
            this.positionItems();
            this.setupEventListeners();
            this.bindCenterColorPicker();
            console.log('üéØ Radial menu initialized');
        }

    positionItems() {
        const radius = window.matchMedia('(pointer: coarse)').matches ? 150 : 130;
        const visibleItems = Array.from(this.items).filter(it => !it.classList.contains('hidden'));
        const count = visibleItems.length || 1;
        const step = 360 / count;
        const start = -90; // start at top (12 o'clock)

        visibleItems.forEach((item, idx) => {
            const angle = start + idx * step;
            const radian = (angle * Math.PI) / 180;
            const x = Math.cos(radian) * radius;
            const y = Math.sin(radian) * radius;
            item.style.left = `calc(50% + ${x}px)`;
            item.style.top = `calc(50% + ${y}px)`;
            // Smooth staggered animation
            item.style.transitionDelay = `${Math.min(idx * 60, 300)}ms`;
            // Update data-angle for any CSS hooks
            item.dataset.angle = String(Math.round(((angle % 360) + 360) % 360));
        });
    }

    setupEventListeners() {
        // Long press detection for canvas parent (to catch all canvas area)
        const canvasParent = document.getElementById('canvas-parent');
        let startPos = { x: 0, y: 0 };
        let hasMoved = false;

        // Mouse events
        canvasParent.addEventListener('mousedown', (e) => {
            // Left mouse button only; avoid when panning with Space or Pan Mode
            const spaceDown = (typeof isSpacePressed !== 'undefined') ? isSpacePressed : false;
            if (e.button === 0 && !this.isVisible && !spaceDown && !isPanModeActive) {
                startPos = { x: e.clientX, y: e.clientY };
                hasMoved = false;
                this.startLongPress(e);
                console.log('üéØ Mouse down - starting long press timer');
            }
        });

        canvasParent.addEventListener('mouseup', (e) => {
            this.cancelLongPress();
            console.log('üéØ Mouse up - cancelled long press');
        });

        canvasParent.addEventListener('mousemove', (e) => {
            if (this.longPressTimer) {
                const deltaX = Math.abs(e.clientX - startPos.x);
                const deltaY = Math.abs(e.clientY - startPos.y);
                if (deltaX > 10 || deltaY > 10) { // Allow small movement
                    hasMoved = true;
                    this.cancelLongPress();
                    console.log('üéØ Mouse moved too much - cancelled long press');
                }
            }
        });

        // Touch events
        canvasParent.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && !this.isVisible && !isPanModeActive) { // Single touch only
                const touch = e.touches[0];
                startPos = { x: touch.clientX, y: touch.clientY };
                hasMoved = false;
                this.startLongPress(touch);
                console.log('üéØ Touch start - starting long press timer');
            }
        }, { passive: false });

        canvasParent.addEventListener('touchend', (e) => {
            this.cancelLongPress();
            console.log('üéØ Touch end - cancelled long press');
        });

        canvasParent.addEventListener('touchmove', (e) => {
            if (this.longPressTimer && e.touches.length === 1) {
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - startPos.x);
                const deltaY = Math.abs(touch.clientY - startPos.y);
                if (deltaX > 15 || deltaY > 15) { // Allow slightly more movement for touch
                    hasMoved = true;
                    this.cancelLongPress();
                    console.log('üéØ Touch moved too much - cancelled long press');
                }
            }
        }, { passive: false });

        // Menu item clicks
        this.items.forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleItemClick(item.dataset.tool);
            });
        });

        // Keep center button visible (used as color picker trigger)

        // Click outside to close (use capture on document for reliability)
        this._outsideClickHandler = (e) => {
            if (!this.isVisible) return;
            // Close if click is outside the visible radial container
            const isInside = this.container.contains(e.target);
            if (!isInside) {
                this.hide();
            }
        };
        document.addEventListener('mousedown', this._outsideClickHandler, true);
        document.addEventListener('touchstart', this._outsideClickHandler, { capture: true, passive: true });

        // Cancel long-press as soon as a multi-touch gesture starts or moves
        const cancelOnMultiTouch = (e) => {
            try {
                if (e.touches && e.touches.length > 1) {
                    this.cancelLongPress();
                }
            } catch (_) {}
        };
        document.addEventListener('touchstart', cancelOnMultiTouch, { capture: true, passive: true });
        document.addEventListener('touchmove', cancelOnMultiTouch, { capture: true, passive: true });

        // Prevent context menu on canvas area while menu is visible
        canvasParent.addEventListener('contextmenu', (e) => {
            if (this.isVisible) {
                e.preventDefault();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            this.positionItems();
        });
    }

    startLongPress(event) {
        // Don't start long press if already visible
        if (this.isVisible || isPanModeActive || isGesturing) {
            console.log('üéØ Menu already visible, ignoring long press');
            return;
        }

        this.currentPosition = {
            x: event.clientX || event.pageX,
            y: event.clientY || event.pageY
        };

        // Pre-set lastMousePosition to the press point in canvas coords so paste targets here
        try {
            const pointer = fabricCanvas.getPointer({ clientX: this.currentPosition.x, clientY: this.currentPosition.y });
            if (pointer && typeof pointer.x === 'number' && typeof pointer.y === 'number') {
                lastMousePosition.x = pointer.x;
                lastMousePosition.y = pointer.y;
            }
        } catch (e) {
            // ignore
        }

        console.log('üéØ Starting long press timer for 0.8 second...');

        this.longPressTimer = setTimeout(() => {
            console.log('üéØ Long press timer fired! Showing menu...');

            // Store original states to restore later
            this.originalDrawingMode = fabricCanvas.isDrawingMode;
            this.originalSelection = fabricCanvas.selection;

            // If a free‚Äëdraw stroke began, end it and discard the aborted path
            try {
                const prevCount = fabricCanvas.getObjects().length;
                // End any ongoing draw by simulating mouseup on the upper canvas
                const upper = (fabricCanvas && fabricCanvas.upperCanvasEl) ? fabricCanvas.upperCanvasEl : document.getElementById('main-canvas');
                if (upper) {
                    upper.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
                }
                // Remove any path that may have been added by the synthetic mouseup
                setTimeout(() => {
                    const objs = fabricCanvas.getObjects();
                    for (let i = prevCount; i < objs.length; i++) {
                        const o = objs[i];
                        if (o && o.type === 'path') {
                            fabricCanvas.remove(o);
                        }
                    }
                    fabricCanvas.requestRenderAll();
                }, 0);
            } catch (err) { /* ignore */ }

            // Temporarily disable canvas interactions while menu is open
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = false;

            this.show(this.currentPosition.x, this.currentPosition.y);
        }, this.longPressDelay);
    }

    cancelLongPress() {
        if (this.longPressTimer) {
            console.log('üéØ Cancelling long press timer');
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
    }

    show(x, y) {
        if (this.isVisible) return;

        this.isVisible = true;

        // Check if objects are selected to determine which menu to show
        const activeObjects = fabricCanvas.getActiveObjects();
        const hasSelection = activeObjects.length > 0;

        // Show/hide appropriate menu items
        const drawingTools = this.menu.querySelectorAll('.drawing-tool');
        const selectionTools = this.menu.querySelectorAll('.selection-tool');

        if (hasSelection) {
            // Show selection context menu
            drawingTools.forEach(item => item.classList.add('hidden'));
            selectionTools.forEach(item => item.classList.remove('hidden'));
            console.log('üéØ Showing selection context menu');
        } else {
            // Show drawing tools menu
            drawingTools.forEach(item => item.classList.remove('hidden'));
            selectionTools.forEach(item => item.classList.add('hidden'));
            console.log('üéØ Showing drawing tools menu');
        }

        // Recompute positions for currently visible items to make spacing even
        this.positionItems();

        // Position menu at touch/click point (center the menu)
        const menuSize = window.matchMedia('(pointer: coarse)').matches ? 280 : 240;
        this.menu.style.left = (x - menuSize/2) + 'px';
        this.menu.style.top = (y - menuSize/2) + 'px';

        // Ensure menu stays within viewport
        const rect = this.menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (rect.right > viewportWidth) {
            this.menu.style.left = (viewportWidth - rect.width - 10) + 'px';
        }
        if (rect.left < 0) {
            this.menu.style.left = '10px';
        }
        if (rect.bottom > viewportHeight) {
            this.menu.style.top = (viewportHeight - rect.height - 10) + 'px';
        }
        if (rect.top < 0) {
            this.menu.style.top = '10px';
        }

        this.menu.classList.remove('hidden');
        this.menu.classList.add('show');

        // Block canvas pointer events while menu is open
        try {
            if (fabricCanvas && fabricCanvas.upperCanvasEl) {
                fabricCanvas.upperCanvasEl.style.pointerEvents = 'none';
            }
        } catch (e) { /* ignore */ }

        // Add show class to container for animation
        setTimeout(() => {
            this.container.classList.add('show');
        }, 10);

        console.log('üéØ Radial menu shown at', x, y, hasSelection ? 'with selection' : 'without selection');
    }

    hide() {
        if (!this.isVisible) return;

        this.isVisible = false;
        this.container.classList.remove('show');

        // Restore original canvas states unless a new tool was selected
        if (!this.closedBySelection) {
            if (this.originalDrawingMode !== undefined) {
                fabricCanvas.isDrawingMode = this.originalDrawingMode;
            }
            if (this.originalSelection !== undefined) {
                fabricCanvas.selection = this.originalSelection;
            }
        }
        // Reset flags
        this.closedBySelection = false;
        this.selectedToolId = null;
        this.selectedToolIsDrawing = false;

        setTimeout(() => {
            this.menu.classList.remove('show');
            this.menu.classList.add('hidden');
            // Restore canvas pointer events unless a color popover is open
            try {
                if (fabricCanvas && fabricCanvas.upperCanvasEl && !this.colorPopoverOpen) {
                    fabricCanvas.upperCanvasEl.style.pointerEvents = '';
                }
            } catch (e) { /* ignore */ }
        }, 250);

        console.log('üéØ Radial menu hidden');
    }

    handleItemClick(tool) {
        console.log('üéØ Radial menu item clicked:', tool);

        switch (tool) {
            case 'pen':
                this.switchToTool('pen-tool');
                break;
            case 'pan':
                this.switchToTool('pan-mode-tool');
                break;

            case 'select':
                this.switchToTool('select-tool');
                break;

            case 'rectangle':
                this.switchToTool('rectangle-tool');
                break;

            case 'circle':
                this.switchToTool('circle-tool');
                break;

            case 'text':
                this.switchToTool('text-tool');
                break;

            case 'arrow':
                this.switchToTool('arrow-tool');
                break;

            case 'copy':
                this.copySelectedObjects();
                break;

            case 'paste':
                this.pasteObjects();
                break;

            case 'delete':
                this.deleteSelectedObjects();
                break;
        }

        this.hide();
    }

    switchToTool(toolId) {
        // Record choice so hide() doesn't restore old mode incorrectly
        this.selectedToolId = toolId;
        this.selectedToolIsDrawing = ['pen-tool','line-tool','arrow-tool','circle-tool','rectangle-tool','highlighter-rect-tool','highlighter-circle-tool','text-tool'].includes(toolId);
        this.closedBySelection = true;

        // Clear any active selection and disable selection to prevent marquee
        fabricCanvas.discardActiveObject();
        fabricCanvas.renderAll();
        fabricCanvas.selection = false;
        fabricCanvas.isDrawingMode = false;

        // Trigger the actual tool button click (lets app set proper state)
        const toolButton = document.getElementById(toolId);
        if (toolButton) {
            toolButton.click();
            console.log('üîß Switched to tool via radial:', toolId);
        } else {
            console.warn('üîß Tool button not found:', toolId);
        }
    }

    copySelectedObjects() {
        // Delegate to global copy if available for unified clipboard
        if (typeof window.copySelectedObjects === 'function') {
            window.copySelectedObjects();
            return;
        }
        // Fallback (rare): simple clone of active objects
        const activeObjects = fabricCanvas.getActiveObjects();
        if (activeObjects.length === 0) return;
        this.copiedObjects = [];
        activeObjects.forEach(obj => obj.clone((cloned) => this.copiedObjects.push(cloned)));
    }

    pasteObjects() {
        // Use global paste to honor cursor positioning and collaboration sync
        if (typeof window.pasteObjects === 'function') {
            window.pasteObjects();
            return;
        }
        // Fallback: add local clones near last position
        const offset = 20;
        this.copiedObjects.forEach(cl => {
            cl.set({ left: cl.left + offset, top: cl.top + offset, id: generateUniqueId() });
            fabricCanvas.add(cl);
        });
        fabricCanvas.requestRenderAll();
    }

    // Open native color picker from center button and sync color
    bindCenterColorPicker() {
        const colorBtn = document.getElementById('radial-color-button');
        const preview = document.getElementById('radial-color-preview');
        const toolbarPicker = document.getElementById('color-picker');
        if (!colorBtn || !preview || !toolbarPicker) return;

        const updatePreview = (hex) => {
            preview.style.background = hex;
            document.documentElement.style.setProperty('--current-stroke-color', hex);
        };

        // Sync initial preview with toolbar color
        updatePreview(toolbarPicker.value || '#111827');

        // Clicking center opens the existing toolbar color input
        colorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Close dial when opening color
            const spawnX = this.currentPosition.x;
            const spawnY = this.currentPosition.y;
            this.colorPopoverOpen = true;
            this.hide();

            // Disable canvas pointer events while popover is open
            let restoredPointerEvents = false;
            try {
              if (fabricCanvas && fabricCanvas.upperCanvasEl) {
                fabricCanvas.upperCanvasEl.style.pointerEvents = 'none';
              }
            } catch (e) { /* ignore */ }

            // Build a small popover with a color input at the spawn point
            const pop = document.createElement('div');
            pop.style.position = 'fixed';
            pop.style.left = Math.max(8, spawnX - 24) + 'px';
            pop.style.top = Math.max(8, spawnY - 24) + 'px';
            pop.style.zIndex = '99999';
            pop.style.background = 'rgba(255,255,255,0.95)';
            pop.style.border = '1px solid rgba(226,232,240,0.9)';
            pop.style.borderRadius = '9999px';
            pop.style.padding = '6px';
            pop.style.width = '48px';
            pop.style.height = '48px';
            pop.style.display = 'flex';
            pop.style.alignItems = 'center';
            pop.style.justifyContent = 'center';
            pop.style.boxShadow = '0 10px 25px -5px rgba(0,0,0,0.25), 0 8px 10px -6px rgba(0,0,0,0.1)';
            pop.className = 'radial-color-popover';
            if (document.documentElement.classList.contains('dark')) {
              pop.style.background = 'rgba(30,41,59,0.95)';
              pop.style.border = '1px solid rgba(71,85,105,0.85)';
            }

            const input = document.createElement('input');
            input.type = 'color';
            input.value = toolbarPicker.value || '#111827';
            input.style.width = '36px';
            input.style.height = '36px';
            input.style.border = '0';
            input.style.padding = '0';
            input.style.background = 'transparent';
            input.style.cursor = 'pointer';
            input.style.borderRadius = '50%';
            input.style.appearance = 'none';
            input.style.WebkitAppearance = 'none';
            input.style.MozAppearance = 'none';
            input.style.boxShadow = 'inset 0 0 0 2px rgba(255,255,255,0.8)';

            pop.appendChild(input);
            document.body.appendChild(pop);

            const cleanup = () => {
              try { document.body.removeChild(pop); } catch (e) {}
              try {
                if (fabricCanvas && fabricCanvas.upperCanvasEl && !restoredPointerEvents) {
                  fabricCanvas.upperCanvasEl.style.pointerEvents = '';
                  restoredPointerEvents = true;
                }
              } catch (e) { /* ignore */ }
              this.colorPopoverOpen = false;
            };

            const applyColor = (val) => {
              toolbarPicker.value = val;
              toolbarPicker.dispatchEvent(new Event('input', { bubbles: true }));
              toolbarPicker.dispatchEvent(new Event('change', { bubbles: true }));
              updatePreview(val);
            };

            input.addEventListener('input', (ev) => applyColor(ev.target.value));
            input.addEventListener('change', (ev) => { applyColor(ev.target.value); cleanup(); });

            // Close when clicking outside
            const outsideHandler = (ev) => {
              if (!pop.contains(ev.target)) {
                cleanup();
                document.removeEventListener('mousedown', outsideHandler, true);
                document.removeEventListener('touchstart', outsideHandler, { capture: true });
              }
            };
            setTimeout(() => {
              document.addEventListener('mousedown', outsideHandler, true);
              document.addEventListener('touchstart', outsideHandler, { capture: true });
            }, 0);

            // Open the native picker for convenience
            try { input.focus(); input.click(); } catch (e) {}
        });

        // When color changes from toolbar, update preview and selected objects/brush
        toolbarPicker.addEventListener('input', (e) => {
            updatePreview(e.target.value);
        });
        toolbarPicker.addEventListener('change', (e) => {
            updatePreview(e.target.value);
        });
    }

    deleteSelectedObjects() {
        const activeObjects = fabricCanvas.getActiveObjects();

        if (activeObjects.length === 0) {
            showSystemMessage('No objects selected to delete', 'warning');
            return;
        }

        activeObjects.forEach(obj => {
            fabricCanvas.remove(obj);

            // Send to collaboration if in room
            if (currentRoomId && isConnected && obj.id) {
                sendCanvasEvent({
                    type: 'object_removed',
                    object_id: obj.id
                });
            }
        });

        fabricCanvas.discardActiveObject();
        fabricCanvas.renderAll();

        showSystemMessage(`Deleted ${activeObjects.length} object(s)`, 'success');
        console.log('üóëÔ∏è Deleted objects:', activeObjects.length);
    }
}

// Utility function for generating unique IDs
function generateUniqueId() {
    return 'obj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// System message function (if not already defined)
function showSystemMessage(message, type = 'info') {
    console.log(`üì¢ ${type.toUpperCase()}: ${message}`);

    // Try to use existing notification system
    if (typeof addChatMessage === 'function') {
        addChatMessage('System', `${type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'} ${message}`, false);
    } else {
        // Fallback to simple alert for now
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300 ${
            type === 'success' ? 'bg-green-500 text-white' :
            type === 'warning' ? 'bg-yellow-500 text-black' :
            'bg-blue-500 text-white'
        }`;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
}

// Add keyboard shortcuts for copy/paste
document.addEventListener('keydown', (e) => {
    // Only handle if not typing in input fields
    if (isUserTypingInTextField()) {
        return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        e.preventDefault();
        if (radialMenu) {
            radialMenu.copySelectedObjects();
        }
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        // Don't preventDefault here - let the paste event handle images first
        // The paste event will fall back to pasteObjects() if no image is found
        console.log('üìã Ctrl+V detected in radial menu handler, letting paste event handle it');
        return;
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault();
        if (radialMenu) {
            radialMenu.deleteSelectedObjects();
        }
    } else if (e.key === 'Escape') {
        // Hide radial menu on escape
        if (radialMenu && radialMenu.isVisible) {
            e.preventDefault();
            radialMenu.hide();
        }
    }
});

// Initialize radial menu
let radialMenu;
setTimeout(() => {
    radialMenu = new RadialMenu();
    console.log('üéØ Radial menu system ready');
}, 1000);

});
</script>

<!-- Room Creation Modal -->
<div id="create-room-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-96 max-w-md mx-4">
 <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200 mb-4">Create Collaboration Room</h3>
 <div class="space-y-4">
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Room Name (Optional)</label>
 <input type="text" id="room-name-input" placeholder="My Canvas Room" class="w-full p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200">
 </div>
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Max Users</label>
 <select id="max-users-select" class="w-full p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200">
 <option value="5">5 users</option>
 <option value="10" selected>10 users</option>
 <option value="20">20 users</option>
 <option value="50">50 users</option>
 </select>
 </div>
 </div>
 <div class="flex justify-end space-x-3 mt-6">
 <button id="cancel-create-room" class="px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">Cancel</button>
 <button id="confirm-create-room" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">Create Room</button>
 </div>
 </div>
</div>

<!-- Join Room Modal -->
<div id="join-room-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-96 max-w-md mx-4">
 <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200 mb-4">Join Collaboration Room</h3>
 <div class="space-y-4">
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Room ID</label>
 <input type="text" id="room-id-input" placeholder="Enter room ID..." class="w-full p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200">
 </div>
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Your Name</label>
 <input type="text" id="user-name-input" placeholder="Your display name..." class="w-full p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200">
 </div>
 </div>
 <div class="flex justify-end space-x-3 mt-6">
 <button id="cancel-join-room" class="px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">Cancel</button>
 <button id="confirm-join-room" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors">Join Room</button>
 </div>
 </div>
</div>

<!-- User Cursors Container -->
<div id="user-cursors" class="absolute inset-0 pointer-events-none z-40"></div>

<!-- Floating AI Button (shown when sidebar is hidden) -->
<button id="floating-ai-btn" class="fixed right-4 top-1/2 transform -translate-y-1/2 bg-indigo-500 hover:bg-indigo-600 text-white p-3 rounded-full shadow-lg transition-all duration-300 z-50 hidden" title="Open AI Assistant">
 <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
 </svg>
</button>

<!-- Voice Settings Modal -->
<div id="voice-settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-96 max-w-md mx-4">
 <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200 mb-4">Voice Assistant Settings</h3>
 <div class="space-y-4">
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Voice</label>
 <select id="voice-select" class="w-full p-2.5 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent outline-none bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200">
 <!-- Options will be populated by JavaScript -->
 </select>
 </div>
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Speech Rate: <span id="rate-value">1.0</span></label>
 <input type="range" id="voice-rate-slider" min="0.1" max="3.0" step="0.1" value="1.0" class="w-full h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-green-500">
 </div>
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Pitch: <span id="pitch-value">1.0</span></label>
 <input type="range" id="voice-pitch-slider" min="0.0" max="2.0" step="0.1" value="1.0" class="w-full h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-green-500">
 </div>
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Volume: <span id="volume-value">1.0</span></label>
 <input type="range" id="voice-volume-slider" min="0.0" max="1.0" step="0.1" value="1.0" class="w-full h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-green-500">
 </div>
 <div class="flex space-x-2">
 <button id="test-voice-btn" class="flex-1 px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">Test Voice</button>
 <button id="reset-voice-settings-btn" class="px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">Reset</button>
 </div>
 </div>
 <div class="flex justify-end space-x-3 mt-6">
 <button id="cancel-voice-settings" class="px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">Cancel</button>
 <button id="save-voice-settings" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">Save</button>
 </div>
 </div>
</div>

<!-- AI Settings Modal -->
<div id="ai-settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-[500px] max-w-[90vw] mx-4 max-h-[90vh] overflow-y-auto">
 <h3 class="text-xl font-semibold text-slate-800 dark:text-slate-200 mb-6 flex items-center">
 <svg class="w-6 h-6 mr-2 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
 </svg>
 AI Settings
 </h3>

 <div class="space-y-6">
 <!-- API Key Section -->
 <div class="border border-slate-200 dark:border-slate-600 rounded-lg p-4">
 <h4 class="text-lg font-medium text-slate-800 dark:text-slate-200 mb-3 flex items-center">
 <svg class="w-5 h-5 mr-2 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"/>
 </svg>
 API Key Configuration
 </h4>
 <div class="space-y-3">
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">
 Custom Gemini API Key (Optional)
 </label>
 <div class="relative">
 <input type="password" id="custom-api-key" placeholder="Enter your Gemini API key (leave empty to use default)"
 class="w-full p-3 pr-10 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100 placeholder-slate-400 dark:placeholder-slate-500 focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
 <button type="button" id="toggle-api-key-visibility" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-600 dark:hover:text-slate-300">
 <svg id="eye-closed" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21"/>
 </svg>
 <svg id="eye-open" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
 </svg>
 </button>
 </div>
 <p class="text-xs text-slate-500 dark:text-slate-400 mt-1">
 If empty, the default API key will be used. Your custom key is stored locally and never shared.
 </p>
 </div>
 <div id="api-key-status" class="hidden">
 <div class="flex items-center space-x-2 text-sm">
 <div id="api-key-status-icon"></div>
 <span id="api-key-status-text"></span>
 </div>
 </div>

 <!-- Test API Key Button -->
 <div class="mt-3">
 <button id="test-api-key" class="w-full px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors font-medium">
 Test API Key
 </button>
 </div>
 </div>
 </div>

 <!-- Model Selection Section -->
 <div class="border border-slate-200 dark:border-slate-600 rounded-lg p-4">
 <h4 class="text-lg font-medium text-slate-800 dark:text-slate-200 mb-3 flex items-center">
 <svg class="w-5 h-5 mr-2 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
 </svg>
 AI Model Selection
 </h4>
 <div class="space-y-3">
 <div class="grid grid-cols-1 gap-3">
 <label class="flex items-center p-3 border border-slate-200 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors">
 <input type="radio" name="ai-model" value="gemini-2.5-flash" id="model-flash" class="mr-3 text-indigo-500 focus:ring-indigo-500">
 <div class="flex-1">
 <div class="font-medium text-slate-800 dark:text-slate-200">Gemini 2.5 Flash</div>
 <div class="text-sm text-slate-500 dark:text-slate-400">Best price-performance model with well-rounded capabilities</div>
 </div>
 </label>
 <label class="flex items-center p-3 border border-slate-200 dark:border-slate-600 rounded-lg cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors">
 <input type="radio" name="ai-model" value="gemini-2.5-flash-lite" id="model-flash-lite" class="mr-3 text-indigo-500 focus:ring-indigo-500">
 <div class="flex-1">
 <div class="font-medium text-slate-800 dark:text-slate-200">Gemini 2.5 Flash-Lite</div>
 <div class="text-sm text-slate-500 dark:text-slate-400">Optimized for cost efficiency and low latency</div>
 </div>
 </label>
 </div>
 </div>
 </div>

 <!-- Message Limit Section -->
 <div class="border border-slate-200 dark:border-slate-600 rounded-lg p-4">
 <h4 class="text-lg font-medium text-slate-800 dark:text-slate-200 mb-3 flex items-center">
 <svg class="w-5 h-5 mr-2 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
 </svg>
 Message Limits
 </h4>
 <div class="space-y-3">
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">
 Daily Message Limit
 </label>
 <div class="flex items-center space-x-3">
 <input type="number" id="message-limit" min="1" max="10000" value="100"
 class="flex-1 p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100">
 <span class="text-sm text-slate-500 dark:text-slate-400">messages/day</span>
 </div>
 <p class="text-xs text-slate-500 dark:text-slate-400 mt-1">
 Set to 0 for unlimited messages
 </p>
 </div>
 <div class="bg-slate-50 dark:bg-slate-700/50 rounded-lg p-3">
 <div class="flex justify-between items-center text-sm">
 <span class="text-slate-600 dark:text-slate-400">Messages used today:</span>
 <span id="current-message-count" class="font-medium text-slate-800 dark:text-slate-200">0</span>
 </div>
 <div class="mt-2">
 <div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-2">
 <div id="message-progress-bar" class="bg-indigo-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
 </div>
 </div>
 <button id="reset-message-count" class="mt-2 text-xs text-indigo-500 hover:text-indigo-600 dark:text-indigo-400 dark:hover:text-indigo-300">
 Reset counter
 </button>
 </div>
 </div>
 </div>
 </div>

 <!-- Canvas Background Section -->
 <div class="border border-slate-200 dark:border-slate-600 rounded-lg p-4">
 <h4 class="text-lg font-medium text-slate-800 dark:text-slate-200 mb-3 flex items-center">
 <svg class="w-5 h-5 mr-2 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
 </svg>
 Canvas Background Patterns
 </h4>
 <div class="space-y-4">
 <!-- Pattern Selection -->
 <div>
 <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Pattern Type</label>
 <div class="grid grid-cols-2 gap-2">
 <button class="ai-pattern-btn p-3 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors text-left" data-pattern="plain">
 <div class="font-medium text-slate-800 dark:text-slate-200">Plain</div>
 <div class="text-xs text-slate-500 dark:text-slate-400">Solid color</div>
 </button>
 <button class="ai-pattern-btn p-3 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors text-left" data-pattern="lines">
 <div class="font-medium text-slate-800 dark:text-slate-200">Line v3</div>
 <div class="text-xs text-slate-500 dark:text-slate-400">Diagonal stripes</div>
 </button>

 <button class="ai-pattern-btn p-3 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors text-left" data-pattern="boxes">
 <div class="font-medium text-slate-800 dark:text-slate-200">Box</div>
 <div class="text-xs text-slate-500 dark:text-slate-400">Grid pattern</div>
 </button>
 <button class="ai-pattern-btn p-3 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors text-left" data-pattern="polka">
 <div class="font-medium text-slate-800 dark:text-slate-200">Polka</div>
 <div class="text-xs text-slate-500 dark:text-slate-400">Dot pattern</div>
 </button>

 <button class="ai-pattern-btn p-3 border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors text-left" data-pattern="graph">
 <div class="font-medium text-slate-800 dark:text-slate-200">Graph</div>
 <div class="text-xs text-slate-500 dark:text-slate-400">Graph paper</div>
 </button>
 </div>
 </div>

 <!-- Pattern Controls -->
 <div id="ai-pattern-controls" class="space-y-3 hidden">
 <div class="grid grid-cols-2 gap-3">
 <div>
 <label class="block text-xs font-medium text-slate-600 dark:text-slate-400 mb-1">Background Color</label>
 <input type="color" id="ai-pattern-background-color" value="#ffffff" class="w-full h-8 border border-slate-300 dark:border-slate-600 rounded cursor-pointer">
 </div>
 <div>
 <label class="block text-xs font-medium text-slate-600 dark:text-slate-400 mb-1">Pattern Color</label>
 <input type="color" id="ai-pattern-color" value="#6366f1" class="w-full h-8 border border-slate-300 dark:border-slate-600 rounded cursor-pointer">
 </div>
 </div>
 <div class="grid grid-cols-2 gap-3">
 <div>
 <label class="block text-xs font-medium text-slate-600 dark:text-slate-400 mb-1">Scale</label>
 <input type="range" id="ai-pattern-scale" min="10" max="100" step="5" value="30" class="w-full h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
 </div>
 <div>
 <label class="block text-xs font-medium text-slate-600 dark:text-slate-400 mb-1">Opacity</label>
 <input type="range" id="ai-pattern-opacity" min="0.1" max="1" step="0.1" value="0.3" class="w-full h-2 bg-slate-200 dark:bg-slate-600 rounded-lg appearance-none cursor-pointer accent-indigo-500">
 </div>
 </div>
 <div class="flex space-x-2">
 <button id="ai-apply-pattern" class="flex-1 px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors text-sm">
 Apply Pattern
 </button>
 <button id="ai-clear-pattern" class="flex-1 px-3 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors text-sm">
 Clear Pattern
 </button>
 </div>
 </div>
 </div>
 </div>

 <!-- Action Buttons -->
 <div class="flex justify-end space-x-3 pt-4 border-t border-slate-200 dark:border-slate-600">
 <button id="cancel-ai-settings" class="px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">
 Cancel
 </button>
 <button id="save-ai-settings" class="px-4 py-2 bg-indigo-500 hover:bg-indigo-600 text-white rounded-lg transition-colors">
 Save Settings
 </button>
 </div>
 </div>
</div>

<!-- Message Limit Reached Modal -->
<div id="message-limit-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-96 max-w-md mx-4">
 <div class="text-center">
 <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-orange-100 dark:bg-orange-900/50 mb-4">
 <svg class="h-6 w-6 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
 </svg>
 </div>
 <h3 class="text-lg font-semibold text-slate-800 dark:text-slate-200 mb-2">Message Limit Reached</h3>
 <p class="text-sm text-slate-600 dark:text-slate-400 mb-6">
 You've reached your daily message limit. You can reset the counter or adjust your limit in settings.
 </p>
 <div class="flex space-x-3">
 <button id="reset-limit-counter" class="flex-1 px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg transition-colors">
 Reset Counter
 </button>
 <button id="open-settings-from-limit" class="flex-1 px-4 py-2 bg-indigo-500 hover:bg-indigo-600 text-white rounded-lg transition-colors">
 Open Settings
 </button>
 </div>
 <button id="close-limit-modal" class="mt-3 w-full px-4 py-2 text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors">
 Close
 </button>
 </div>
 </div>
</div>

<!-- Kick Notification Modal -->
<div id="kick-notification-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
 <div class="bg-white dark:bg-slate-800 rounded-lg p-6 w-96 max-w-md mx-4 border-l-4 border-red-500 shadow-2xl">
 <div class="text-center">
 <div class="mx-auto flex items-center justify-center h-14 w-14 rounded-full bg-red-100 dark:bg-red-900/50 mb-4 kick-warning-icon">
 <svg class="h-8 w-8 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"/>
 </svg>
 </div>
 <h3 class="text-xl font-bold text-red-600 dark:text-red-400 mb-2">üö´ You've Been Kicked</h3>
 <p id="kick-notification-message" class="text-sm text-slate-600 dark:text-slate-400 mb-6 leading-relaxed">
 You have been removed from the room.
 </p>
 <div class="flex justify-center">
 <button id="kick-notification-close" class="px-6 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded-lg transition-all duration-200 hover:shadow-lg">
 Close
 </button>
 </div>
 </div>
 </div>
</div>

<!-- Group Chat Notification Container -->
<div id="notification-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 99998;"></div>

<!-- Radial Menu Container -->
<div id="radial-menu" class="fixed hidden z-50" style="pointer-events: none;">
    <div class="radial-menu-container relative" style="width: 240px; height: 240px;">
        <!-- Center color picker preview/button -->
        <div class="radial-menu-center absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-16 h-16 bg-white/90 dark:bg-slate-800/90 backdrop-blur-xl border border-slate-200/60 dark:border-slate-600/60 rounded-full flex items-center justify-center shadow-xl transition-all duration-200 hover:scale-105" style="pointer-events: auto;">
            <button id="radial-color-button" class="w-12 h-12 rounded-full ring-2 ring-white/60 dark:ring-slate-600/60 shadow-md flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-700 dark:to-slate-800" title="Pick color" style="pointer-events: auto;">
                <span id="radial-color-preview" class="w-9 h-9 rounded-full border border-slate-300 dark:border-slate-500" style="background: var(--current-stroke-color, #111827);"></span>
            </button>
        </div>

        <!-- Drawing Tools Menu Items (shown when no objects selected) -->
        <div class="radial-menu-item drawing-tool absolute" data-tool="pen" data-angle="0" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
                </svg>
            </div>
            <div class="radial-menu-label">Pen</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="pan" data-angle="30" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l-4-4m0 0l4-4m-4 4h18M17 8l4 4m0 0l-4 4"/>
                </svg>
            </div>
            <div class="radial-menu-label">Pan</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="select" data-angle="60" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"/>
                </svg>
            </div>
            <div class="radial-menu-label">Select</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="rectangle" data-angle="120" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </div>
            <div class="radial-menu-label">Rectangle</div>
        </div>

        <!-- Paste in normal (drawing) dial -->
        <div class="radial-menu-item drawing-tool absolute" data-tool="paste" data-angle="90" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                </svg>
            </div>
            <div class="radial-menu-label">Paste</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="circle" data-angle="180" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </div>
            <div class="radial-menu-label">Circle</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="text" data-angle="240" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/>
                </svg>
            </div>
            <div class="radial-menu-label">Text</div>
        </div>

        <div class="radial-menu-item drawing-tool absolute" data-tool="arrow" data-angle="300" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"/>
                </svg>
            </div>
            <div class="radial-menu-label">Arrow</div>
        </div>

        <!-- Selection Context Menu Items (shown when objects are selected) -->
        <div class="radial-menu-item selection-tool absolute hidden" data-tool="copy" data-angle="90" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                </svg>
            </div>
            <div class="radial-menu-label">Copy</div>
        </div>

        <div class="radial-menu-item selection-tool absolute hidden" data-tool="paste" data-angle="180" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                </svg>
            </div>
            <div class="radial-menu-label">Paste</div>
        </div>

        <div class="radial-menu-item selection-tool absolute hidden" data-tool="delete" data-angle="270" style="pointer-events: auto;">
            <div class="tool-button radial-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
            </div>
            <div class="radial-menu-label">Delete</div>
        </div>
    </div>
</div>

<!-- NEW UNDO/REDO BUTTONS - Bottom Left Corner -->
<div id="undo-redo-container" class="fixed bottom-4 left-4 flex flex-col gap-1 z-40 print:hidden">
    <button id="new-undo-btn" title="Undo (Ctrl+Z)" class="toolbar-button flex items-center justify-center" style="width: 51px; height: 51px;">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/>
        </svg>
    </button>
    <button id="new-redo-btn" title="Redo (Ctrl+Y)" class="toolbar-button flex items-center justify-center" style="width: 51px; height: 51px;">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 10h-10a8 8 0 00-8 8v2m18-10l-6 6m6-6l-6-6"/>
        </svg>
    </button>

</div>

<!-- PDF Viewer Modal -->
<div id="pdf-viewer-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden">
 <div class="relative w-full h-full max-w-6xl max-h-full p-4">
 <!-- Header with controls -->
 <div class="absolute top-4 left-4 right-4 bg-black bg-opacity-50 text-white px-4 py-2 rounded-lg flex items-center justify-between z-10">
 <div class="flex items-center space-x-4">
 <div id="pdf-modal-filename" class="font-medium"></div>
 <div class="text-sm text-gray-300">
 Page <span id="pdf-modal-current-page">1</span> of <span id="pdf-modal-total-pages">1</span>
 </div>
 </div>
 <div class="flex items-center space-x-2">
 <!-- Navigation controls -->
 <button id="pdf-modal-prev" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Previous Page">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
 </svg>
 </button>
 <button id="pdf-modal-next" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Next Page">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
 </svg>
 </button>
 <!-- Zoom controls -->
 <button id="pdf-modal-zoom-out" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Zoom Out">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"/>
 </svg>
 </button>
 <span id="pdf-modal-zoom-level" class="text-sm px-2 cursor-pointer hover:bg-white hover:bg-opacity-20 rounded" title="Click to reset zoom">100%</span>
 <button id="pdf-modal-zoom-in" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Zoom In">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"/>
 </svg>
 </button>
 <!-- Download button -->
 <a id="pdf-modal-download" href="" download="" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Download PDF">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
 </svg>
 </a>
 <!-- Close button -->
 <button id="close-pdf-viewer" class="p-2 hover:bg-white hover:bg-opacity-20 rounded transition-colors" title="Close">
 <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
 <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
 </svg>
 </button>
 </div>
 </div>

 <!-- PDF content area -->
 <div class="w-full h-full pt-16 pb-4">
 <div id="pdf-modal-container" class="w-full h-full bg-gray-100 dark:bg-gray-800 rounded-lg overflow-auto">
 <div id="pdf-modal-loading" class="flex items-center justify-center h-full text-center">
 <div>
 <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-600 mx-auto mb-4"></div>
 <div class="text-gray-600 dark:text-gray-300">Loading PDF...</div>
 </div>
 </div>
 <div id="pdf-modal-canvas-wrapper" class="flex items-center justify-center min-h-full p-4" style="display: none;">
 <canvas id="pdf-modal-canvas" class="shadow-lg border border-gray-300 dark:border-gray-600"></canvas>
 </div>
 </div>
 </div>
 </div>
</div>

<style>
/* Undo/Redo buttons with dynamic background adaptation */
#new-undo-btn,
#new-redo-btn {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    transition: all 0.2s ease-in-out, background-color 0.3s ease;
}

/* Light background adaptation */
#new-undo-btn:not(:disabled),
#new-redo-btn:not(:disabled) {
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid rgba(226, 232, 240, 0.8);
    color: rgb(51, 65, 85);
}

#new-undo-btn:not(:disabled):hover,
#new-redo-btn:not(:disabled):hover {
    background: rgba(255, 255, 255, 0.95);
    color: rgb(15, 23, 42);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

/* Dark mode adaptation */
.dark #new-undo-btn:not(:disabled),
.dark #new-redo-btn:not(:disabled) {
    background: rgba(30, 41, 59, 0.85);
    border-color: rgba(71, 85, 105, 0.8);
    color: rgb(203, 213, 225);
}

.dark #new-undo-btn:not(:disabled):hover,
.dark #new-redo-btn:not(:disabled):hover {
    background: rgba(51, 65, 85, 0.95);
    color: rgb(248, 250, 252);
}

/* Canvas background color adaptation */
.canvas-bg-white #new-undo-btn:not(:disabled),
.canvas-bg-white #new-redo-btn:not(:disabled) {
    background: rgba(0, 0, 0, 0.1);
    border-color: rgba(0, 0, 0, 0.2);
    color: rgb(30, 30, 30);
}

.canvas-bg-dark #new-undo-btn:not(:disabled),
.canvas-bg-dark #new-redo-btn:not(:disabled) {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 255, 255, 0.3);
    color: rgb(240, 240, 240);
}

/* Disabled states */
#new-undo-btn:disabled,
#new-redo-btn:disabled {
    opacity: 0.4 !important;
    cursor: not-allowed !important;
    transform: none !important;
    background: rgba(156, 163, 175, 0.3) !important;
    border-color: rgba(203, 213, 225, 0.5) !important;
}

#new-undo-btn:disabled:hover,
#new-redo-btn:disabled:hover {
    transform: none !important;
    background: rgba(156, 163, 175, 0.3) !important;
    box-shadow: none !important;
}

.dark #new-undo-btn:disabled,
.dark #new-redo-btn:disabled {
    background: rgba(71, 85, 105, 0.3) !important;
    border-color: rgba(100, 116, 139, 0.5) !important;
}
</style>

<style>
/* Radial Menu Styles */
#radial-menu { pointer-events: none; }

.radial-menu-container {
  position: relative;
  width: 240px;
  height: 240px;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  transform: scale(0) rotate(-180deg);
  opacity: 0;
  pointer-events: none;
}

.radial-menu-container.show { transform: scale(1) rotate(0deg); opacity: 1; }

/* Items */
.radial-menu-item {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  transform: scale(0) translate(-50%, -50%);
  opacity: 0;
}

.radial-menu-container.show .radial-menu-item {
  transform: scale(1) translate(-50%, -50%);
  opacity: 1;
}

/* Tool buttons (match toolbar) */
.radial-menu-item .tool-button {
  position: relative;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.5rem;
  background: rgba(255, 255, 255, 0.85);
  border: 1px solid rgba(226, 232, 240, 0.9);
  color: rgb(51, 65, 85);
  transition: all 0.2s ease-in-out;
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

.radial-menu-item .tool-button:hover {
  background: #fff;
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 20px 35px -5px rgba(0, 0, 0, 0.3),
              0 15px 20px -6px rgba(0, 0, 0, 0.15),
              inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
}

.dark .radial-menu-item .tool-button {
  background: rgba(30, 41, 59, 0.85);
  border-color: rgba(71, 85, 105, 0.85);
  color: rgb(203, 213, 225);
}

.dark .radial-menu-item .tool-button:hover {
  background: rgb(51, 65, 85);
  color: rgb(248, 250, 252);
}

/* radial-btn states */
.radial-btn { outline: 0; }
.radial-btn:hover { box-shadow: 0 6px 12px -2px rgba(0,0,0,0.15), 0 0 0 3px rgba(99,102,241,0.15); }
.radial-btn:active { transform: translateY(0) scale(0.99); }
.radial-btn:focus-visible { box-shadow: 0 0 0 3px rgba(99,102,241,0.35); }

/* Color dot for drawing tools */
.radial-menu-item.drawing-tool .tool-button::after {
  content: '';
  position: absolute;
  bottom: -4px;
  right: -4px;
  width: 14px;
  height: 14px;
  border-radius: 9999px;
  background: var(--current-stroke-color, #111827);
  border: 2px solid rgba(255, 255, 255, 0.9);
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}
.dark .radial-menu-item.drawing-tool .tool-button::after { border-color: rgba(30, 41, 59, 0.95); }
.radial-menu-item[data-tool="select"] .tool-button::after,
.radial-menu-item[data-tool="pan"] .tool-button::after,
.radial-menu-item[data-tool="paste"] .tool-button::after,
.radial-menu-item.selection-tool .tool-button::after { display: none; }

/* Center color button */
#radial-color-button {
  position: relative;
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  background: transparent !important; /* ensure no square/gradient */
  overflow: hidden;
  padding: 0;
}
.dark #radial-color-button { box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
#radial-color-preview {
  background: var(--current-stroke-color, #111827);
  width: 100% !important;
  height: 100% !important;
  border-radius: 9999px !important;
  border: 0 !important;
  display: block;
}

/* Round color popover and input styling */
.radial-color-popover { border-radius: 9999px; }
.radial-color-popover input[type="color"] {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  border-radius: 50%;
  overflow: hidden;
  padding: 0;
  border: none;
}
.radial-color-popover input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: 50%; }
.radial-color-popover input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
.radial-color-popover input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }

/* Labels */
.radial-menu-label {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-top: 6px;
  font-size: 11px;
  font-weight: 600;
  color: #374151;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(8px);
  padding: 4px 8px;
  border-radius: 8px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: all 0.2s ease;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.dark .radial-menu-label {
  color: #e5e7eb;
  background: rgba(30, 41, 59, 0.95);
  border: 1px solid rgba(255, 255, 255, 0.1);
}
.radial-menu-item:hover .radial-menu-label {
  opacity: 1;
  transform: translateX(-50%) translateY(-2px);
}

/* Staggered animations */
.radial-menu-item[data-angle="0"] { transition-delay: 0ms; }
.radial-menu-item[data-angle="60"] { transition-delay: 50ms; }
.radial-menu-item[data-angle="90"] { transition-delay: 75ms; }
.radial-menu-item[data-angle="120"] { transition-delay: 100ms; }
.radial-menu-item[data-angle="180"] { transition-delay: 150ms; }
.radial-menu-item[data-angle="240"] { transition-delay: 200ms; }
.radial-menu-item[data-angle="270"] { transition-delay: 225ms; }
.radial-menu-item[data-angle="300"] { transition-delay: 250ms; }

/* Touch-friendly sizing */
@media (pointer: coarse) {
  .radial-menu-item .tool-button { width: 52px !important; height: 52px !important; }
  .radial-menu-center { width: 60px !important; height: 60px !important; }
  .radial-menu-container { width: 280px !important; height: 280px !important; }
  .radial-menu-label { font-size: 12px; padding: 6px 10px; }
}

/* Backdrop blur */
#radial-menu::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: transparent; /* no page highlight */
  backdrop-filter: none;    /* remove blur */
  opacity: 0;               /* keep invisible */
  pointer-events: none;     /* don't intercept clicks */
}
#radial-menu.show::before { opacity: 0; }

/* Center pulse */
.radial-menu-center { animation: none; } /* disable pulsing/highlight */
@keyframes radialPulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
  50%      { box-shadow: 0 0 0 10px rgba(99, 102, 241, 0); }
}
</style>

<script>
// NEW UNDO/REDO BUTTONS SETUP - Bottom Left Corner
  console.log('üîß Setting up new undo/redo buttons...');

  function setupNewUndoRedoButtons() {
    const newUndoBtn = document.getElementById('new-undo-btn');
    const newRedoBtn = document.getElementById('new-redo-btn');

        console.log('üìç New buttons found:', {
            undo: !!newUndoBtn,
            redo: !!newRedoBtn
        });

        if (newUndoBtn) {
        newUndoBtn.onclick = function() {
            console.log('üîÑ NEW UNDO BUTTON CLICKED');
            // EXACT COPY of keyboard shortcut code from lines 9762-9765
            const cmdHistory = window.commandHistory || commandHistory;
            if (cmdHistory && cmdHistory.canUndo()) {
                cmdHistory.undo();
                console.log('üîÑ Undo triggered via keyboard shortcut (Ctrl+Z)');
            } else {
                console.log('‚ùå Cannot undo - commandHistory not available or no commands');
            }
        };
        console.log('‚úÖ New undo button setup complete');
        }

    // Auto-center on startup: if there is content, fit to it; else reset view to origin
    try {
      setTimeout(() => {
        const objs = (typeof fabricCanvas !== 'undefined' && fabricCanvas) ? fabricCanvas.getObjects() : [];
        if (objs && objs.length > 0) {
          centerCanvasView();
        } else {
          // Default home view when empty
          if (typeof fabricCanvas !== 'undefined' && fabricCanvas) {
            currentZoom = 1.0;
            fabricCanvas.setZoom(currentZoom);
            fabricCanvas.setViewportTransform([1,0,0,1,0,0]);
            fabricCanvas.requestRenderAll();
          }
        }
      }, 800);
      // Run a second pass after potential state restoration
      setTimeout(() => {
        try { centerCanvasView(); } catch (_) {}
      }, 2000);
    } catch (_) {}

    if (newRedoBtn) {
        newRedoBtn.onclick = function() {
            console.log('üîÑ NEW REDO BUTTON CLICKED');
            // EXACT COPY of keyboard shortcut code from lines 9769-9772
            const cmdHistory = window.commandHistory || commandHistory;
            if (cmdHistory && cmdHistory.canRedo()) {
                cmdHistory.redo();
                console.log('üîÑ Redo triggered via keyboard shortcut (Ctrl+Y or Ctrl+Shift+Z)');
            } else {
                console.log('‚ùå Cannot redo - commandHistory not available or no commands');
            }
        };
        console.log('‚úÖ New redo button setup complete');
    }

    // Update button states based on command history
    function updateButtonStates() {
        try {
            const cmdHistory = window.commandHistory || (typeof commandHistory !== 'undefined' ? commandHistory : null);
            if (newUndoBtn && cmdHistory && typeof cmdHistory.canUndo === 'function') {
                const canUndo = cmdHistory.canUndo();
                newUndoBtn.disabled = !canUndo;
                newUndoBtn.title = canUndo
                    ? `Undo: ${cmdHistory.undoStack[cmdHistory.undoStack.length - 1]?.description || 'Last Action'} (Ctrl+Z)`
                    : 'Nothing to undo (Ctrl+Z)';
            }
            if (newRedoBtn && cmdHistory && typeof cmdHistory.canRedo === 'function') {
                const canRedo = cmdHistory.canRedo();
                newRedoBtn.disabled = !canRedo;
                newRedoBtn.title = canRedo
                    ? `Redo: ${cmdHistory.redoStack[cmdHistory.redoStack.length - 1]?.description || 'Last Undone Action'} (Ctrl+Y)`
                    : 'Nothing to redo (Ctrl+Y)';
            }
        } catch (error) {
            // Silently handle errors to prevent console spam
            if (error && error.message) {
                console.warn('Button state update error:', error.message);
            }
        }
    }

    // Function to update button colors based on canvas background
    function updateButtonColors() {
        try {
            if (!fabricCanvas) return;

            const backgroundColor = fabricCanvas.backgroundColor || '#ffffff';
            const container = document.getElementById('undo-redo-container');

            if (!container) return;

            // Remove existing background classes
            container.classList.remove('canvas-bg-white', 'canvas-bg-dark');

            // Determine if background is light or dark
            let isLightBackground = true;

            if (backgroundColor && backgroundColor !== '#ffffff') {
                // Convert hex to RGB to calculate luminance
                const hex = backgroundColor.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);

                // Calculate relative luminance
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                isLightBackground = luminance > 0.5;
            }

            // Apply appropriate class
            if (isLightBackground) {
                container.classList.add('canvas-bg-white');
            } else {
                container.classList.add('canvas-bg-dark');
            }

        } catch (error) {
            // Silently handle color update errors
        }
    }

    // Update button states and colors periodically
    const updateInterval = setInterval(() => {
        try {
            const cmdHistory = window.commandHistory || (typeof commandHistory !== 'undefined' ? commandHistory : null);
            if (cmdHistory && typeof cmdHistory.canUndo === 'function' && typeof cmdHistory.canRedo === 'function') {
                updateButtonStates();
                updateButtonColors();
            }
        } catch (error) {
            // Silently handle periodic update errors
        }
    }, 500);

    // Listen for canvas background changes
    if (typeof fabricCanvas !== 'undefined' && fabricCanvas) {
        // Override the setBackgroundColor method to trigger color updates
        const originalSetBackgroundColor = fabricCanvas.setBackgroundColor;
        fabricCanvas.setBackgroundColor = function(color, callback) {
            const result = originalSetBackgroundColor.call(this, color, callback);
            setTimeout(updateButtonColors, 100); // Small delay to ensure color is applied
            return result;
        };

        // Initial color update
        setTimeout(updateButtonColors, 1000);
    }

    console.log('‚úÖ New undo/redo buttons fully configured with dynamic color adaptation');
}

// Setup when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(setupNewUndoRedoButtons, 1000);
});

// Setup again after everything loads
window.addEventListener('load', function() {
    setTimeout(setupNewUndoRedoButtons, 2000);
});

console.log('üîß New undo/redo button script loaded');
</script>

</body>
</html>
